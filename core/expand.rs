#![feature(prelude_import)]
//! Core functionality and types for `PliantDb`.
#![forbid(unsafe_code)]
#![warn(
    clippy::cargo,
    missing_docs,
    clippy::nursery,
    clippy::pedantic,
    future_incompatible,
    rust_2018_idioms
)]
#![allow(clippy::missing_errors_doc, clippy::option_if_let_else)]
#[prelude_import]
use std::prelude::rust_2018::*;
#[macro_use]
extern crate std;
pub use num_traits;
/// Types for creating and validating permissions.
pub mod permissions {
    /// Schema types for permission groups.
    pub mod group {
        use serde::{Deserialize, Serialize};
        use super::Statement;
        use crate::{
            schema::{Collection, CollectionName, InvalidNameError, Name, Schematic, View},
            Error,
        };
        /// A named group of permissions statements.
        #[allow(clippy::module_name_repetitions)]
        pub struct PermissionGroup {
            /// The name of the group. Must be unique.
            pub name: String,
            /// The permission statements.
            pub statements: Vec<Statement>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::module_name_repetitions)]
        impl ::core::fmt::Debug for PermissionGroup {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    PermissionGroup {
                        name: ref __self_0_0,
                        statements: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "PermissionGroup");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "name",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "statements",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PermissionGroup {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "PermissionGroup",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "statements",
                        &self.statements,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PermissionGroup {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "statements" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"statements" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PermissionGroup>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PermissionGroup;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct PermissionGroup",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct PermissionGroup with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Vec<Statement>,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct PermissionGroup with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(PermissionGroup {
                                name: __field0,
                                statements: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<Statement>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "statements",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<Statement>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("statements") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(PermissionGroup {
                                name: __field0,
                                statements: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["name", "statements"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PermissionGroup",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PermissionGroup>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Collection for PermissionGroup {
            fn collection_name() -> Result<CollectionName, InvalidNameError> {
                CollectionName::new("khonsulabs", "permission-group")
            }
            fn define_views(schema: &mut Schematic) -> Result<(), Error> {
                schema.define_view(ByName)
            }
        }
        /// A unique view of permission groups by name.
        pub struct ByName;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ByName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ByName => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ByName");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl View for ByName {
            type Collection = PermissionGroup;
            type Key = String;
            type Value = ();
            fn unique(&self) -> bool {
                true
            }
            fn version(&self) -> u64 {
                1
            }
            fn name(&self) -> Result<Name, InvalidNameError> {
                Name::new("by-name")
            }
            fn map(
                &self,
                document: &crate::document::Document<'_>,
            ) -> crate::schema::MapResult<Self::Key, Self::Value> {
                let group = document.contents::<PermissionGroup>()?;
                Ok(Some(document.emit_key(group.name)))
            }
        }
    }
    /// Types used for granting permissions within `PliantDb`.
    pub mod pliant {
        use actionable::{Action, ResourceName};
        use serde::{Deserialize, Serialize};
        use crate::schema::{CollectionName, ViewName};
        /// Creates a resource name with the database `name`.
        #[must_use]
        pub fn pliantdb_resource_name<'a>() -> ResourceName<'a> {
            ResourceName::named("pliantdb")
        }
        /// Creates a resource name with the database `name`.
        #[must_use]
        pub fn database_resource_name(name: &'_ str) -> ResourceName<'_> {
            pliantdb_resource_name().and(name)
        }
        /// Creates a resource name for a `collection` within a `database`.
        #[must_use]
        pub fn collection_resource_name<'a>(
            database: &'a str,
            collection: &'a CollectionName,
        ) -> ResourceName<'a> {
            database_resource_name(database).and(collection.to_string())
        }
        /// Creates a resource name for a document `id` within `collection` within `database`.
        #[must_use]
        pub fn document_resource_name<'a>(
            database: &'a str,
            collection: &'a CollectionName,
            id: u64,
        ) -> ResourceName<'a> {
            collection_resource_name(database, collection)
                .and("document")
                .and(id)
        }
        /// Creaets a resource name for a `view` within `database`.
        #[must_use]
        pub fn view_resource_name<'a>(database: &'a str, view: &'a ViewName) -> ResourceName<'a> {
            database_resource_name(database)
                .and(view.collection.to_string())
                .and("view")
                .and(view.name.as_ref())
        }
        /// Creates a resource name for `PubSub` `topic` within `database`.
        #[must_use]
        pub fn pubsub_topic_resource_name<'a>(
            database: &'a str,
            topic: &'a str,
        ) -> ResourceName<'a> {
            database_resource_name(database).and("pubsub").and(topic)
        }
        /// Creates a resource name for `key` within `namespace` within the key-value store of `database`.
        #[must_use]
        pub fn kv_key_resource_name<'a>(
            database: &'a str,
            namespace: Option<&'a str>,
            key: &'a str,
        ) -> ResourceName<'a> {
            database_resource_name(database)
                .and("pubsub")
                .and(namespace.unwrap_or(""))
                .and(key)
        }
        /// Actions that can be permitted within `PliantDb`.
        #[allow(clippy::module_name_repetitions)]
        pub enum PliantAction {
            /// Actions that operate on a server
            Server(ServerAction),
            /// Actions that operate on a specific database.
            Database(DatabaseAction),
        }
        impl Action for PliantAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::Server(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("Server"));
                        name
                    }
                    Self::Database(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("Database"));
                        name
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PliantAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        PliantAction::Server(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PliantAction",
                                0u32,
                                "Server",
                                __field0,
                            )
                        }
                        PliantAction::Database(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "PliantAction",
                                1u32,
                                "Database",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PliantAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Server" => _serde::__private::Ok(__Field::__field0),
                                "Database" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Server" => _serde::__private::Ok(__Field::__field0),
                                b"Database" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PliantAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PliantAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum PliantAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<ServerAction>(
                                        __variant,
                                    ),
                                    PliantAction::Server,
                                ),
                                (__Field::__field1, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<DatabaseAction>(
                                        __variant,
                                    ),
                                    PliantAction::Database,
                                ),
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Server", "Database"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "PliantAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PliantAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::module_name_repetitions)]
        impl ::core::clone::Clone for PliantAction {
            #[inline]
            fn clone(&self) -> PliantAction {
                {
                    let _: ::core::clone::AssertParamIsClone<ServerAction>;
                    let _: ::core::clone::AssertParamIsClone<DatabaseAction>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::module_name_repetitions)]
        impl ::core::marker::Copy for PliantAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::module_name_repetitions)]
        impl ::core::fmt::Debug for PliantAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&PliantAction::Server(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Server");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&PliantAction::Database(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Database");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on a server.
        pub enum ServerAction {
            /// Permits connecting to the server. Upon negotiating authentication, the
            /// effective permissions of the connected party will be checked for
            /// permissions to `Connect`. If not allowed, the connection will be
            /// terminated. (Not implemented)
            Connect,
            /// Permits [`ServerConnection::list_available_schemas`](crate::connection::ServerConnection::list_available_schemas).
            ListAvailableSchemas,
            /// Permits [`ServerConnection::list_databases`](crate::connection::ServerConnection::list_databases).
            ListDatabases,
            /// Permits [`ServerConnection::create_database`](crate::connection::ServerConnection::create_database).
            CreateDatabase,
            /// Permits [`ServerConnection::delete_database`](crate::connection::ServerConnection::delete_database).
            DeleteDatabase,
        }
        impl Action for ServerAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::Connect => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Connect",
                        )]))
                    }
                    Self::ListAvailableSchemas => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "ListAvailableSchemas",
                        )]))
                    }
                    Self::ListDatabases => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "ListDatabases",
                        )]))
                    }
                    Self::CreateDatabase => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "CreateDatabase",
                        )]))
                    }
                    Self::DeleteDatabase => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "DeleteDatabase",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ServerAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ServerAction::Connect => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServerAction",
                            0u32,
                            "Connect",
                        ),
                        ServerAction::ListAvailableSchemas => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "ServerAction",
                                1u32,
                                "ListAvailableSchemas",
                            )
                        }
                        ServerAction::ListDatabases => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServerAction",
                            2u32,
                            "ListDatabases",
                        ),
                        ServerAction::CreateDatabase => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServerAction",
                            3u32,
                            "CreateDatabase",
                        ),
                        ServerAction::DeleteDatabase => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServerAction",
                            4u32,
                            "DeleteDatabase",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ServerAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Connect" => _serde::__private::Ok(__Field::__field0),
                                "ListAvailableSchemas" => _serde::__private::Ok(__Field::__field1),
                                "ListDatabases" => _serde::__private::Ok(__Field::__field2),
                                "CreateDatabase" => _serde::__private::Ok(__Field::__field3),
                                "DeleteDatabase" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Connect" => _serde::__private::Ok(__Field::__field0),
                                b"ListAvailableSchemas" => _serde::__private::Ok(__Field::__field1),
                                b"ListDatabases" => _serde::__private::Ok(__Field::__field2),
                                b"CreateDatabase" => _serde::__private::Ok(__Field::__field3),
                                b"DeleteDatabase" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ServerAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ServerAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum ServerAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ServerAction::Connect)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ServerAction::ListAvailableSchemas)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ServerAction::ListDatabases)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ServerAction::CreateDatabase)
                                }
                                (__Field::__field4, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ServerAction::DeleteDatabase)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "Connect",
                        "ListAvailableSchemas",
                        "ListDatabases",
                        "CreateDatabase",
                        "DeleteDatabase",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ServerAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ServerAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ServerAction {
            #[inline]
            fn clone(&self) -> ServerAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for ServerAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ServerAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ServerAction::Connect,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Connect");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&ServerAction::ListAvailableSchemas,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ListAvailableSchemas");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&ServerAction::ListDatabases,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ListDatabases");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&ServerAction::CreateDatabase,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "CreateDatabase");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&ServerAction::DeleteDatabase,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "DeleteDatabase");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on a specific database.
        pub enum DatabaseAction {
            /// Actions that operate on a document.
            Document(DocumentAction),
            /// Actions that operate on a view.
            View(ViewAction),
            /// Actions that operate on transactions.
            Transaction(TransactionAction),
            /// Actions that operate on the `PubSub` system.
            PubSub(PubSubAction),
            /// Actions that operate on the key-value store.
            Kv(KvAction),
        }
        impl Action for DatabaseAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::Document(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("Document"));
                        name
                    }
                    Self::View(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("View"));
                        name
                    }
                    Self::Transaction(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0
                            .insert(0, ::std::borrow::Cow::Borrowed("Transaction"));
                        name
                    }
                    Self::PubSub(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("PubSub"));
                        name
                    }
                    Self::Kv(subaction) => {
                        let mut name = Action::name(subaction);
                        name.0.insert(0, ::std::borrow::Cow::Borrowed("Kv"));
                        name
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DatabaseAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DatabaseAction::Document(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseAction",
                                0u32,
                                "Document",
                                __field0,
                            )
                        }
                        DatabaseAction::View(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseAction",
                                1u32,
                                "View",
                                __field0,
                            )
                        }
                        DatabaseAction::Transaction(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseAction",
                                2u32,
                                "Transaction",
                                __field0,
                            )
                        }
                        DatabaseAction::PubSub(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseAction",
                                3u32,
                                "PubSub",
                                __field0,
                            )
                        }
                        DatabaseAction::Kv(ref __field0) => {
                            _serde::Serializer::serialize_newtype_variant(
                                __serializer,
                                "DatabaseAction",
                                4u32,
                                "Kv",
                                __field0,
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DatabaseAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                4u64 => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 5",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Document" => _serde::__private::Ok(__Field::__field0),
                                "View" => _serde::__private::Ok(__Field::__field1),
                                "Transaction" => _serde::__private::Ok(__Field::__field2),
                                "PubSub" => _serde::__private::Ok(__Field::__field3),
                                "Kv" => _serde::__private::Ok(__Field::__field4),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Document" => _serde::__private::Ok(__Field::__field0),
                                b"View" => _serde::__private::Ok(__Field::__field1),
                                b"Transaction" => _serde::__private::Ok(__Field::__field2),
                                b"PubSub" => _serde::__private::Ok(__Field::__field3),
                                b"Kv" => _serde::__private::Ok(__Field::__field4),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DatabaseAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DatabaseAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DatabaseAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<DocumentAction>(
                                        __variant,
                                    ),
                                    DatabaseAction::Document,
                                ),
                                (__Field::__field1, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<ViewAction>(
                                        __variant,
                                    ),
                                    DatabaseAction::View,
                                ),
                                (__Field::__field2, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<TransactionAction>(
                                        __variant,
                                    ),
                                    DatabaseAction::Transaction,
                                ),
                                (__Field::__field3, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<PubSubAction>(
                                        __variant,
                                    ),
                                    DatabaseAction::PubSub,
                                ),
                                (__Field::__field4, __variant) => _serde::__private::Result::map(
                                    _serde::de::VariantAccess::newtype_variant::<KvAction>(
                                        __variant,
                                    ),
                                    DatabaseAction::Kv,
                                ),
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Document", "View", "Transaction", "PubSub", "Kv"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DatabaseAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DatabaseAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DatabaseAction {
            #[inline]
            fn clone(&self) -> DatabaseAction {
                {
                    let _: ::core::clone::AssertParamIsClone<DocumentAction>;
                    let _: ::core::clone::AssertParamIsClone<ViewAction>;
                    let _: ::core::clone::AssertParamIsClone<TransactionAction>;
                    let _: ::core::clone::AssertParamIsClone<PubSubAction>;
                    let _: ::core::clone::AssertParamIsClone<KvAction>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for DatabaseAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DatabaseAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&DatabaseAction::Document(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Document");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DatabaseAction::View(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "View");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DatabaseAction::Transaction(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Transaction");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DatabaseAction::PubSub(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "PubSub");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DatabaseAction::Kv(ref __self_0),) => {
                        let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Kv");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on a document.
        pub enum DocumentAction {
            /// Allows document retrieval through
            /// [`Connection::get()`](crate::connection::Connection::get) and
            /// [`Connection::get_multiple()`](crate::connection::Connection::get_multiple).
            /// See [`document_resource_name()`] for the format of document resource
            /// names.
            Get,
            /// Allows inserting a document through
            /// [`Connection::apply_transaction()`](crate::connection::Connection::apply_transaction).
            /// See [`collection_resource_name()`] for the format of collection resource
            /// names.
            Insert,
            /// Allows updating a document through
            /// [`Connection::apply_transaction()`](crate::connection::Connection::apply_transaction).
            /// See [`document_resource_name()`] for the format of document resource
            /// names.
            Update,
            /// Allows deleting a document through
            /// [`Connection::apply_transaction()`](crate::connection::Connection::apply_transaction).
            /// See [`document_resource_name()`] for the format of document resource
            /// names.
            Delete,
        }
        impl Action for DocumentAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::Get => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Get",
                        )]))
                    }
                    Self::Insert => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Insert",
                        )]))
                    }
                    Self::Update => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Update",
                        )]))
                    }
                    Self::Delete => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Delete",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DocumentAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        DocumentAction::Get => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DocumentAction",
                            0u32,
                            "Get",
                        ),
                        DocumentAction::Insert => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DocumentAction",
                            1u32,
                            "Insert",
                        ),
                        DocumentAction::Update => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DocumentAction",
                            2u32,
                            "Update",
                        ),
                        DocumentAction::Delete => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DocumentAction",
                            3u32,
                            "Delete",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DocumentAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Get" => _serde::__private::Ok(__Field::__field0),
                                "Insert" => _serde::__private::Ok(__Field::__field1),
                                "Update" => _serde::__private::Ok(__Field::__field2),
                                "Delete" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Get" => _serde::__private::Ok(__Field::__field0),
                                b"Insert" => _serde::__private::Ok(__Field::__field1),
                                b"Update" => _serde::__private::Ok(__Field::__field2),
                                b"Delete" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<DocumentAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DocumentAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum DocumentAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DocumentAction::Get)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DocumentAction::Insert)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DocumentAction::Update)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(DocumentAction::Delete)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] =
                        &["Get", "Insert", "Update", "Delete"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "DocumentAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<DocumentAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DocumentAction {
            #[inline]
            fn clone(&self) -> DocumentAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for DocumentAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DocumentAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&DocumentAction::Get,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Get");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DocumentAction::Insert,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Insert");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DocumentAction::Update,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Update");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&DocumentAction::Delete,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Delete");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on a view.
        pub enum ViewAction {
            /// Allows querying a view with
            /// [`Connection::query()`](crate::connection::Connection::query). See
            /// [`view_resource_name`] for the format of view resource names.
            Query,
            /// Allows reducing a view with
            /// [`Connection::reduce()`](crate::connection::Connection::reduce). See
            /// [`view_resource_name`] for the format of view resource names.
            Reduce,
        }
        impl Action for ViewAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::Query => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Query",
                        )]))
                    }
                    Self::Reduce => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Reduce",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ViewAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        ViewAction::Query => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ViewAction",
                            0u32,
                            "Query",
                        ),
                        ViewAction::Reduce => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ViewAction",
                            1u32,
                            "Reduce",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ViewAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "Query" => _serde::__private::Ok(__Field::__field0),
                                "Reduce" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"Query" => _serde::__private::Ok(__Field::__field0),
                                b"Reduce" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ViewAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ViewAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum ViewAction")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ViewAction::Query)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(ViewAction::Reduce)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["Query", "Reduce"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "ViewAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ViewAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ViewAction {
            #[inline]
            fn clone(&self) -> ViewAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for ViewAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ViewAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&ViewAction::Query,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Query");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&ViewAction::Reduce,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Reduce");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on transactions.
        pub enum TransactionAction {
            /// Allows listing executed transactions with
            /// [`Connection::list_executed_transactions()`](crate::connection::Connection::list_executed_transactions).
            /// This action is checked against the database's resource name. See
            /// [`database_resource_name()`] for the format of database resource names.
            ListExecuted,
            /// Allows retrieving the last executed transaction id with
            /// [`Connection::last_transaction_id()`](crate::connection::Connection::last_transaction_id).
            /// This action is checked against the database's resource name. See
            /// [`database_resource_name()`] for the format of database resource names.
            GetLastId,
        }
        impl Action for TransactionAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::ListExecuted => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "ListExecuted",
                        )]))
                    }
                    Self::GetLastId => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "GetLastId",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for TransactionAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        TransactionAction::ListExecuted => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "TransactionAction",
                                0u32,
                                "ListExecuted",
                            )
                        }
                        TransactionAction::GetLastId => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "TransactionAction",
                            1u32,
                            "GetLastId",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for TransactionAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ListExecuted" => _serde::__private::Ok(__Field::__field0),
                                "GetLastId" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ListExecuted" => _serde::__private::Ok(__Field::__field0),
                                b"GetLastId" => _serde::__private::Ok(__Field::__field1),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<TransactionAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = TransactionAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum TransactionAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(TransactionAction::ListExecuted)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(TransactionAction::GetLastId)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["ListExecuted", "GetLastId"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "TransactionAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<TransactionAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for TransactionAction {
            #[inline]
            fn clone(&self) -> TransactionAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for TransactionAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for TransactionAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&TransactionAction::ListExecuted,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ListExecuted");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&TransactionAction::GetLastId,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "GetLastId");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on the `PubSub` system.
        pub enum PubSubAction {
            /// Allows creating a subscriber with
            /// [`PubSub::create_subscriber()`](crate::pubsub::PubSub::create_subscriber).
            /// This action is checked against the database's resource name. See
            /// [`database_resource_name()`] for the format of database resource names.
            CreateSuscriber,
            /// Allows publishing a payload to a `PubSub` topic with
            /// [`PubSub::publish()`](crate::pubsub::PubSub::publish). See
            /// [`pubsub_topic_resource_name()`] for the format of `PubSub` topic
            /// resource names.
            Publish,
            /// Allows subscribing to a `PubSub` topic with
            /// [`PubSub::subscribe_to()`](crate::pubsub::Subscriber::subscribe_to). See
            /// [`pubsub_topic_resource_name()`] for the format of `PubSub` topic
            /// resource names.
            SubscribeTo,
            /// Allows unsubscribing from a `PubSub` topic with
            /// [`PubSub::unsubscribe_from()`](crate::pubsub::Subscriber::unsubscribe_from). See
            /// [`pubsub_topic_resource_name()`] for the format of `PubSub` topic
            /// resource names.
            UnsubscribeFrom,
        }
        impl Action for PubSubAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::CreateSuscriber => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "CreateSuscriber",
                        )]))
                    }
                    Self::Publish => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "Publish",
                        )]))
                    }
                    Self::SubscribeTo => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "SubscribeTo",
                        )]))
                    }
                    Self::UnsubscribeFrom => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "UnsubscribeFrom",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PubSubAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        PubSubAction::CreateSuscriber => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "PubSubAction",
                                0u32,
                                "CreateSuscriber",
                            )
                        }
                        PubSubAction::Publish => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PubSubAction",
                            1u32,
                            "Publish",
                        ),
                        PubSubAction::SubscribeTo => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "PubSubAction",
                            2u32,
                            "SubscribeTo",
                        ),
                        PubSubAction::UnsubscribeFrom => {
                            _serde::Serializer::serialize_unit_variant(
                                __serializer,
                                "PubSubAction",
                                3u32,
                                "UnsubscribeFrom",
                            )
                        }
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PubSubAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                2u64 => _serde::__private::Ok(__Field::__field2),
                                3u64 => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "CreateSuscriber" => _serde::__private::Ok(__Field::__field0),
                                "Publish" => _serde::__private::Ok(__Field::__field1),
                                "SubscribeTo" => _serde::__private::Ok(__Field::__field2),
                                "UnsubscribeFrom" => _serde::__private::Ok(__Field::__field3),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"CreateSuscriber" => _serde::__private::Ok(__Field::__field0),
                                b"Publish" => _serde::__private::Ok(__Field::__field1),
                                b"SubscribeTo" => _serde::__private::Ok(__Field::__field2),
                                b"UnsubscribeFrom" => _serde::__private::Ok(__Field::__field3),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<PubSubAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PubSubAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "enum PubSubAction",
                            )
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(PubSubAction::CreateSuscriber)
                                }
                                (__Field::__field1, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(PubSubAction::Publish)
                                }
                                (__Field::__field2, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(PubSubAction::SubscribeTo)
                                }
                                (__Field::__field3, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(PubSubAction::UnsubscribeFrom)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &[
                        "CreateSuscriber",
                        "Publish",
                        "SubscribeTo",
                        "UnsubscribeFrom",
                    ];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "PubSubAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<PubSubAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for PubSubAction {
            #[inline]
            fn clone(&self) -> PubSubAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for PubSubAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for PubSubAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&PubSubAction::CreateSuscriber,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "CreateSuscriber");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&PubSubAction::Publish,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Publish");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&PubSubAction::SubscribeTo,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "SubscribeTo");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&PubSubAction::UnsubscribeFrom,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "UnsubscribeFrom");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// Actions that operate on the key-value store.
        pub enum KvAction {
            /// Allows executing a key-value store operation with
            /// [`Kv::execute_key_operation()`](crate::kv::Kv::execute_key_operation).
            /// See [`kv_key_resource_name()`] for the format of key resource names.
            ExecuteOperation,
        }
        impl Action for KvAction {
            fn name(&self) -> actionable::ActionName {
                match self {
                    Self::ExecuteOperation => {
                        actionable::ActionName(<[_]>::into_vec(box [::std::borrow::Cow::Borrowed(
                            "ExecuteOperation",
                        )]))
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for KvAction {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    match *self {
                        KvAction::ExecuteOperation => _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "KvAction",
                            0u32,
                            "ExecuteOperation",
                        ),
                    }
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for KvAction {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "variant identifier",
                            )
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"variant index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "ExecuteOperation" => _serde::__private::Ok(__Field::__field0),
                                _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                )),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"ExecuteOperation" => _serde::__private::Ok(__Field::__field0),
                                _ => {
                                    let __value = &_serde::__private::from_utf8_lossy(__value);
                                    _serde::__private::Err(_serde::de::Error::unknown_variant(
                                        __value, VARIANTS,
                                    ))
                                }
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<KvAction>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = KvAction;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "enum KvAction")
                        }
                        fn visit_enum<__A>(
                            self,
                            __data: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::EnumAccess<'de>,
                        {
                            match match _serde::de::EnumAccess::variant(__data) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                (__Field::__field0, __variant) => {
                                    match _serde::de::VariantAccess::unit_variant(__variant) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                    _serde::__private::Ok(KvAction::ExecuteOperation)
                                }
                            }
                        }
                    }
                    const VARIANTS: &'static [&'static str] = &["ExecuteOperation"];
                    _serde::Deserializer::deserialize_enum(
                        __deserializer,
                        "KvAction",
                        VARIANTS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<KvAction>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for KvAction {
            #[inline]
            fn clone(&self) -> KvAction {
                {
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for KvAction {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for KvAction {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&KvAction::ExecuteOperation,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ExecuteOperation");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
    }
    /// Schema types for roles.
    pub mod role {
        use serde::{Deserialize, Serialize};
        use crate::{
            schema::{Collection, CollectionName, InvalidNameError, Name, Schematic, View},
            Error,
        };
        /// An assignable role, which grants permissions based on the associated [`PermissionGroup`](crate::permissions::PermissionGroup)s.
        #[allow(clippy::module_name_repetitions)]
        pub struct Role {
            /// The name of the role. Must be unique.
            pub name: String,
            /// The IDs of the permission groups this role belongs to.
            pub groups: Vec<u64>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        #[allow(clippy::module_name_repetitions)]
        impl ::core::fmt::Debug for Role {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Role {
                        name: ref __self_0_0,
                        groups: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Role");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "name",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "groups",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Role {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Role",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "groups",
                        &self.groups,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Role {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::__private::Ok(__Field::__field0),
                                "groups" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::__private::Ok(__Field::__field0),
                                b"groups" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Role>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Role;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct Role")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Role with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<Vec<u64>>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Role with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Role {
                                name: __field0,
                                groups: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<String> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Vec<u64>> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "groups",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<u64>>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("groups") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Role {
                                name: __field0,
                                groups: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["name", "groups"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Role",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Role>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Collection for Role {
            fn collection_name() -> Result<CollectionName, InvalidNameError> {
                CollectionName::new("khonsulabs", "role")
            }
            fn define_views(schema: &mut Schematic) -> Result<(), Error> {
                schema.define_view(ByName)
            }
        }
        /// A unique view of roles by name.
        pub struct ByName;
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ByName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ByName => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ByName");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl View for ByName {
            type Collection = Role;
            type Key = String;
            type Value = ();
            fn unique(&self) -> bool {
                true
            }
            fn version(&self) -> u64 {
                1
            }
            fn name(&self) -> Result<Name, InvalidNameError> {
                Name::new("by-name")
            }
            fn map(
                &self,
                document: &crate::document::Document<'_>,
            ) -> crate::schema::MapResult<Self::Key, Self::Value> {
                let role = document.contents::<Role>()?;
                Ok(Some(document.emit_key(role.name)))
            }
        }
    }
    pub use actionable::{
        Action, ActionName, ActionNameList, Actionable, Dispatcher, Identifier, PermissionDenied,
        Permissions, ResourceName, Statement,
    };
    pub use self::{group::PermissionGroup, role::Role};
}
/// Types for interacting with `PliantDb`.
pub mod connection {
    use std::{borrow::Cow, marker::PhantomData, ops::Range};
    use async_trait::async_trait;
    use serde::{Deserialize, Serialize};
    use crate::{
        document::{Document, Header},
        schema::{self, view, Key, Map, MappedDocument, MappedValue, Schema, SchemaName},
        transaction::{self, Command, Operation, OperationResult, Transaction},
        Error,
    };
    /// Defines all interactions with a [`schema::Schema`], regardless of whether it is local or remote.
    pub trait Connection: Send + Sync {
        /// Accesses a collection for the connected [`schema::Schema`].
        fn collection<'a, C: schema::Collection + 'static>(&'a self) -> Collection<'a, Self, C>
        where
            Self: Sized,
        {
            Collection::new(self)
        }
        /// Inserts a newly created document into the connected [`schema::Schema`] for the [`Collection`] `C`.
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn insert<'life0, 'async_trait, C: schema::Collection>(
            &'life0 self,
            contents: Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Header, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            C: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<Header, Error>>
                {
                    return __ret;
                }
                let __self = self;
                let contents = contents;
                let __ret: Result<Header, Error> = {
                    let mut tx = Transaction::default();
                    tx.push(Operation {
                        collection: C::collection_name()?,
                        command: Command::Insert {
                            contents: Cow::from(contents),
                        },
                    });
                    let results = __self.apply_transaction(tx).await?;
                    if let OperationResult::DocumentUpdated { header, .. } = &results[0] {
                        Ok(header.clone())
                    } else {
                        {
                            {
                                :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: "] , & match (& "apply_transaction on a single insert should yield a single DocumentUpdated entry" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }))
                            }
                        }
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        /// Updates an existing document in the connected [`schema::Schema`] for the
        /// [`Collection`] `C`. Upon success, `doc.revision` will be updated with
        /// the new revision.
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn update<'life0, 'life1, 'life2, 'async_trait>(
            &'life0 self,
            doc: &'life1 mut Document<'life2>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let doc = doc;
                let __ret: Result<(), Error> = {
                    let mut tx = Transaction::default();
                    tx.push(Operation {
                        collection: doc.collection.clone(),
                        command: Command::Update {
                            header: Cow::Owned(doc.header.as_ref().clone()),
                            contents: Cow::Owned(doc.contents.to_vec()),
                        },
                    });
                    let results = __self.apply_transaction(tx).await?;
                    if let OperationResult::DocumentUpdated { header, .. } = &results[0] {
                        doc.header = Cow::Owned(header.clone());
                        Ok(())
                    } else {
                        {
                            {
                                :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: "] , & match (& "apply_transaction on a single update should yield a single DocumentUpdated entry" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }))
                            }
                        }
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        /// Retrieves a stored document from [`Collection`] `C` identified by `id`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn get<'life0, 'async_trait, C: schema::Collection>(
            &'life0 self,
            id: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Option<Document<'static>>, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            C: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Retrieves all documents matching `ids`. Documents that are not found
        /// are not returned, but no error will be generated.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn get_multiple<'life0, 'life1, 'async_trait, C: schema::Collection>(
            &'life0 self,
            ids: &'life1 [u64],
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Vec<Document<'static>>, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            C: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Removes a `Document` from the database.
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn delete<'life0, 'life1, 'life2, 'async_trait>(
            &'life0 self,
            doc: &'life1 Document<'life2>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let doc = doc;
                let __ret: Result<(), Error> = {
                    let mut tx = Transaction::default();
                    tx.push(Operation {
                        collection: doc.collection.clone(),
                        command: Command::Delete {
                            header: Cow::Owned(doc.header.as_ref().clone()),
                        },
                    });
                    let results = __self.apply_transaction(tx).await?;
                    if let OperationResult::DocumentDeleted { .. } = &results[0] {
                        Ok(())
                    } else {
                        {
                            {
                                :: core :: panicking :: panic_fmt (:: core :: fmt :: Arguments :: new_v1 (& ["internal error: entered unreachable code: "] , & match (& "apply_transaction on a single update should yield a single DocumentUpdated entry" ,) { (arg0 ,) => [:: core :: fmt :: ArgumentV1 :: new (arg0 , :: core :: fmt :: Display :: fmt)] , }))
                            }
                        }
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        /// Initializes [`View`] for [`schema::View`] `V`.
        #[must_use]
        fn view<V: schema::View>(&'_ self) -> View<'_, Self, V>
        where
            Self: Sized,
        {
            View::new(self)
        }
        /// Queries for view entries matching [`View`].
        #[must_use]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn query<'life0, 'async_trait, V: schema::View>(
            &'life0 self,
            key: Option<QueryKey<V::Key>>,
            access_policy: AccessPolicy,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Vec<Map<V::Key, V::Value>>, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            Self: Sized,
            V: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Queries for view entries matching [`View`].
        #[must_use]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn query_with_docs<'life0, 'async_trait, V: schema::View>(
            &'life0 self,
            key: Option<QueryKey<V::Key>>,
            access_policy: AccessPolicy,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<Vec<MappedDocument<V::Key, V::Value>>, Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            Self: Sized,
            V: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Reduces the view entries matching [`View`].
        #[must_use]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn reduce<'life0, 'async_trait, V: schema::View>(
            &'life0 self,
            key: Option<QueryKey<V::Key>>,
            access_policy: AccessPolicy,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<V::Value, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            Self: Sized,
            V: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Reduces the view entries matching [`View`], reducing the values by each
        /// unique key.
        #[must_use]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn reduce_grouped<'life0, 'async_trait, V: schema::View>(
            &'life0 self,
            key: Option<QueryKey<V::Key>>,
            access_policy: AccessPolicy,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<Vec<MappedValue<V::Key, V::Value>>, Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            Self: Sized,
            V: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Applies a [`Transaction`] to the [`schema::Schema`]. If any operation in the
        /// [`Transaction`] fails, none of the operations will be applied to the
        /// [`schema::Schema`].
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn apply_transaction<'life0, 'async_trait>(
            &'life0 self,
            transaction: Transaction<'static>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Vec<OperationResult>, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Lists executed [`Transaction`]s from this [`schema::Schema`]. By default, a maximum of
        /// 1000 entries will be returned, but that limit can be overridden by
        /// setting `result_limit`. A hard limit of 100,000 results will be
        /// returned. To begin listing after another known `transaction_id`, pass
        /// `transaction_id + 1` into `starting_id`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn list_executed_transactions<'life0, 'async_trait>(
            &'life0 self,
            starting_id: Option<u64>,
            result_limit: Option<usize>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<Vec<transaction::Executed<'static>>, Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Fetches the last transaction id that has been committed, if any.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn last_transaction_id<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Option<u64>, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
    }
    /// Interacts with a collection over a `Connection`.
    pub struct Collection<'a, Cn, Cl> {
        connection: &'a Cn,
        _phantom: PhantomData<Cl>,
    }
    impl<'a, Cn, Cl> Collection<'a, Cn, Cl>
    where
        Cn: Connection,
        Cl: schema::Collection,
    {
        /// Creates a new instance using `connection`.
        pub fn new(connection: &'a Cn) -> Self {
            Self {
                connection,
                _phantom: PhantomData::default(),
            }
        }
        /// Adds a new `Document<Cl>` with the contents `item`.
        pub async fn push<S: Serialize + Sync>(&self, item: &S) -> Result<Header, crate::Error> {
            let contents = serde_cbor::to_vec(item)?;
            Ok(self.connection.insert::<Cl>(contents).await?)
        }
        /// Retrieves a `Document<Cl>` with `id` from the connection.
        pub async fn get(&self, id: u64) -> Result<Option<Document<'static>>, Error> {
            self.connection.get::<Cl>(id).await
        }
    }
    /// Parameters to query a `schema::View`.
    pub struct View<'a, Cn, V: schema::View> {
        connection: &'a Cn,
        /// Key filtering criteria.
        pub key: Option<QueryKey<V::Key>>,
        /// The view's data access policy. The default value is [`AccessPolicy::UpdateBefore`].
        pub access_policy: AccessPolicy,
    }
    impl<'a, Cn, V> View<'a, Cn, V>
    where
        V: schema::View,
        Cn: Connection,
    {
        fn new(connection: &'a Cn) -> Self {
            Self {
                connection,
                key: None,
                access_policy: AccessPolicy::UpdateBefore,
            }
        }
        /// Filters for entries in the view with `key`.
        #[must_use]
        pub fn with_key(mut self, key: V::Key) -> Self {
            self.key = Some(QueryKey::Matches(key));
            self
        }
        /// Filters for entries in the view with `keys`.
        #[must_use]
        pub fn with_keys(mut self, keys: Vec<V::Key>) -> Self {
            self.key = Some(QueryKey::Multiple(keys));
            self
        }
        /// Filters for entries in the view with the range `keys`.
        #[must_use]
        pub fn with_key_range(mut self, range: Range<V::Key>) -> Self {
            self.key = Some(QueryKey::Range(range));
            self
        }
        /// Sets the access policy for queries.
        pub fn with_access_policy(mut self, policy: AccessPolicy) -> Self {
            self.access_policy = policy;
            self
        }
        /// Executes the query and retrieves the results.
        pub async fn query(self) -> Result<Vec<Map<V::Key, V::Value>>, Error> {
            self.connection
                .query::<V>(self.key, self.access_policy)
                .await
        }
        /// Executes the query and retrieves the results with the associated `Document`s.
        pub async fn query_with_docs(self) -> Result<Vec<MappedDocument<V::Key, V::Value>>, Error> {
            self.connection
                .query_with_docs::<V>(self.key, self.access_policy)
                .await
        }
        /// Executes a reduce over the results of the query
        pub async fn reduce(self) -> Result<V::Value, Error> {
            self.connection
                .reduce::<V>(self.key, self.access_policy)
                .await
        }
        /// Executes a reduce over the results of the query
        pub async fn reduce_grouped(self) -> Result<Vec<MappedValue<V::Key, V::Value>>, Error> {
            self.connection
                .reduce_grouped::<V>(self.key, self.access_policy)
                .await
        }
    }
    /// Filters a [`View`] by key.
    pub enum QueryKey<K> {
        /// Matches all entries with the key provided.
        Matches(K),
        /// Matches all entires with keys in the range provided.
        Range(Range<K>),
        /// Matches all entries that have keys that are included in the set provided.
        Multiple(Vec<K>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<K: ::core::clone::Clone> ::core::clone::Clone for QueryKey<K> {
        #[inline]
        fn clone(&self) -> QueryKey<K> {
            match (&*self,) {
                (&QueryKey::Matches(ref __self_0),) => {
                    QueryKey::Matches(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&QueryKey::Range(ref __self_0),) => {
                    QueryKey::Range(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&QueryKey::Multiple(ref __self_0),) => {
                    QueryKey::Multiple(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<K> _serde::Serialize for QueryKey<K>
        where
            K: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    QueryKey::Matches(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "QueryKey",
                            0u32,
                            "Matches",
                            __field0,
                        )
                    }
                    QueryKey::Range(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "QueryKey",
                        1u32,
                        "Range",
                        __field0,
                    ),
                    QueryKey::Multiple(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "QueryKey",
                            2u32,
                            "Multiple",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, K> _serde::Deserialize<'de> for QueryKey<K>
        where
            K: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Matches" => _serde::__private::Ok(__Field::__field0),
                            "Range" => _serde::__private::Ok(__Field::__field1),
                            "Multiple" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Matches" => _serde::__private::Ok(__Field::__field0),
                            b"Range" => _serde::__private::Ok(__Field::__field1),
                            b"Multiple" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, K>
                where
                    K: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<QueryKey<K>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, K> _serde::de::Visitor<'de> for __Visitor<'de, K>
                where
                    K: _serde::Deserialize<'de>,
                {
                    type Value = QueryKey<K>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum QueryKey")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<K>(__variant),
                                QueryKey::Matches,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Range<K>>(__variant),
                                QueryKey::Range,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<K>>(__variant),
                                QueryKey::Multiple,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Matches", "Range", "Multiple"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "QueryKey",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<QueryKey<K>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<K: ::core::fmt::Debug> ::core::fmt::Debug for QueryKey<K> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&QueryKey::Matches(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Matches");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&QueryKey::Range(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Range");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&QueryKey::Multiple(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Multiple");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[allow(clippy::use_self)]
    impl<K: Key> QueryKey<K> {
        /// Converts this key to a serialized format using the [`Key`] trait.
        pub fn serialized(&self) -> Result<QueryKey<Vec<u8>>, Error> {
            match self {
                Self::Matches(key) => key
                    .as_big_endian_bytes()
                    .map_err(|err| Error::Database(view::Error::KeySerialization(err).to_string()))
                    .map(|v| QueryKey::Matches(v.to_vec())),
                Self::Range(range) => {
                    let start = range
                        .start
                        .as_big_endian_bytes()
                        .map_err(|err| {
                            Error::Database(view::Error::KeySerialization(err).to_string())
                        })?
                        .to_vec();
                    let end = range
                        .end
                        .as_big_endian_bytes()
                        .map_err(|err| {
                            Error::Database(view::Error::KeySerialization(err).to_string())
                        })?
                        .to_vec();
                    Ok(QueryKey::Range(start..end))
                }
                Self::Multiple(keys) => {
                    let keys = keys
                        .iter()
                        .map(|key| {
                            key.as_big_endian_bytes()
                                .map(|key| key.to_vec())
                                .map_err(|err| {
                                    Error::Database(view::Error::KeySerialization(err).to_string())
                                })
                        })
                        .collect::<Result<Vec<_>, Error>>()?;
                    Ok(QueryKey::Multiple(keys))
                }
            }
        }
    }
    #[allow(clippy::use_self)]
    impl QueryKey<Vec<u8>> {
        /// Deserializes the bytes into `K` via the [`Key`] trait.
        pub fn deserialized<K: Key>(&self) -> Result<QueryKey<K>, Error> {
            match self {
                Self::Matches(key) => K::from_big_endian_bytes(key)
                    .map_err(|err| Error::Database(view::Error::KeySerialization(err).to_string()))
                    .map(QueryKey::Matches),
                Self::Range(range) => {
                    let start = K::from_big_endian_bytes(&range.start).map_err(|err| {
                        Error::Database(view::Error::KeySerialization(err).to_string())
                    })?;
                    let end = K::from_big_endian_bytes(&range.end).map_err(|err| {
                        Error::Database(view::Error::KeySerialization(err).to_string())
                    })?;
                    Ok(QueryKey::Range(start..end))
                }
                Self::Multiple(keys) => {
                    let keys = keys
                        .iter()
                        .map(|key| {
                            K::from_big_endian_bytes(key).map_err(|err| {
                                Error::Database(view::Error::KeySerialization(err).to_string())
                            })
                        })
                        .collect::<Result<Vec<_>, Error>>()?;
                    Ok(QueryKey::Multiple(keys))
                }
            }
        }
    }
    /// Changes how the view's outdated data will be treated.
    pub enum AccessPolicy {
        /// Update any changed documents before returning a response.
        UpdateBefore,
        /// Return the results, which may be out-of-date, and start an update job in
        /// the background. This pattern is useful when you want to ensure you
        /// provide consistent response times while ensuring the database is
        /// updating in the background.
        UpdateAfter,
        /// Returns the restuls, which may be out-of-date, and do not start any
        /// background jobs. This mode is useful if you're using a view as a cache
        /// and have a background process that is responsible for controlling when
        /// data is refreshed and updated. While the default `UpdateBefore`
        /// shouldn't have much overhead, this option removes all overhead related
        /// to view updating from the query.
        NoUpdate,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AccessPolicy {
        #[inline]
        fn clone(&self) -> AccessPolicy {
            match (&*self,) {
                (&AccessPolicy::UpdateBefore,) => AccessPolicy::UpdateBefore,
                (&AccessPolicy::UpdateAfter,) => AccessPolicy::UpdateAfter,
                (&AccessPolicy::NoUpdate,) => AccessPolicy::NoUpdate,
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AccessPolicy {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    AccessPolicy::UpdateBefore => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AccessPolicy",
                        0u32,
                        "UpdateBefore",
                    ),
                    AccessPolicy::UpdateAfter => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AccessPolicy",
                        1u32,
                        "UpdateAfter",
                    ),
                    AccessPolicy::NoUpdate => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "AccessPolicy",
                        2u32,
                        "NoUpdate",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AccessPolicy {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UpdateBefore" => _serde::__private::Ok(__Field::__field0),
                            "UpdateAfter" => _serde::__private::Ok(__Field::__field1),
                            "NoUpdate" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UpdateBefore" => _serde::__private::Ok(__Field::__field0),
                            b"UpdateAfter" => _serde::__private::Ok(__Field::__field1),
                            b"NoUpdate" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<AccessPolicy>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AccessPolicy;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum AccessPolicy")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(AccessPolicy::UpdateBefore)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(AccessPolicy::UpdateAfter)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(AccessPolicy::NoUpdate)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["UpdateBefore", "UpdateAfter", "NoUpdate"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "AccessPolicy",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<AccessPolicy>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AccessPolicy {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&AccessPolicy::UpdateBefore,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UpdateBefore");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&AccessPolicy::UpdateAfter,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UpdateAfter");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&AccessPolicy::NoUpdate,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "NoUpdate");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// Functions for interacting with a multi-database `PliantDb` instance.
    #[allow(clippy::module_name_repetitions)]
    pub trait ServerConnection: Send + Sync {
        /// Creates a database named `name` with the `Schema` provided.
        ///
        /// ## Errors
        ///
        /// * [`Error::InvalidDatabaseName`]: `name` must begin with an alphanumeric
        ///   character (`[a-zA-Z0-9]`), and all remaining characters must be
        ///   alphanumeric, a period (`.`), or a hyphen (`-`).
        /// * [`Error::DatabaseNameAlreadyTaken]: `name` was already used for a
        ///   previous database name. Database names are case insensitive.
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn create_database<'life0, 'life1, 'async_trait, DB: Schema>(
            &'life0 self,
            name: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), crate::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            DB: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), crate::Error>>
                {
                    return __ret;
                }
                let __self = self;
                let name = name;
                let __ret: Result<(), crate::Error> = {
                    __self
                        .create_database_with_schema(name, DB::schema_name()?)
                        .await
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        /// Creates a database named `name` using the [`SchemaName`] `schema`.
        ///
        /// ## Errors
        ///
        /// * [`Error::InvalidDatabaseName`]: `name` must begin with an alphanumeric
        ///   character (`[a-zA-Z0-9]`), and all remaining characters must be
        ///   alphanumeric, a period (`.`), or a hyphen (`-`).
        /// * [`Error::DatabaseNameAlreadyTaken]: `name` was already used for a
        ///   previous database name. Database names are case insensitive.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn create_database_with_schema<'life0, 'life1, 'async_trait>(
            &'life0 self,
            name: &'life1 str,
            schema: SchemaName,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), crate::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Deletes a database named `name`.
        ///
        /// ## Errors
        ///
        /// * [`Error::DatabaseNotFound`]: database `name` does not exist.
        /// * [`Error::Io)`]: an error occurred while deleting files.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn delete_database<'life0, 'life1, 'async_trait>(
            &'life0 self,
            name: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), crate::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Lists the databases on this server.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn list_databases<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Vec<Database>, crate::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Lists the [`SchemaName`]s on this server.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn list_available_schemas<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Vec<SchemaName>, crate::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
    }
    /// A database on a server.
    pub struct Database {
        /// The name of the database.
        pub name: String,
        /// The schema defining the database.
        pub schema: SchemaName,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Database {
        #[inline]
        fn clone(&self) -> Database {
            match *self {
                Database {
                    name: ref __self_0_0,
                    schema: ref __self_0_1,
                } => Database {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    schema: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Database {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Database {
        #[inline]
        fn eq(&self, other: &Database) -> bool {
            match *other {
                Database {
                    name: ref __self_1_0,
                    schema: ref __self_1_1,
                } => match *self {
                    Database {
                        name: ref __self_0_0,
                        schema: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Database) -> bool {
            match *other {
                Database {
                    name: ref __self_1_0,
                    schema: ref __self_1_1,
                } => match *self {
                    Database {
                        name: ref __self_0_0,
                        schema: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Database {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::__private::Ok(__Field::__field0),
                            "schema" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::__private::Ok(__Field::__field0),
                            b"schema" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Database>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Database;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Database")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Database with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<SchemaName>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Database with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Database {
                            name: __field0,
                            schema: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<SchemaName> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "schema",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<SchemaName>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("name") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("schema") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Database {
                            name: __field0,
                            schema: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "schema"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Database",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Database>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Database {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Database",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "schema",
                    &self.schema,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Database {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Database {
                    name: ref __self_0_0,
                    schema: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Database");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "name",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "schema",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
}
/// Types for interacting with `Document`s.
pub mod document {
    use std::borrow::Cow;
    use serde::{Deserialize, Serialize};
    use crate::schema::{CollectionName, Key, Map};
    mod revision {
        use serde::{Deserialize, Serialize};
        use sha2::{Digest, Sha256};
        /// Information about a `Document`'s revision history.
        pub struct Revision {
            /// The current revision id of the document. This value is sequentially incremented on each document update.
            pub id: u32,
            /// The SHA256 digest of the bytes contained within the `Document`.
            pub sha256: [u8; 32],
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Revision {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Revision {
                        id: ref __self_0_0,
                        sha256: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Revision");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "id",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "sha256",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Revision {
            #[inline]
            fn clone(&self) -> Revision {
                match *self {
                    Revision {
                        id: ref __self_0_0,
                        sha256: ref __self_0_1,
                    } => Revision {
                        id: ::core::clone::Clone::clone(&(*__self_0_0)),
                        sha256: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Revision {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Revision {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                    let _: ::core::cmp::AssertParamIsEq<[u8; 32]>;
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Revision {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Revision {
            #[inline]
            fn eq(&self, other: &Revision) -> bool {
                match *other {
                    Revision {
                        id: ref __self_1_0,
                        sha256: ref __self_1_1,
                    } => match *self {
                        Revision {
                            id: ref __self_0_0,
                            sha256: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Revision) -> bool {
                match *other {
                    Revision {
                        id: ref __self_1_0,
                        sha256: ref __self_1_1,
                    } => match *self {
                        Revision {
                            id: ref __self_0_0,
                            sha256: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Revision {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Revision",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "sha256",
                        &self.sha256,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Revision {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "id" => _serde::__private::Ok(__Field::__field0),
                                "sha256" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"id" => _serde::__private::Ok(__Field::__field0),
                                b"sha256" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Revision>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Revision;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct Revision")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Revision with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<[u8; 32]>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Revision with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Revision {
                                id: __field0,
                                sha256: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<[u8; 32]> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "id",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "sha256",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<[u8; 32]>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("id") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("sha256") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Revision {
                                id: __field0,
                                sha256: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["id", "sha256"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Revision",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Revision>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        impl Revision {
            /// Creates the first revision for a document with the SHA256 digest of the passed bytes.
            #[must_use]
            pub fn new(contents: &[u8]) -> Self {
                Self::with_id(0, contents)
            }
            /// Creates a revision with `id` for a document with the SHA256 digest of the passed bytes.
            #[must_use]
            pub fn with_id(id: u32, contents: &[u8]) -> Self {
                Self {
                    id,
                    sha256: digest(contents),
                }
            }
            /// Creates the next revision in sequence with an updated digest. If the digest doesn't change, None is returned.
            ///
            /// # Panics
            ///
            /// Panics if `id` overflows.
            #[must_use]
            pub fn next_revision(&self, new_contents: &[u8]) -> Option<Self> {
                let sha256 = digest(new_contents);
                if sha256 == self.sha256 {
                    None
                } else {
                    Some(Self {
                        id: self.id.checked_add(1).expect(
                            "need to implement revision id wrapping or increase revision id size",
                        ),
                        sha256,
                    })
                }
            }
        }
        fn digest(payload: &[u8]) -> [u8; 32] {
            let mut hasher = Sha256::default();
            hasher.update(payload);
            hasher.finalize().into()
        }
    }
    pub use revision::Revision;
    /// The header of a `Document`.
    pub struct Header {
        /// The id of the Document. Unique across the collection `C`
        pub id: u64,
        /// The revision of the stored document.
        pub revision: Revision,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Header {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Header",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "revision",
                    &self.revision,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Header {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "revision" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"revision" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Header>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Header;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Header")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Header with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<Revision>(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Header with 2 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Header {
                            id: __field0,
                            revision: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Revision> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "revision",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Revision>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("revision") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Header {
                            id: __field0,
                            revision: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["id", "revision"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Header",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Header>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Header {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Header {
                    id: ref __self_0_0,
                    revision: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Header");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "revision",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Header {
        #[inline]
        fn clone(&self) -> Header {
            match *self {
                Header {
                    id: ref __self_0_0,
                    revision: ref __self_0_1,
                } => Header {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    revision: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Header {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Header {
        #[inline]
        fn eq(&self, other: &Header) -> bool {
            match *other {
                Header {
                    id: ref __self_1_0,
                    revision: ref __self_1_1,
                } => match *self {
                    Header {
                        id: ref __self_0_0,
                        revision: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Header) -> bool {
            match *other {
                Header {
                    id: ref __self_1_0,
                    revision: ref __self_1_1,
                } => match *self {
                    Header {
                        id: ref __self_0_0,
                        revision: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Header {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Header {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<u64>;
                let _: ::core::cmp::AssertParamIsEq<Revision>;
            }
        }
    }
    /// Contains a serialized document in the database.
    pub struct Document<'a> {
        /// The `Id` of the `Collection` this document belongs to.
        pub collection: CollectionName,
        /// The header of the document, which contains the id and `Revision`.
        pub header: Cow<'a, Header>,
        /// The serialized bytes of the stored item.
        pub contents: Cow<'a, [u8]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Document<'a> {
        #[inline]
        fn clone(&self) -> Document<'a> {
            match *self {
                Document {
                    collection: ref __self_0_0,
                    header: ref __self_0_1,
                    contents: ref __self_0_2,
                } => Document {
                    collection: ::core::clone::Clone::clone(&(*__self_0_0)),
                    header: ::core::clone::Clone::clone(&(*__self_0_1)),
                    contents: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Document<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Document",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collection",
                    &self.collection,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "header",
                    &self.header,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "contents",
                    &self.contents,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, 'a> _serde::Deserialize<'de> for Document<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "collection" => _serde::__private::Ok(__Field::__field0),
                            "header" => _serde::__private::Ok(__Field::__field1),
                            "contents" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"collection" => _serde::__private::Ok(__Field::__field0),
                            b"header" => _serde::__private::Ok(__Field::__field1),
                            b"contents" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, 'a> {
                    marker: _serde::__private::PhantomData<Document<'a>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Document<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Document")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            CollectionName,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Document with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Cow<'a, Header>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Document with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Cow<'a, [u8]>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Document with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Document {
                            collection: __field0,
                            header: __field1,
                            contents: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<CollectionName> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Cow<'a, Header>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Cow<'a, [u8]>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collection",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<CollectionName>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "header",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Cow<'a, Header>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "contents",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Cow<'a, [u8]>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("collection") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("header") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("contents") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Document {
                            collection: __field0,
                            header: __field1,
                            contents: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["collection", "header", "contents"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Document",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Document<'a>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Document<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Document {
                    collection: ref __self_0_0,
                    header: ref __self_0_1,
                    contents: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Document");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "header",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "contents",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<'a> Document<'a> {
        /// Creates a new document with `contents`.
        #[must_use]
        pub fn new(id: u64, contents: Cow<'a, [u8]>, collection: CollectionName) -> Self {
            let revision = Revision::new(&contents);
            Self {
                header: Cow::Owned(Header { id, revision }),
                contents,
                collection,
            }
        }
        /// Creates a new document with serialized bytes from `contents`.
        pub fn with_contents<S: Serialize>(
            id: u64,
            contents: &S,
            collection: CollectionName,
        ) -> Result<Self, serde_cbor::Error> {
            let contents = Cow::from(serde_cbor::to_vec(contents)?);
            Ok(Self::new(id, contents, collection))
        }
        /// Retrieves `contents` through deserialization into the type `D`.
        pub fn contents<D: Deserialize<'a>>(&'a self) -> Result<D, serde_cbor::Error> {
            serde_cbor::from_slice(&self.contents)
        }
        /// Serializes and stores `contents` into this document.
        pub fn set_contents<S: Serialize>(
            &mut self,
            contents: &S,
        ) -> Result<(), serde_cbor::Error> {
            self.contents = Cow::from(serde_cbor::to_vec(contents)?);
            Ok(())
        }
        /// Creates a new revision.
        ///
        /// **WARNING: This normally should not be used** outside of implementing a
        /// backend for `PliantDb`. To update a document, use `set_contents()` and
        /// send the document with the existing `Revision` information.
        #[must_use]
        pub fn create_new_revision(&self, contents: Cow<'a, [u8]>) -> Option<Self> {
            self.header
                .revision
                .next_revision(&contents)
                .map(|revision| Self {
                    header: Cow::Owned(Header {
                        id: self.header.id,
                        revision,
                    }),
                    contents,
                    collection: self.collection.clone(),
                })
        }
        /// Creates a `Map` result with an empty key and value.
        #[must_use]
        pub fn emit(&self) -> Map<(), ()> {
            self.emit_key_and_value((), ())
        }
        /// Creates a `Map` result with a `key` and an empty value.
        #[must_use]
        pub fn emit_key<K: Key>(&self, key: K) -> Map<K, ()> {
            self.emit_key_and_value(key, ())
        }
        /// Creates a `Map` result with `value` and an empty key.
        #[must_use]
        pub fn emit_value<Value: Serialize>(&self, value: Value) -> Map<(), Value> {
            self.emit_key_and_value((), value)
        }
        /// Creates a `Map` result with a `key` and `value`.
        #[must_use]
        pub fn emit_key_and_value<K: Key, Value: Serialize>(
            &self,
            key: K,
            value: Value,
        ) -> Map<K, Value> {
            Map::new(self.header.id, key, value)
        }
        /// Clone the document's data so that it's no longer borrowed in the original lifetime `'a`.
        #[must_use]
        pub fn to_owned(&self) -> Document<'static> {
            Document::<'static> {
                collection: self.collection.clone(),
                header: Cow::Owned(self.header.as_ref().clone()),
                contents: Cow::Owned(self.contents.as_ref().to_vec()),
            }
        }
    }
}
/// Limits used within `PliantDb`.
pub mod limits {
    /// The maximum number of results allowed to be returned from `list_executed_transactions`.
    pub const LIST_TRANSACTIONS_MAX_RESULTS: usize = 1000;
    /// If no `result_limit` is specified, this value is the limit used by default.
    pub const LIST_TRANSACTIONS_DEFAULT_RESULT_COUNT: usize = 100;
}
/// Types for defining database schema.
pub mod schema {
    mod collection {
        use std::fmt::Debug;
        use super::names::InvalidNameError;
        use crate::{
            schema::{CollectionName, Schematic},
            Error,
        };
        /// A namespaced collection of `Document<Self>` items and views.
        pub trait Collection: Debug + Send + Sync {
            /// The `Id` of this collection.
            fn collection_name() -> Result<CollectionName, InvalidNameError>;
            /// Defines all `View`s in this collection in `schema`.
            fn define_views(schema: &mut Schematic) -> Result<(), Error>;
        }
    }
    mod names {
        use std::{
            borrow::Cow,
            convert::{TryFrom, TryInto},
            fmt::{Debug, Display, Write},
            sync::Arc,
        };
        use serde::{Deserialize, Serialize};
        /// A valid schema name. Must be alphanumeric (`a-zA-Z9-0`) or a hyphen (`-`).
        /// Cloning this structure shares the underlying string data, regardless of
        /// whether it's a static string literal or an owned String.
        #[serde(try_from = "String")]
        #[serde(into = "String")]
        pub struct Name(Arc<Cow<'static, str>>);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Name {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Name(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Name {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Name {
            #[inline]
            fn eq(&self, other: &Name) -> bool {
                match *other {
                    Name(ref __self_1_0) => match *self {
                        Name(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Name) -> bool {
                match *other {
                    Name(ref __self_1_0) => match *self {
                        Name(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Name {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Name {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Arc<Cow<'static, str>>>;
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Name {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::__private::Result::and_then(
                        <String as _serde::Deserialize>::deserialize(__deserializer),
                        |v| {
                            _serde::__private::TryFrom::try_from(v)
                                .map_err(_serde::de::Error::custom)
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Name {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    _serde::Serialize::serialize(
                        &_serde::__private::Into::<String>::into(_serde::__private::Clone::clone(
                            self,
                        )),
                        __serializer,
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Name {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Name(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Name");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Name {
            #[inline]
            fn clone(&self) -> Name {
                match *self {
                    Name(ref __self_0_0) => Name(::core::clone::Clone::clone(&(*__self_0_0))),
                }
            }
        }
        /// An invalid name was used in a schema definition.
        #[error("invalid name: {0}")]
        pub struct InvalidNameError(pub String);
        #[allow(unused_qualifications)]
        impl std::error::Error for InvalidNameError {}
        #[allow(unused_qualifications)]
        impl std::fmt::Display for InvalidNameError {
            #[allow(clippy::used_underscore_binding)]
            fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                #[allow(unused_imports)]
                use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
                #[allow(unused_variables, deprecated)]
                let Self(_0) = self;
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["invalid name: "],
                    &match (&_0.as_display(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for InvalidNameError {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    InvalidNameError(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidNameError");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for InvalidNameError {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    _serde::Serializer::serialize_newtype_struct(
                        __serializer,
                        "InvalidNameError",
                        &self.0,
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for InvalidNameError {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<InvalidNameError>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = InvalidNameError;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "tuple struct InvalidNameError",
                            )
                        }
                        #[inline]
                        fn visit_newtype_struct<__E>(
                            self,
                            __e: __E,
                        ) -> _serde::__private::Result<Self::Value, __E::Error>
                        where
                            __E: _serde::Deserializer<'de>,
                        {
                            let __field0: String =
                                match <String as _serde::Deserialize>::deserialize(__e) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                            _serde::__private::Ok(InvalidNameError(__field0))
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"tuple struct InvalidNameError with 1 element",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(InvalidNameError(__field0))
                        }
                    }
                    _serde::Deserializer::deserialize_newtype_struct(
                        __deserializer,
                        "InvalidNameError",
                        __Visitor {
                            marker: _serde::__private::PhantomData::<InvalidNameError>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for InvalidNameError {
            #[inline]
            fn clone(&self) -> InvalidNameError {
                match *self {
                    InvalidNameError(ref __self_0_0) => {
                        InvalidNameError(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl Name {
            /// Creates a new name after validating it.
            ///
            /// # Errors
            /// Returns [`InvalidNameError`] if the value passed contains any characters
            /// other than `a-zA-Z9-0` or a hyphen (`-`).
            pub fn new<T: TryInto<Self, Error = InvalidNameError>>(
                contents: T,
            ) -> Result<Self, InvalidNameError> {
                contents.try_into()
            }
            fn validate_name(name: &str) -> Result<(), InvalidNameError> {
                if name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {
                    Ok(())
                } else {
                    Err(InvalidNameError(name.to_string()))
                }
            }
        }
        impl TryFrom<&'static str> for Name {
            type Error = InvalidNameError;
            fn try_from(value: &'static str) -> Result<Self, InvalidNameError> {
                Self::validate_name(value)?;
                Ok(Self(Arc::new(Cow::Borrowed(value))))
            }
        }
        impl TryFrom<String> for Name {
            type Error = InvalidNameError;
            fn try_from(value: String) -> Result<Self, InvalidNameError> {
                Self::validate_name(&value)?;
                Ok(Self(Arc::new(Cow::Owned(value))))
            }
        }
        #[allow(clippy::from_over_into)]
        impl Into<String> for Name {
            fn into(self) -> String {
                self.0.to_string()
            }
        }
        impl Display for Name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                Display::fmt(&self.0, f)
            }
        }
        impl AsRef<str> for Name {
            fn as_ref(&self) -> &str {
                self.0.as_ref()
            }
        }
        /// The owner of a schema item. This should represent the company, group, or
        /// individual that created the item in question. This value is used for
        /// namespacing. Changing this after values are in use is not supported without
        /// manual migrations at this time.
        #[serde(transparent)]
        pub struct Authority(Name);
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for Authority {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    Authority(ref __self_0_0) => ::core::hash::Hash::hash(&(*__self_0_0), state),
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Authority {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Authority {
            #[inline]
            fn eq(&self, other: &Authority) -> bool {
                match *other {
                    Authority(ref __self_1_0) => match *self {
                        Authority(ref __self_0_0) => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Authority) -> bool {
                match *other {
                    Authority(ref __self_1_0) => match *self {
                        Authority(ref __self_0_0) => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Authority {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Authority {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Name>;
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Authority {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::__private::Result::map(
                        _serde::Deserialize::deserialize(__deserializer),
                        |__transparent| Authority { 0: __transparent },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Authority {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    _serde::Serialize::serialize(&self.0, __serializer)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Authority {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Authority(ref __self_0_0) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Authority");
                        let _ =
                            ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Authority {
            #[inline]
            fn clone(&self) -> Authority {
                match *self {
                    Authority(ref __self_0_0) => {
                        Authority(::core::clone::Clone::clone(&(*__self_0_0)))
                    }
                }
            }
        }
        impl TryFrom<&'static str> for Authority {
            type Error = InvalidNameError;
            fn try_from(value: &'static str) -> Result<Self, InvalidNameError> {
                Ok(Self(Name::new(value)?))
            }
        }
        impl TryFrom<String> for Authority {
            type Error = InvalidNameError;
            fn try_from(value: String) -> Result<Self, InvalidNameError> {
                Ok(Self(Name::new(value)?))
            }
        }
        impl Display for Authority {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                Display::fmt(&self.0, f)
            }
        }
        /// The name of a [`Schema`](super::Schema).
        pub struct SchemaName {
            /// The authority of this schema.
            pub authority: Authority,
            /// The name of this schema.
            pub name: Name,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for SchemaName {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    SchemaName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for SchemaName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SchemaName {
            #[inline]
            fn eq(&self, other: &SchemaName) -> bool {
                match *other {
                    SchemaName {
                        authority: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        SchemaName {
                            authority: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &SchemaName) -> bool {
                match *other {
                    SchemaName {
                        authority: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        SchemaName {
                            authority: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for SchemaName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SchemaName {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Authority>;
                    let _: ::core::cmp::AssertParamIsEq<Name>;
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SchemaName {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "authority" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"authority" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<SchemaName>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SchemaName;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct SchemaName",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Authority,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct SchemaName with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<Name>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct SchemaName with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(SchemaName {
                                authority: __field0,
                                name: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Authority> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Name> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "authority",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Authority>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Name>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("authority") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(SchemaName {
                                authority: __field0,
                                name: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["authority", "name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SchemaName",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<SchemaName>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SchemaName {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SchemaName",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "authority",
                        &self.authority,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SchemaName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    SchemaName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "SchemaName");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "authority",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "name",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SchemaName {
            #[inline]
            fn clone(&self) -> SchemaName {
                match *self {
                    SchemaName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => SchemaName {
                        authority: ::core::clone::Clone::clone(&(*__self_0_0)),
                        name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl SchemaName {
            /// Creates a new schema name.
            pub fn new<
                A: TryInto<Authority, Error = InvalidNameError>,
                N: TryInto<Name, Error = InvalidNameError>,
            >(
                authority: A,
                name: N,
            ) -> Result<Self, InvalidNameError> {
                let authority = authority.try_into()?;
                let name = name.try_into()?;
                Ok(Self { authority, name })
            }
        }
        impl Display for SchemaName {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                Display::fmt(&self.authority, f)?;
                f.write_char('.')?;
                Display::fmt(&self.name, f)
            }
        }
        impl TryFrom<&str> for SchemaName {
            type Error = InvalidNameError;
            fn try_from(schema_name: &str) -> Result<Self, InvalidNameError> {
                let parts = schema_name.split('.').collect::<Vec<&str>>();
                if parts.len() == 2 {
                    let mut parts = parts.into_iter();
                    let authority = parts.next().unwrap();
                    let name = parts.next().unwrap();
                    Self::new(authority.to_string(), name.to_string())
                } else {
                    Err(InvalidNameError(schema_name.to_string()))
                }
            }
        }
        /// The name of a [`Collection`](super::Collection).
        pub struct CollectionName {
            /// The authority of this collection.
            pub authority: Authority,
            /// The name of this collection.
            pub name: Name,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for CollectionName {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    CollectionName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for CollectionName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CollectionName {
            #[inline]
            fn eq(&self, other: &CollectionName) -> bool {
                match *other {
                    CollectionName {
                        authority: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        CollectionName {
                            authority: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &CollectionName) -> bool {
                match *other {
                    CollectionName {
                        authority: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        CollectionName {
                            authority: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for CollectionName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CollectionName {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Authority>;
                    let _: ::core::cmp::AssertParamIsEq<Name>;
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CollectionName {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "authority" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"authority" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<CollectionName>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CollectionName;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(
                                __formatter,
                                "struct CollectionName",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Authority,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct CollectionName with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<Name>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct CollectionName with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(CollectionName {
                                authority: __field0,
                                name: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<Authority> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Name> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "authority",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Authority>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Name>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("authority") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(CollectionName {
                                authority: __field0,
                                name: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["authority", "name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CollectionName",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<CollectionName>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CollectionName {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "CollectionName",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "authority",
                        &self.authority,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CollectionName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    CollectionName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "CollectionName");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "authority",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "name",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CollectionName {
            #[inline]
            fn clone(&self) -> CollectionName {
                match *self {
                    CollectionName {
                        authority: ref __self_0_0,
                        name: ref __self_0_1,
                    } => CollectionName {
                        authority: ::core::clone::Clone::clone(&(*__self_0_0)),
                        name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl CollectionName {
            /// Creates a new collection name.
            pub fn new<
                A: TryInto<Authority, Error = InvalidNameError>,
                N: TryInto<Name, Error = InvalidNameError>,
            >(
                authority: A,
                name: N,
            ) -> Result<Self, InvalidNameError> {
                let authority = authority.try_into()?;
                let name = name.try_into()?;
                Ok(Self { authority, name })
            }
        }
        impl Display for CollectionName {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                Display::fmt(&self.authority, f)?;
                f.write_char('.')?;
                Display::fmt(&self.name, f)
            }
        }
        impl TryFrom<&str> for CollectionName {
            type Error = InvalidNameError;
            fn try_from(collection_name: &str) -> Result<Self, InvalidNameError> {
                let parts = collection_name.split('.').collect::<Vec<&str>>();
                if parts.len() == 2 {
                    let mut parts = parts.into_iter();
                    let authority = parts.next().unwrap();
                    let name = parts.next().unwrap();
                    Self::new(authority.to_string(), name.to_string())
                } else {
                    Err(InvalidNameError(collection_name.to_string()))
                }
            }
        }
        /// The name of a [`View`](super::View).
        pub struct ViewName {
            /// The name of the collection that contains this view.
            pub collection: CollectionName,
            /// The name of this view.
            pub name: Name,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::hash::Hash for ViewName {
            fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
                match *self {
                    ViewName {
                        collection: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        ::core::hash::Hash::hash(&(*__self_0_0), state);
                        ::core::hash::Hash::hash(&(*__self_0_1), state)
                    }
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for ViewName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for ViewName {
            #[inline]
            fn eq(&self, other: &ViewName) -> bool {
                match *other {
                    ViewName {
                        collection: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        ViewName {
                            collection: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &ViewName) -> bool {
                match *other {
                    ViewName {
                        collection: ref __self_1_0,
                        name: ref __self_1_1,
                    } => match *self {
                        ViewName {
                            collection: ref __self_0_0,
                            name: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for ViewName {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for ViewName {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<CollectionName>;
                    let _: ::core::cmp::AssertParamIsEq<Name>;
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for ViewName {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "collection" => _serde::__private::Ok(__Field::__field0),
                                "name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"collection" => _serde::__private::Ok(__Field::__field0),
                                b"name" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<ViewName>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = ViewName;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct ViewName")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                CollectionName,
                            >(&mut __seq)
                            {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct ViewName with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 =
                                match match _serde::de::SeqAccess::next_element::<Name>(&mut __seq)
                                {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct ViewName with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            _serde::__private::Ok(ViewName {
                                collection: __field0,
                                name: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<CollectionName> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<Name> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "collection",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<CollectionName>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<Name>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("collection") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("name") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(ViewName {
                                collection: __field0,
                                name: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["collection", "name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "ViewName",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<ViewName>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for ViewName {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "ViewName",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "collection",
                        &self.collection,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for ViewName {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    ViewName {
                        collection: ref __self_0_0,
                        name: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "ViewName");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "collection",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "name",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for ViewName {
            #[inline]
            fn clone(&self) -> ViewName {
                match *self {
                    ViewName {
                        collection: ref __self_0_0,
                        name: ref __self_0_1,
                    } => ViewName {
                        collection: ::core::clone::Clone::clone(&(*__self_0_0)),
                        name: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        impl ViewName {
            /// Creates a new view name.
            pub fn new<
                C: TryInto<CollectionName, Error = InvalidNameError>,
                N: TryInto<Name, Error = InvalidNameError>,
            >(
                collection: C,
                name: N,
            ) -> Result<Self, InvalidNameError> {
                let collection = collection.try_into()?;
                let name = name.try_into()?;
                Ok(Self { collection, name })
            }
        }
        impl Display for ViewName {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                Display::fmt(&self.collection, f)?;
                f.write_char('.')?;
                Display::fmt(&self.name, f)
            }
        }
    }
    mod schematic {
        use std::{
            any::TypeId,
            collections::{HashMap, HashSet},
            fmt::Debug,
        };
        use crate::{
            schema::{
                collection::Collection,
                view::{self, Serialized},
                CollectionName, View, ViewName,
            },
            Error,
        };
        /// A collection of defined collections and views.
        pub struct Schematic {
            contained_collections: HashSet<CollectionName>,
            collections_by_type_id: HashMap<TypeId, CollectionName>,
            views: HashMap<TypeId, Box<dyn view::Serialized>>,
            views_by_name: HashMap<ViewName, TypeId>,
            views_by_collection: HashMap<CollectionName, Vec<TypeId>>,
            unique_views_by_collection: HashMap<CollectionName, Vec<TypeId>>,
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::default::Default for Schematic {
            #[inline]
            fn default() -> Schematic {
                Schematic {
                    contained_collections: ::core::default::Default::default(),
                    collections_by_type_id: ::core::default::Default::default(),
                    views: ::core::default::Default::default(),
                    views_by_name: ::core::default::Default::default(),
                    views_by_collection: ::core::default::Default::default(),
                    unique_views_by_collection: ::core::default::Default::default(),
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Schematic {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Schematic {
                        contained_collections: ref __self_0_0,
                        collections_by_type_id: ref __self_0_1,
                        views: ref __self_0_2,
                        views_by_name: ref __self_0_3,
                        views_by_collection: ref __self_0_4,
                        unique_views_by_collection: ref __self_0_5,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Schematic");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "contained_collections",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "collections_by_type_id",
                            &&(*__self_0_1),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "views",
                            &&(*__self_0_2),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "views_by_name",
                            &&(*__self_0_3),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "views_by_collection",
                            &&(*__self_0_4),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "unique_views_by_collection",
                            &&(*__self_0_5),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        impl Schematic {
            /// Adds the collection `C` and its views.
            pub fn define_collection<C: Collection + 'static>(&mut self) -> Result<(), Error> {
                self.collections_by_type_id
                    .insert(TypeId::of::<C>(), C::collection_name()?);
                self.contained_collections.insert(C::collection_name()?);
                C::define_views(self)
            }
            /// Adds the view `V`.
            pub fn define_view<V: View + 'static>(&mut self, view: V) -> Result<(), Error> {
                let name = view.view_name()?;
                let collection = view.collection()?;
                let unique = view.unique();
                self.views.insert(TypeId::of::<V>(), Box::new(view));
                self.views_by_name.insert(name, TypeId::of::<V>());
                if unique {
                    let unique_views = self
                        .unique_views_by_collection
                        .entry(collection.clone())
                        .or_insert_with(Vec::new);
                    unique_views.push(TypeId::of::<V>());
                }
                let views = self
                    .views_by_collection
                    .entry(collection)
                    .or_insert_with(Vec::new);
                views.push(TypeId::of::<V>());
                Ok(())
            }
            /// Returns `true` if this schema contains the collection `C`.
            #[must_use]
            pub fn contains<C: Collection + 'static>(&self) -> bool {
                self.collections_by_type_id.contains_key(&TypeId::of::<C>())
            }
            /// Returns `true` if this schema contains the collection `C`.
            #[must_use]
            pub fn contains_collection_id(&self, collection: &CollectionName) -> bool {
                self.contained_collections.contains(collection)
            }
            /// Looks up a [`view::Serialized`] by name.
            #[must_use]
            pub fn view_by_name(&self, name: &ViewName) -> Option<&'_ dyn view::Serialized> {
                self.views_by_name
                    .get(name)
                    .and_then(|type_id| self.views.get(type_id))
                    .map(AsRef::as_ref)
            }
            /// Looks up a [`view::Serialized`] through the the type `V`.
            #[must_use]
            pub fn view<V: View + 'static>(&self) -> Option<&'_ dyn view::Serialized> {
                self.views.get(&TypeId::of::<V>()).map(AsRef::as_ref)
            }
            /// Iterates over all registered views.
            pub fn views(&self) -> impl Iterator<Item = &'_ dyn view::Serialized> {
                self.views.values().map(AsRef::as_ref)
            }
            /// Iterates over all views that belong to `collection`.
            #[must_use]
            pub fn views_in_collection(
                &self,
                collection: &CollectionName,
            ) -> Option<Vec<&'_ dyn view::Serialized>> {
                self.views_by_collection.get(collection).map(|view_ids| {
                    view_ids
                        .iter()
                        .filter_map(|id| self.views.get(id).map(AsRef::as_ref))
                        .collect()
                })
            }
            /// Iterates over all views that are unique that belong to `collection`.
            #[must_use]
            pub fn unique_views_in_collection(
                &self,
                collection: &CollectionName,
            ) -> Option<Vec<&'_ dyn view::Serialized>> {
                self.unique_views_by_collection
                    .get(collection)
                    .map(|view_ids| {
                        view_ids
                            .iter()
                            .filter_map(|id| self.views.get(id).map(AsRef::as_ref))
                            .collect()
                    })
            }
        }
    }
    /// Types for defining map/reduce-powered `View`s.
    pub mod view {
        use std::fmt::Debug;
        use serde::{Deserialize, Serialize};
        use crate::{
            document::Document,
            schema::{Collection, CollectionName, InvalidNameError, Name, ViewName},
        };
        /// Types for defining a `Map` within a `View`.
        pub mod map {
            use std::{borrow::Cow, convert::TryInto};
            use num_traits::{FromPrimitive, ToPrimitive};
            use serde::{de::DeserializeOwned, Deserialize, Serialize};
            use crate::{document::Document, schema::view};
            /// A document's entry in a View's mappings.
            pub struct Map<K: Key = (), V: Serialize = ()> {
                /// The id of the document that emitted this entry.
                pub source: u64,
                /// The key used to index the View.
                pub key: K,
                /// An associated value stored in the view.
                pub value: V,
            }
            impl<K: Key, V: Serialize> ::core::marker::StructuralPartialEq for Map<K, V> {}
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::cmp::PartialEq + Key, V: ::core::cmp::PartialEq + Serialize>
                ::core::cmp::PartialEq for Map<K, V>
            {
                #[inline]
                fn eq(&self, other: &Map<K, V>) -> bool {
                    match *other {
                        Map {
                            source: ref __self_1_0,
                            key: ref __self_1_1,
                            value: ref __self_1_2,
                        } => match *self {
                            Map {
                                source: ref __self_0_0,
                                key: ref __self_0_1,
                                value: ref __self_0_2,
                            } => {
                                (*__self_0_0) == (*__self_1_0)
                                    && (*__self_0_1) == (*__self_1_1)
                                    && (*__self_0_2) == (*__self_1_2)
                            }
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &Map<K, V>) -> bool {
                    match *other {
                        Map {
                            source: ref __self_1_0,
                            key: ref __self_1_1,
                            value: ref __self_1_2,
                        } => match *self {
                            Map {
                                source: ref __self_0_0,
                                key: ref __self_0_1,
                                value: ref __self_0_2,
                            } => {
                                (*__self_0_0) != (*__self_1_0)
                                    || (*__self_0_1) != (*__self_1_1)
                                    || (*__self_0_2) != (*__self_1_2)
                            }
                        },
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::fmt::Debug + Key, V: ::core::fmt::Debug + Serialize> ::core::fmt::Debug
                for Map<K, V>
            {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        Map {
                            source: ref __self_0_0,
                            key: ref __self_0_1,
                            value: ref __self_0_2,
                        } => {
                            let debug_trait_builder =
                                &mut ::core::fmt::Formatter::debug_struct(f, "Map");
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "source",
                                &&(*__self_0_0),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "key",
                                &&(*__self_0_1),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "value",
                                &&(*__self_0_2),
                            );
                            ::core::fmt::DebugStruct::finish(debug_trait_builder)
                        }
                    }
                }
            }
            impl<K: Key, V: Serialize> Map<K, V> {
                /// Serializes this map.
                pub fn serialized(&self) -> Result<Serialized, view::Error> {
                    Ok(Serialized {
                        source: self.source,
                        key: self
                            .key
                            .as_big_endian_bytes()
                            .map_err(view::Error::KeySerialization)?
                            .to_vec(),
                        value: serde_cbor::to_vec(&self.value)?,
                    })
                }
            }
            /// A document's entry in a View's mappings.
            pub struct MappedDocument<K: Key = (), V: Serialize = ()> {
                /// The id of the document that emitted this entry.
                pub document: Document<'static>,
                /// The key used to index the View.
                pub key: K,
                /// An associated value stored in the view.
                pub value: V,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::fmt::Debug + Key, V: ::core::fmt::Debug + Serialize> ::core::fmt::Debug
                for MappedDocument<K, V>
            {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        MappedDocument {
                            document: ref __self_0_0,
                            key: ref __self_0_1,
                            value: ref __self_0_2,
                        } => {
                            let debug_trait_builder =
                                &mut ::core::fmt::Formatter::debug_struct(f, "MappedDocument");
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "document",
                                &&(*__self_0_0),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "key",
                                &&(*__self_0_1),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "value",
                                &&(*__self_0_2),
                            );
                            ::core::fmt::DebugStruct::finish(debug_trait_builder)
                        }
                    }
                }
            }
            impl<K: Key, V: Serialize> Map<K, V> {
                /// Creates a new Map entry for the document with id `source`.
                pub fn new(source: u64, key: K, value: V) -> Self {
                    Self { source, key, value }
                }
            }
            /// Represents a document's entry in a View's mappings, serialized and ready to store.
            pub struct Serialized {
                /// The id of the document that emitted this entry.
                pub source: u64,
                /// The key used to index the View.
                pub key: Vec<u8>,
                /// An associated value stored in the view.
                pub value: Vec<u8>,
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(rust_2018_idioms, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl _serde::Serialize for Serialized {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "Serialized",
                            false as usize + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "source",
                            &self.source,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            &self.value,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(rust_2018_idioms, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de> _serde::Deserialize<'de> for Serialized {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __field2,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    2u64 => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "source" => _serde::__private::Ok(__Field::__field0),
                                    "key" => _serde::__private::Ok(__Field::__field1),
                                    "value" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"source" => _serde::__private::Ok(__Field::__field0),
                                    b"key" => _serde::__private::Ok(__Field::__field1),
                                    b"value" => _serde::__private::Ok(__Field::__field2),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de> {
                            marker: _serde::__private::PhantomData<Serialized>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                            type Value = Serialized;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct Serialized",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<u64>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct Serialized with 3 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                        &mut __seq,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    1usize,
                                                    &"struct Serialized with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                let __field2 =
                                    match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                        &mut __seq,
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde::__private::Err(
                                                _serde::de::Error::invalid_length(
                                                    2usize,
                                                    &"struct Serialized with 3 elements",
                                                ),
                                            );
                                        }
                                    };
                                _serde::__private::Ok(Serialized {
                                    source: __field0,
                                    key: __field1,
                                    value: __field2,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<u64> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<Vec<u8>> =
                                    _serde::__private::None;
                                let mut __field2: _serde::__private::Option<Vec<u8>> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("source")) ;
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<u64>(
                                                    &mut __map,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<Vec<u8>>(
                                                    &mut __map,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field2 => {
                                            if _serde::__private::Option::is_some(&__field2) {
                                                return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("value")) ;
                                            }
                                            __field2 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<Vec<u8>>(
                                                    &mut __map,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("source") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("key") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field2 = match __field2 {
                                    _serde::__private::Some(__field2) => __field2,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("value") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(Serialized {
                                    source: __field0,
                                    key: __field1,
                                    value: __field2,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["source", "key", "value"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "Serialized",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<Serialized>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::fmt::Debug for Serialized {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        Serialized {
                            source: ref __self_0_0,
                            key: ref __self_0_1,
                            value: ref __self_0_2,
                        } => {
                            let debug_trait_builder =
                                &mut ::core::fmt::Formatter::debug_struct(f, "Serialized");
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "source",
                                &&(*__self_0_0),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "key",
                                &&(*__self_0_1),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "value",
                                &&(*__self_0_2),
                            );
                            ::core::fmt::DebugStruct::finish(debug_trait_builder)
                        }
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl ::core::clone::Clone for Serialized {
                #[inline]
                fn clone(&self) -> Serialized {
                    match *self {
                        Serialized {
                            source: ref __self_0_0,
                            key: ref __self_0_1,
                            value: ref __self_0_2,
                        } => Serialized {
                            source: ::core::clone::Clone::clone(&(*__self_0_0)),
                            key: ::core::clone::Clone::clone(&(*__self_0_1)),
                            value: ::core::clone::Clone::clone(&(*__self_0_2)),
                        },
                    }
                }
            }
            impl Serialized {
                /// Deserializes this map.
                pub fn deserialized<K: Key, V: Serialize + DeserializeOwned>(
                    &self,
                ) -> Result<Map<K, V>, view::Error> {
                    Ok(Map {
                        source: self.source,
                        key: K::from_big_endian_bytes(&self.key)
                            .map_err(view::Error::KeySerialization)?,
                        value: serde_cbor::from_slice(&self.value)?,
                    })
                }
            }
            /// A key value pair
            pub struct MappedValue<K: Key, V> {
                /// The key responsible for generating the value
                pub key: K,
                /// The value generated by the `View`
                pub value: V,
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::clone::Clone + Key, V: ::core::clone::Clone> ::core::clone::Clone
                for MappedValue<K, V>
            {
                #[inline]
                fn clone(&self) -> MappedValue<K, V> {
                    match *self {
                        MappedValue {
                            key: ref __self_0_0,
                            value: ref __self_0_1,
                        } => MappedValue {
                            key: ::core::clone::Clone::clone(&(*__self_0_0)),
                            value: ::core::clone::Clone::clone(&(*__self_0_1)),
                        },
                    }
                }
            }
            impl<K: Key, V> ::core::marker::StructuralPartialEq for MappedValue<K, V> {}
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::cmp::PartialEq + Key, V: ::core::cmp::PartialEq> ::core::cmp::PartialEq
                for MappedValue<K, V>
            {
                #[inline]
                fn eq(&self, other: &MappedValue<K, V>) -> bool {
                    match *other {
                        MappedValue {
                            key: ref __self_1_0,
                            value: ref __self_1_1,
                        } => match *self {
                            MappedValue {
                                key: ref __self_0_0,
                                value: ref __self_0_1,
                            } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                        },
                    }
                }
                #[inline]
                fn ne(&self, other: &MappedValue<K, V>) -> bool {
                    match *other {
                        MappedValue {
                            key: ref __self_1_0,
                            value: ref __self_1_1,
                        } => match *self {
                            MappedValue {
                                key: ref __self_0_0,
                                value: ref __self_0_1,
                            } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                        },
                    }
                }
            }
            #[automatically_derived]
            #[allow(unused_qualifications)]
            impl<K: ::core::fmt::Debug + Key, V: ::core::fmt::Debug> ::core::fmt::Debug for MappedValue<K, V> {
                fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                    match *self {
                        MappedValue {
                            key: ref __self_0_0,
                            value: ref __self_0_1,
                        } => {
                            let debug_trait_builder =
                                &mut ::core::fmt::Formatter::debug_struct(f, "MappedValue");
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "key",
                                &&(*__self_0_0),
                            );
                            let _ = ::core::fmt::DebugStruct::field(
                                debug_trait_builder,
                                "value",
                                &&(*__self_0_1),
                            );
                            ::core::fmt::DebugStruct::finish(debug_trait_builder)
                        }
                    }
                }
            }
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(rust_2018_idioms, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<K: Key, V> _serde::Serialize for MappedValue<K, V>
                where
                    K: _serde::Serialize,
                    V: _serde::Serialize,
                {
                    fn serialize<__S>(
                        &self,
                        __serializer: __S,
                    ) -> _serde::__private::Result<__S::Ok, __S::Error>
                    where
                        __S: _serde::Serializer,
                    {
                        let mut __serde_state = match _serde::Serializer::serialize_struct(
                            __serializer,
                            "MappedValue",
                            false as usize + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "key",
                            &self.key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStruct::serialize_field(
                            &mut __serde_state,
                            "value",
                            &self.value,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStruct::end(__serde_state)
                    }
                }
            };
            #[doc(hidden)]
            #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
            const _: () = {
                #[allow(rust_2018_idioms, clippy::useless_attribute)]
                extern crate serde as _serde;
                #[automatically_derived]
                impl<'de, K: Key, V> _serde::Deserialize<'de> for MappedValue<K, V>
                where
                    K: _serde::Deserialize<'de>,
                    V: _serde::Deserialize<'de>,
                {
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        #[allow(non_camel_case_types)]
                        enum __Field {
                            __field0,
                            __field1,
                            __ignore,
                        }
                        struct __FieldVisitor;
                        impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                            type Value = __Field;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "field identifier",
                                )
                            }
                            fn visit_u64<__E>(
                                self,
                                __value: u64,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    0u64 => _serde::__private::Ok(__Field::__field0),
                                    1u64 => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_str<__E>(
                                self,
                                __value: &str,
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    "key" => _serde::__private::Ok(__Field::__field0),
                                    "value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                            fn visit_bytes<__E>(
                                self,
                                __value: &[u8],
                            ) -> _serde::__private::Result<Self::Value, __E>
                            where
                                __E: _serde::de::Error,
                            {
                                match __value {
                                    b"key" => _serde::__private::Ok(__Field::__field0),
                                    b"value" => _serde::__private::Ok(__Field::__field1),
                                    _ => _serde::__private::Ok(__Field::__ignore),
                                }
                            }
                        }
                        impl<'de> _serde::Deserialize<'de> for __Field {
                            #[inline]
                            fn deserialize<__D>(
                                __deserializer: __D,
                            ) -> _serde::__private::Result<Self, __D::Error>
                            where
                                __D: _serde::Deserializer<'de>,
                            {
                                _serde::Deserializer::deserialize_identifier(
                                    __deserializer,
                                    __FieldVisitor,
                                )
                            }
                        }
                        struct __Visitor<'de, K: Key, V>
                        where
                            K: _serde::Deserialize<'de>,
                            V: _serde::Deserialize<'de>,
                        {
                            marker: _serde::__private::PhantomData<MappedValue<K, V>>,
                            lifetime: _serde::__private::PhantomData<&'de ()>,
                        }
                        impl<'de, K: Key, V> _serde::de::Visitor<'de> for __Visitor<'de, K, V>
                        where
                            K: _serde::Deserialize<'de>,
                            V: _serde::Deserialize<'de>,
                        {
                            type Value = MappedValue<K, V>;
                            fn expecting(
                                &self,
                                __formatter: &mut _serde::__private::Formatter,
                            ) -> _serde::__private::fmt::Result {
                                _serde::__private::Formatter::write_str(
                                    __formatter,
                                    "struct MappedValue",
                                )
                            }
                            #[inline]
                            fn visit_seq<__A>(
                                self,
                                mut __seq: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::SeqAccess<'de>,
                            {
                                let __field0 = match match _serde::de::SeqAccess::next_element::<K>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct MappedValue with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                let __field1 = match match _serde::de::SeqAccess::next_element::<V>(
                                    &mut __seq,
                                ) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                } {
                                    _serde::__private::Some(__value) => __value,
                                    _serde::__private::None => {
                                        return _serde::__private::Err(
                                            _serde::de::Error::invalid_length(
                                                1usize,
                                                &"struct MappedValue with 2 elements",
                                            ),
                                        );
                                    }
                                };
                                _serde::__private::Ok(MappedValue {
                                    key: __field0,
                                    value: __field1,
                                })
                            }
                            #[inline]
                            fn visit_map<__A>(
                                self,
                                mut __map: __A,
                            ) -> _serde::__private::Result<Self::Value, __A::Error>
                            where
                                __A: _serde::de::MapAccess<'de>,
                            {
                                let mut __field0: _serde::__private::Option<K> =
                                    _serde::__private::None;
                                let mut __field1: _serde::__private::Option<V> =
                                    _serde::__private::None;
                                while let _serde::__private::Some(__key) =
                                    match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                {
                                    match __key {
                                        __Field::__field0 => {
                                            if _serde::__private::Option::is_some(&__field0) {
                                                return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                            }
                                            __field0 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<K>(
                                                    &mut __map,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        __Field::__field1 => {
                                            if _serde::__private::Option::is_some(&__field1) {
                                                return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("value")) ;
                                            }
                                            __field1 = _serde::__private::Some(
                                                match _serde::de::MapAccess::next_value::<V>(
                                                    &mut __map,
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                },
                                            );
                                        }
                                        _ => {
                                            let _ = match _serde::de::MapAccess::next_value::<
                                                _serde::de::IgnoredAny,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            };
                                        }
                                    }
                                }
                                let __field0 = match __field0 {
                                    _serde::__private::Some(__field0) => __field0,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("key") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                let __field1 = match __field1 {
                                    _serde::__private::Some(__field1) => __field1,
                                    _serde::__private::None => {
                                        match _serde::__private::de::missing_field("value") {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    }
                                };
                                _serde::__private::Ok(MappedValue {
                                    key: __field0,
                                    value: __field1,
                                })
                            }
                        }
                        const FIELDS: &'static [&'static str] = &["key", "value"];
                        _serde::Deserializer::deserialize_struct(
                            __deserializer,
                            "MappedValue",
                            FIELDS,
                            __Visitor {
                                marker: _serde::__private::PhantomData::<MappedValue<K, V>>,
                                lifetime: _serde::__private::PhantomData,
                            },
                        )
                    }
                }
            };
            /// A trait that enables a type to convert itself to a big-endian/network byte order.
            pub trait Key: Clone + Send + Sync {
                /// Convert `self` into a `Cow<[u8]>` containing bytes ordered in big-endian/network byte order.
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>>;
                /// Convert a slice of bytes into `Self` by interpretting `bytes` in big-endian/network byte order.
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self>;
            }
            impl<'k> Key for Cow<'k, [u8]> {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'k, [u8]>> {
                    Ok(self.clone())
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(Cow::Owned(bytes.to_vec()))
                }
            }
            impl Key for Vec<u8> {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::Borrowed(self))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(bytes.to_vec())
                }
            }
            impl Key for String {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::Borrowed(self.as_bytes()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(Self::from_utf8(bytes.to_vec())?)
                }
            }
            impl Key for () {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::default())
                }
                fn from_big_endian_bytes(_: &[u8]) -> anyhow::Result<Self> {
                    Ok(())
                }
            }
            #[cfg(feature = "uuid")]
            impl<'k> Key for uuid::Uuid {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::Borrowed(self.as_bytes()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(Self::from_bytes(bytes.try_into()?))
                }
            }
            impl<T> Key for Option<T>
            where
                T: Key,
            {
                /// # Panics
                ///
                /// Panics if `T::into_big_endian_bytes` returns an empty `IVec`.
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    if let Some(contents) = self {
                        let contents = contents.as_big_endian_bytes()?;
                        if !!contents.is_empty() {
                            ::core::panicking::panic("assertion failed: !contents.is_empty()")
                        };
                        Ok(contents)
                    } else {
                        Ok(Cow::default())
                    }
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    if bytes.is_empty() {
                        Ok(None)
                    } else {
                        Ok(Some(T::from_big_endian_bytes(bytes)?))
                    }
                }
            }
            /// Adds `Key` support to an enum. Requires implementing
            /// [`ToPrimitive`](num_traits::ToPrimitive) and
            /// [`FromPrimitive`](num_traits::FromPrimitive), or using a crate like
            /// [num-derive](https://crates.io/crates/num-derive) to do it automatically.
            /// Take care when using enums as keys: if the order changes or if the meaning
            /// of existing numerical values changes, make sure to update any related views'
            /// version number to ensure the values are re-evaluated.
            pub trait EnumKey: ToPrimitive + FromPrimitive + Clone + Send + Sync {}
            impl<T> Key for T
            where
                T: EnumKey,
            {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    self.to_u64()
                        .ok_or_else(|| {
                            ::anyhow::private::new_adhoc("Primitive::to_u64() returned None")
                        })?
                        .as_big_endian_bytes()
                        .map(|bytes| Cow::Owned(bytes.to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    let primitive = u64::from_big_endian_bytes(bytes)?;
                    Self::from_u64(primitive).ok_or_else(|| {
                        ::anyhow::private::new_adhoc("Primitive::from_u64() returned None")
                    })
                }
            }
            impl Key for i8 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(i8::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for u8 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(u8::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for i16 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(i16::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for u16 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(u16::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for i32 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(i32::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for u32 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(u32::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for i64 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(i64::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for u64 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(u64::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for i128 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(i128::from_be_bytes(bytes.try_into()?))
                }
            }
            impl Key for u128 {
                fn as_big_endian_bytes(&self) -> anyhow::Result<Cow<'_, [u8]>> {
                    Ok(Cow::from(self.to_be_bytes().to_vec()))
                }
                fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                    Ok(u128::from_be_bytes(bytes.try_into()?))
                }
            }
        }
        use map::{Key, Map, MappedValue};
        /// Errors that arise when interacting with views.
        pub enum Error {
            /// An error occurred while serializing or deserializing.
            #[error("error deserializing document {0}")]
            Serialization(#[from] serde_cbor::Error),
            /// An error occurred while serializing or deserializing keys emitted in a view.
            #[error("error serializing view keys {0}")]
            KeySerialization(anyhow::Error),
            /// Returned when the reduce() function is unimplemented.
            #[error("reduce is unimplemented")]
            ReduceUnimplemented,
        }
        #[allow(unused_qualifications)]
        impl std::error::Error for Error {
            fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
                use thiserror::private::AsDynError;
                #[allow(deprecated)]
                match self {
                    Error::Serialization { 0: source, .. } => {
                        std::option::Option::Some(source.as_dyn_error())
                    }
                    Error::KeySerialization { .. } => std::option::Option::None,
                    Error::ReduceUnimplemented { .. } => std::option::Option::None,
                }
            }
        }
        #[allow(unused_qualifications)]
        impl std::fmt::Display for Error {
            fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                #[allow(unused_imports)]
                use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
                #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
                match self {
                    Error::Serialization(_0) => {
                        __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &["error deserializing document "],
                            &match (&_0.as_display(),) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                    Error::KeySerialization(_0) => {
                        __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &["error serializing view keys "],
                            &match (&_0.as_display(),) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ))
                    }
                    Error::ReduceUnimplemented {} => {
                        __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                            &["reduce is unimplemented"],
                            &match () {
                                () => [],
                            },
                        ))
                    }
                }
            }
        }
        #[allow(unused_qualifications)]
        impl std::convert::From<serde_cbor::Error> for Error {
            #[allow(deprecated)]
            fn from(source: serde_cbor::Error) -> Self {
                Error::Serialization { 0: source }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Error {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match (&*self,) {
                    (&Error::Serialization(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "Serialization");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&Error::KeySerialization(ref __self_0),) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "KeySerialization");
                        let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                    (&Error::ReduceUnimplemented,) => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_tuple(f, "ReduceUnimplemented");
                        ::core::fmt::DebugTuple::finish(debug_trait_builder)
                    }
                }
            }
        }
        /// A type alias for the result of `View::map()`.
        pub type MapResult<K = (), V = ()> = Result<Option<Map<K, V>>, Error>;
        /// A map/reduce powered indexing and aggregation schema.
        ///
        /// Inspired by [`CouchDB`'s view
        /// system](https://docs.couchdb.org/en/stable/ddocs/views/index.html)
        ///
        /// This implementation is under active development, our own docs explaining our
        /// implementation will be written as things are solidified. The guide [has an
        /// overview](https://pliantdb.dev/guide/about/concepts/view.html).
        pub trait View: Send + Sync + Debug + 'static {
            /// The collection this view belongs to
            type Collection: Collection;
            /// The key for this view.
            type Key: Key + 'static;
            /// An associated type that can be stored with each entry in the view.
            type Value: Serialize + for<'de> Deserialize<'de> + Send + Sync;
            /// If true, no two documents may emit the same key. Unique views are
            /// updated when the document is saved, allowing for this check to be done
            /// atomically. When a document is updated, all unique views will be
            /// updated, and if any of them fail, the document will not be allowed to
            /// update and an
            /// [`Error::UniqueKeyViolation`](crate::Error::UniqueKeyViolation) will be
            /// returned.
            fn unique(&self) -> bool {
                false
            }
            /// The version of the view. Changing this value will cause indexes to be rebuilt.
            fn version(&self) -> u64;
            /// The name of the view. Must be unique per collection.
            fn name(&self) -> Result<Name, InvalidNameError>;
            /// The namespaced name of the view.
            fn view_name(&self) -> Result<ViewName, InvalidNameError> {
                Ok(ViewName {
                    collection: Self::Collection::collection_name()?,
                    name: self.name()?,
                })
            }
            /// The map function for this view. This function is responsible for
            /// emitting entries for any documents that should be contained in this
            /// View. If None is returned, the View will not include the document.
            fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value>;
            /// The reduce function for this view. If `Err(Error::ReduceUnimplemented)`
            /// is returned, queries that ask for a reduce operation will return an
            /// error. See [`CouchDB`'s Reduce/Rereduce
            /// documentation](https://docs.couchdb.org/en/stable/ddocs/views/intro.html#reduce-rereduce)
            /// for the design this implementation will be inspired by
            #[allow(unused_variables)]
            fn reduce(
                &self,
                mappings: &[MappedValue<Self::Key, Self::Value>],
                rereduce: bool,
            ) -> Result<Self::Value, Error> {
                Err(Error::ReduceUnimplemented)
            }
        }
        /// Represents either an owned value or a borrowed value. Functionally
        /// equivalent to `std::borrow::Cow` except this type doesn't require the
        /// wrapped type to implement `Clone`.
        pub enum SerializableValue<'a, T: Serialize> {
            /// an owned value
            Owned(T),
            /// a borrowed value
            Borrowed(&'a T),
        }
        impl<'a, T> From<&'a T> for SerializableValue<'a, T>
        where
            T: Serialize,
        {
            fn from(other: &'a T) -> SerializableValue<'a, T> {
                SerializableValue::Borrowed(other)
            }
        }
        impl<'a, T> AsRef<T> for SerializableValue<'a, T>
        where
            T: Serialize,
        {
            fn as_ref(&self) -> &T {
                match self {
                    Self::Owned(value) => value,
                    Self::Borrowed(value) => value,
                }
            }
        }
        /// Wraps a [`View`] with serialization to erase the associated types
        pub trait Serialized: Send + Sync + Debug {
            /// Wraps returing [`<View::Collection as Collection>::collection_name()`](crate::schema::Collection::collection_name)
            fn collection(&self) -> Result<CollectionName, InvalidNameError>;
            /// Wraps [`View::unique`]
            fn unique(&self) -> bool;
            /// Wraps [`View::version`]
            fn version(&self) -> u64;
            /// Wraps [`View::view_name`]
            fn view_name(&self) -> Result<ViewName, InvalidNameError>;
            /// Wraps [`View::map`]
            fn map(&self, document: &Document<'_>) -> Result<Option<map::Serialized>, Error>;
            /// Wraps [`View::reduce`]
            fn reduce(&self, mappings: &[(&[u8], &[u8])], rereduce: bool)
                -> Result<Vec<u8>, Error>;
        }
        #[allow(clippy::use_self)]
        impl<T> Serialized for T
        where
            T: View,
            <T as View>::Key: 'static,
        {
            fn collection(&self) -> Result<CollectionName, InvalidNameError> {
                <<Self as View>::Collection as Collection>::collection_name()
            }
            fn unique(&self) -> bool {
                self.unique()
            }
            fn version(&self) -> u64 {
                self.version()
            }
            fn view_name(&self) -> Result<ViewName, InvalidNameError> {
                self.view_name()
            }
            fn map(&self, document: &Document<'_>) -> Result<Option<map::Serialized>, Error> {
                let map = self.map(document)?;
                map.map(|map| map.serialized()).transpose()
            }
            fn reduce(
                &self,
                mappings: &[(&[u8], &[u8])],
                rereduce: bool,
            ) -> Result<Vec<u8>, Error> {
                let mappings = mappings
                    .iter()
                    .map(
                        |(key, value)| match <T::Key as Key>::from_big_endian_bytes(key) {
                            Ok(key) => match serde_cbor::from_slice::<T::Value>(value) {
                                Ok(value) => Ok(MappedValue { key, value }),
                                Err(err) => Err(Error::from(err)),
                            },
                            Err(err) => Err(Error::KeySerialization(err)),
                        },
                    )
                    .collect::<Result<Vec<_>, Error>>()?;
                let reduced_value = match self.reduce(&mappings, rereduce) {
                    Ok(value) => value,
                    Err(Error::ReduceUnimplemented) => return Ok(Vec::new()),
                    Err(other) => return Err(other),
                };
                serde_cbor::to_vec(&reduced_value).map_err(Error::from)
            }
        }
    }
    use std::fmt::Debug;
    pub use self::{
        collection::Collection,
        names::{Authority, CollectionName, InvalidNameError, Name, SchemaName, ViewName},
        schematic::Schematic,
        view::{
            map::{Key, Map, MappedDocument, MappedValue},
            MapResult, View,
        },
    };
    use crate::Error;
    /// Defines a group of collections that are stored into a single database.
    pub trait Schema: Send + Sync + Debug + 'static {
        /// Returns the unique [`SchemaName`] for this schema.
        fn schema_name() -> Result<SchemaName, InvalidNameError>;
        /// Defines the `Collection`s into `schema`.
        fn define_collections(schema: &mut Schematic) -> Result<(), Error>;
        /// Retrieves the [`Schematic`] for this schema.
        fn schematic() -> Result<Schematic, Error> {
            let mut schematic = Schematic::default();
            Self::define_collections(&mut schematic)?;
            Ok(schematic)
        }
    }
    /// This trait is only useful for tools like `pliantdb local-backup`. There is no
    /// real-world use case of connecting to a Database with no schema.
    impl Schema for () {
        fn schema_name() -> Result<SchemaName, InvalidNameError> {
            SchemaName::new("", "")
        }
        fn define_collections(_schema: &mut Schematic) -> Result<(), Error> {
            Ok(())
        }
    }
    impl<T> Schema for T
    where
        T: Collection + 'static,
    {
        fn schema_name() -> Result<SchemaName, InvalidNameError> {
            let CollectionName { authority, name } = Self::collection_name()?;
            Ok(SchemaName { authority, name })
        }
        fn define_collections(schema: &mut Schematic) -> Result<(), Error> {
            schema.define_collection::<Self>()
        }
    }
}
/// Types for executing transactions.
pub mod transaction {
    use std::borrow::Cow;
    use serde::{Deserialize, Serialize};
    use crate::{document::Header, schema::CollectionName};
    /// A list of operations to execute as a single unit. If any operation fails,
    /// all changes are aborted. Reads that happen while the transaction is in
    /// progress will return old data and not block.
    pub struct Transaction<'a> {
        /// The operations in this transaction.
        pub operations: Vec<Operation<'a>>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Transaction<'a> {
        #[inline]
        fn clone(&self) -> Transaction<'a> {
            match *self {
                Transaction {
                    operations: ref __self_0_0,
                } => Transaction {
                    operations: ::core::clone::Clone::clone(&(*__self_0_0)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Transaction<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Transaction",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "operations",
                    &self.operations,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, 'a> _serde::Deserialize<'de> for Transaction<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "operations" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"operations" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, 'a> {
                    marker: _serde::__private::PhantomData<Transaction<'a>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Transaction<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Transaction")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Operation<'a>>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Transaction with 1 element",
                                ));
                            }
                        };
                        _serde::__private::Ok(Transaction {
                            operations: __field0,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<Operation<'a>>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "operations",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Operation<'a>>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("operations") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Transaction {
                            operations: __field0,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["operations"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Transaction",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Transaction<'a>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::default::Default for Transaction<'a> {
        #[inline]
        fn default() -> Transaction<'a> {
            Transaction {
                operations: ::core::default::Default::default(),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Transaction<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Transaction {
                    operations: ref __self_0_0,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Transaction");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "operations",
                        &&(*__self_0_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl<'a> Transaction<'a> {
        /// Adds an operation to the transaction.
        pub fn push(&mut self, operation: Operation<'a>) {
            self.operations.push(operation);
        }
    }
    /// A single operation performed on a `Collection`.
    pub struct Operation<'a> {
        /// The id of the `Collection`.
        pub collection: CollectionName,
        /// The command being performed.
        pub command: Command<'a>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Operation<'a> {
        #[inline]
        fn clone(&self) -> Operation<'a> {
            match *self {
                Operation {
                    collection: ref __self_0_0,
                    command: ref __self_0_1,
                } => Operation {
                    collection: ::core::clone::Clone::clone(&(*__self_0_0)),
                    command: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Operation<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Operation",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collection",
                    &self.collection,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "command",
                    &self.command,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, 'a> _serde::Deserialize<'de> for Operation<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "collection" => _serde::__private::Ok(__Field::__field0),
                            "command" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"collection" => _serde::__private::Ok(__Field::__field0),
                            b"command" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, 'a> {
                    marker: _serde::__private::PhantomData<Operation<'a>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Operation<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Operation")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            CollectionName,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Operation with 2 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Command<'a>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Operation with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Operation {
                            collection: __field0,
                            command: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<CollectionName> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Command<'a>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collection",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<CollectionName>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "command",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Command<'a>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("collection") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("command") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Operation {
                            collection: __field0,
                            command: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["collection", "command"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Operation",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Operation<'a>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Operation<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Operation {
                    collection: ref __self_0_0,
                    command: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Operation");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "command",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A command to execute within a `Collection`.
    pub enum Command<'a> {
        /// Inserts a new document containing `contents`.
        Insert {
            /// The initial contents of the document.
            contents: Cow<'a, [u8]>,
        },
        /// Update an existing `Document` identified by `id`. `revision` must match
        /// the currently stored revision on the `Document`. If it does not, the
        /// command fill fail with a `DocumentConflict` error.
        Update {
            /// The current header of the `Document`.
            header: Cow<'a, Header>,
            /// The new contents to store within the `Document`.
            contents: Cow<'a, [u8]>,
        },
        /// Delete an existing `Document` identified by `id`. `revision` must match
        /// the currently stored revision on the `Document`. If it does not, the
        /// command fill fail with a `DocumentConflict` error.
        Delete {
            /// The current header of the `Document`.
            header: Cow<'a, Header>,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Command<'a> {
        #[inline]
        fn clone(&self) -> Command<'a> {
            match (&*self,) {
                (&Command::Insert {
                    contents: ref __self_0,
                },) => Command::Insert {
                    contents: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&Command::Update {
                    header: ref __self_0,
                    contents: ref __self_1,
                },) => Command::Update {
                    header: ::core::clone::Clone::clone(&(*__self_0)),
                    contents: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Command::Delete {
                    header: ref __self_0,
                },) => Command::Delete {
                    header: ::core::clone::Clone::clone(&(*__self_0)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Command<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Command::Insert { ref contents } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Command",
                            0u32,
                            "Insert",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "contents",
                            contents,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Command::Update {
                        ref header,
                        ref contents,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Command",
                            1u32,
                            "Update",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "header",
                            header,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "contents",
                            contents,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Command::Delete { ref header } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Command",
                            2u32,
                            "Delete",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "header",
                            header,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, 'a> _serde::Deserialize<'de> for Command<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Insert" => _serde::__private::Ok(__Field::__field0),
                            "Update" => _serde::__private::Ok(__Field::__field1),
                            "Delete" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Insert" => _serde::__private::Ok(__Field::__field0),
                            b"Update" => _serde::__private::Ok(__Field::__field1),
                            b"Delete" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, 'a> {
                    marker: _serde::__private::PhantomData<Command<'a>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Command<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Command")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "contents" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"contents" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, 'a> {
                                    marker: _serde::__private::PhantomData<Command<'a>>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = Command<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Command::Insert",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Cow<'a, [u8]>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Command::Insert with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Command::Insert {
                                            contents: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<Cow<'a, [u8]>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("contents")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Cow<'a, [u8]>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "contents",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Command::Insert {
                                            contents: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["contents"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Command<'a>>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "header" => _serde::__private::Ok(__Field::__field0),
                                            "contents" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"header" => _serde::__private::Ok(__Field::__field0),
                                            b"contents" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, 'a> {
                                    marker: _serde::__private::PhantomData<Command<'a>>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = Command<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Command::Update",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Cow<'a, Header>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Command::Update with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Cow<'a, [u8]>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Command::Update with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Command::Update {
                                            header: __field0,
                                            contents: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Cow<'a, Header>,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Cow<'a, [u8]>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("header")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Cow<'a, Header>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("contents")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Cow<'a, [u8]>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("header")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "contents",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Command::Update {
                                            header: __field0,
                                            contents: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["header", "contents"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Command<'a>>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "header" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"header" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, 'a> {
                                    marker: _serde::__private::PhantomData<Command<'a>>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                                    type Value = Command<'a>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Command::Delete",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Cow<'a, Header>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Command::Delete with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Command::Delete { header: __field0 })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Cow<'a, Header>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("header")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Cow<'a, Header>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("header")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Command::Delete { header: __field0 })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["header"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Command<'a>>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Insert", "Update", "Delete"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Command",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Command<'a>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Command<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Command::Insert {
                    contents: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Insert");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "contents",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Command::Update {
                    header: ref __self_0,
                    contents: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Update");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "header",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "contents",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Command::Delete {
                    header: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Delete");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "header",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    /// Information about the result of each `Operation` in a transaction.
    pub enum OperationResult {
        /// An operation succeeded but had no information to output.
        Success,
        /// A `Document` was updated.
        DocumentUpdated {
            /// The id of the `Collection` of the updated `Document`.
            collection: CollectionName,
            /// The header of the updated `Document`.
            header: Header,
        },
        /// A `Document` was deleted.
        DocumentDeleted {
            /// The id of the `Collection` of the deleted `Document`.
            collection: CollectionName,
            /// The id of the deleted `Document`.
            id: u64,
        },
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for OperationResult {
        #[inline]
        fn clone(&self) -> OperationResult {
            match (&*self,) {
                (&OperationResult::Success,) => OperationResult::Success,
                (&OperationResult::DocumentUpdated {
                    collection: ref __self_0,
                    header: ref __self_1,
                },) => OperationResult::DocumentUpdated {
                    collection: ::core::clone::Clone::clone(&(*__self_0)),
                    header: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&OperationResult::DocumentDeleted {
                    collection: ref __self_0,
                    id: ref __self_1,
                },) => OperationResult::DocumentDeleted {
                    collection: ::core::clone::Clone::clone(&(*__self_0)),
                    id: ::core::clone::Clone::clone(&(*__self_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for OperationResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&OperationResult::Success,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Success");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&OperationResult::DocumentUpdated {
                    collection: ref __self_0,
                    header: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DocumentUpdated");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "header",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&OperationResult::DocumentDeleted {
                    collection: ref __self_0,
                    id: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DocumentDeleted");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_1));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for OperationResult {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    OperationResult::Success => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "OperationResult",
                        0u32,
                        "Success",
                    ),
                    OperationResult::DocumentUpdated {
                        ref collection,
                        ref header,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "OperationResult",
                            1u32,
                            "DocumentUpdated",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "collection",
                            collection,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "header",
                            header,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    OperationResult::DocumentDeleted {
                        ref collection,
                        ref id,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "OperationResult",
                            2u32,
                            "DocumentDeleted",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "collection",
                            collection,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "id",
                            id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for OperationResult {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Success" => _serde::__private::Ok(__Field::__field0),
                            "DocumentUpdated" => _serde::__private::Ok(__Field::__field1),
                            "DocumentDeleted" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Success" => _serde::__private::Ok(__Field::__field0),
                            b"DocumentUpdated" => _serde::__private::Ok(__Field::__field1),
                            b"DocumentDeleted" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<OperationResult>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = OperationResult;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum OperationResult")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(OperationResult::Success)
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "header" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"header" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<OperationResult>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = OperationResult;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant OperationResult::DocumentUpdated",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                CollectionName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant OperationResult::DocumentUpdated with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Header>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant OperationResult::DocumentUpdated with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(OperationResult::DocumentUpdated {
                                            collection: __field0,
                                            header: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            CollectionName,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Header> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("collection")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            CollectionName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("header")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Header,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "collection",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("header")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(OperationResult::DocumentUpdated {
                                            collection: __field0,
                                            header: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["collection", "header"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<OperationResult>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "id" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"id" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<OperationResult>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = OperationResult;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant OperationResult::DocumentDeleted",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                CollectionName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant OperationResult::DocumentDeleted with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant OperationResult::DocumentDeleted with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(OperationResult::DocumentDeleted {
                                            collection: __field0,
                                            id: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            CollectionName,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("collection")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            CollectionName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("id")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "collection",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(OperationResult::DocumentDeleted {
                                            collection: __field0,
                                            id: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["collection", "id"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<OperationResult>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["Success", "DocumentUpdated", "DocumentDeleted"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "OperationResult",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<OperationResult>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    /// Details about an executed transaction.
    pub struct Executed<'a> {
        /// The id of the transaction.
        pub id: u64,
        /// A list of containing ids of `Documents` changed.
        pub changed_documents: Cow<'a, [ChangedDocument]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::clone::Clone for Executed<'a> {
        #[inline]
        fn clone(&self) -> Executed<'a> {
            match *self {
                Executed {
                    id: ref __self_0_0,
                    changed_documents: ref __self_0_1,
                } => Executed {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    changed_documents: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<'a> ::core::fmt::Debug for Executed<'a> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Executed {
                    id: ref __self_0_0,
                    changed_documents: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Executed");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "changed_documents",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'a> _serde::Serialize for Executed<'a> {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Executed",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "changed_documents",
                    &self.changed_documents,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, 'a> _serde::Deserialize<'de> for Executed<'a> {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "changed_documents" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"changed_documents" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, 'a> {
                    marker: _serde::__private::PhantomData<Executed<'a>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, 'a> _serde::de::Visitor<'de> for __Visitor<'de, 'a> {
                    type Value = Executed<'a>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Executed")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Executed with 2 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Cow<'a, [ChangedDocument]>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Executed with 2 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Executed {
                            id: __field0,
                            changed_documents: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Cow<'a, [ChangedDocument]>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "changed_documents",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Cow<'a, [ChangedDocument]>,
                                        >(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("changed_documents") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Executed {
                            id: __field0,
                            changed_documents: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["id", "changed_documents"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Executed",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Executed<'a>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    impl<'a> Executed<'a> {
        /// Convert this structure to be free of borrows.
        #[must_use]
        pub fn to_owned(&self) -> Executed<'static> {
            Executed {
                id: self.id,
                changed_documents: self.changed_documents.iter().cloned().collect(),
            }
        }
    }
    /// A record of a changed.
    pub struct ChangedDocument {
        /// The id of the `Collection` of the changed `Document`.
        pub collection: CollectionName,
        /// The id of the changed `Document`.
        pub id: u64,
        /// If the `Document` has been deleted, this will be `true`.
        pub deleted: bool,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ChangedDocument {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ChangedDocument {
                    collection: ref __self_0_0,
                    id: ref __self_0_1,
                    deleted: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "ChangedDocument");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0_0),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_1));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "deleted",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ChangedDocument {
        #[inline]
        fn clone(&self) -> ChangedDocument {
            match *self {
                ChangedDocument {
                    collection: ref __self_0_0,
                    id: ref __self_0_1,
                    deleted: ref __self_0_2,
                } => ChangedDocument {
                    collection: ::core::clone::Clone::clone(&(*__self_0_0)),
                    id: ::core::clone::Clone::clone(&(*__self_0_1)),
                    deleted: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ChangedDocument {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "ChangedDocument",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "collection",
                    &self.collection,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "deleted",
                    &self.deleted,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ChangedDocument {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "collection" => _serde::__private::Ok(__Field::__field0),
                            "id" => _serde::__private::Ok(__Field::__field1),
                            "deleted" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"collection" => _serde::__private::Ok(__Field::__field0),
                            b"id" => _serde::__private::Ok(__Field::__field1),
                            b"deleted" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ChangedDocument>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ChangedDocument;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct ChangedDocument",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            CollectionName,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct ChangedDocument with 3 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct ChangedDocument with 3 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            2usize,
                                            &"struct ChangedDocument with 3 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(ChangedDocument {
                            collection: __field0,
                            id: __field1,
                            deleted: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<CollectionName> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<u64> = _serde::__private::None;
                        let mut __field2: _serde::__private::Option<bool> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "collection",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<CollectionName>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "deleted",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<bool>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("collection") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("deleted") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(ChangedDocument {
                            collection: __field0,
                            id: __field1,
                            deleted: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["collection", "id", "deleted"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ChangedDocument",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ChangedDocument>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
/// Types for utilizing a lightweight atomic Key-Value store.
pub mod kv {
    use serde::{Deserialize, Serialize};
    mod timestamp {
        use std::{
            borrow::Cow,
            time::{Duration, SystemTime, UNIX_EPOCH},
        };
        use serde::{Deserialize, Serialize};
        use crate::schema::Key;
        /// A timestamp relative to [`UNIX_EPOCH`].
        pub struct Timestamp {
            /// The number of whole seconds since [`UNIX_EPOCH`].
            pub seconds: u64,
            /// The number of nanoseconds in the timestamp.
            pub nanos: u32,
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Timestamp {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::__private::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Timestamp",
                        false as usize + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "seconds",
                        &self.seconds,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "nanos",
                        &self.nanos,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Timestamp {
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::__private::Ok(__Field::__field0),
                                1u64 => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "seconds" => _serde::__private::Ok(__Field::__field0),
                                "nanos" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::__private::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"seconds" => _serde::__private::Ok(__Field::__field0),
                                b"nanos" => _serde::__private::Ok(__Field::__field1),
                                _ => _serde::__private::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::__private::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::__private::PhantomData<Timestamp>,
                        lifetime: _serde::__private::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Timestamp;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::__private::Formatter,
                        ) -> _serde::__private::fmt::Result {
                            _serde::__private::Formatter::write_str(__formatter, "struct Timestamp")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<u64>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Timestamp with 2 elements",
                                        ),
                                    );
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Timestamp with 2 elements",
                                        ),
                                    );
                                }
                            };
                            _serde::__private::Ok(Timestamp {
                                seconds: __field0,
                                nanos: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::__private::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::__private::Option<u64> =
                                _serde::__private::None;
                            let mut __field1: _serde::__private::Option<u32> =
                                _serde::__private::None;
                            while let _serde::__private::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::__private::Option::is_some(&__field0) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "seconds",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u64>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::__private::Option::is_some(&__field1) {
                                            return _serde::__private::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "nanos",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::__private::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::__private::Some(__field0) => __field0,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("seconds") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::__private::Some(__field1) => __field1,
                                _serde::__private::None => {
                                    match _serde::__private::de::missing_field("nanos") {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::__private::Ok(Timestamp {
                                seconds: __field0,
                                nanos: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["seconds", "nanos"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Timestamp",
                        FIELDS,
                        __Visitor {
                            marker: _serde::__private::PhantomData::<Timestamp>,
                            lifetime: _serde::__private::PhantomData,
                        },
                    )
                }
            }
        };
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Timestamp {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Timestamp {
                        seconds: ref __self_0_0,
                        nanos: ref __self_0_1,
                    } => {
                        let debug_trait_builder =
                            &mut ::core::fmt::Formatter::debug_struct(f, "Timestamp");
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "seconds",
                            &&(*__self_0_0),
                        );
                        let _ = ::core::fmt::DebugStruct::field(
                            debug_trait_builder,
                            "nanos",
                            &&(*__self_0_1),
                        );
                        ::core::fmt::DebugStruct::finish(debug_trait_builder)
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Timestamp {
            #[inline]
            fn clone(&self) -> Timestamp {
                {
                    let _: ::core::clone::AssertParamIsClone<u64>;
                    let _: ::core::clone::AssertParamIsClone<u32>;
                    *self
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::marker::Copy for Timestamp {}
        impl ::core::marker::StructuralEq for Timestamp {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Timestamp {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<u64>;
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                }
            }
        }
        impl ::core::marker::StructuralPartialEq for Timestamp {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Timestamp {
            #[inline]
            fn eq(&self, other: &Timestamp) -> bool {
                match *other {
                    Timestamp {
                        seconds: ref __self_1_0,
                        nanos: ref __self_1_1,
                    } => match *self {
                        Timestamp {
                            seconds: ref __self_0_0,
                            nanos: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Timestamp) -> bool {
                match *other {
                    Timestamp {
                        seconds: ref __self_1_0,
                        nanos: ref __self_1_1,
                    } => match *self {
                        Timestamp {
                            seconds: ref __self_0_0,
                            nanos: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialOrd for Timestamp {
            #[inline]
            fn partial_cmp(
                &self,
                other: &Timestamp,
            ) -> ::core::option::Option<::core::cmp::Ordering> {
                match *other {
                    Timestamp {
                        seconds: ref __self_1_0,
                        nanos: ref __self_1_1,
                    } => match *self {
                        Timestamp {
                            seconds: ref __self_0_0,
                            nanos: ref __self_0_1,
                        } => match ::core::cmp::PartialOrd::partial_cmp(
                            &(*__self_0_0),
                            &(*__self_1_0),
                        ) {
                            ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                match ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_1),
                                    &(*__self_1_1),
                                ) {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                    }
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Ord for Timestamp {
            #[inline]
            fn cmp(&self, other: &Timestamp) -> ::core::cmp::Ordering {
                match *other {
                    Timestamp {
                        seconds: ref __self_1_0,
                        nanos: ref __self_1_1,
                    } => match *self {
                        Timestamp {
                            seconds: ref __self_0_0,
                            nanos: ref __self_0_1,
                        } => match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                            ::core::cmp::Ordering::Equal => {
                                match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                    ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                    cmp => cmp,
                                }
                            }
                            cmp => cmp,
                        },
                    },
                }
            }
        }
        impl Timestamp {
            /// Returns the current timestamp according to the OS. Uses [`SystemTime::now()`].
            #[must_use]
            pub fn now() -> Self {
                Self::from(SystemTime::now())
            }
        }
        impl From<SystemTime> for Timestamp {
            fn from(time: SystemTime) -> Self {
                let duration_since_epoch = time
                    .duration_since(UNIX_EPOCH)
                    .expect("unrealistic system time");
                Self {
                    seconds: duration_since_epoch.as_secs(),
                    nanos: duration_since_epoch.subsec_nanos(),
                }
            }
        }
        impl From<Timestamp> for Duration {
            fn from(t: Timestamp) -> Self {
                Self::new(t.seconds, t.nanos)
            }
        }
        impl std::ops::Sub for Timestamp {
            type Output = Option<Duration>;
            fn sub(self, rhs: Self) -> Self::Output {
                Duration::from(self).checked_sub(Duration::from(rhs))
            }
        }
        impl std::ops::Add<Duration> for Timestamp {
            type Output = Self;
            fn add(self, rhs: Duration) -> Self::Output {
                let mut nanos = self.nanos + rhs.subsec_nanos();
                let mut seconds = self.seconds + rhs.as_secs();
                while nanos > 1_000_000_000 {
                    nanos -= 1_000_000_000;
                    seconds += 1;
                }
                Self { seconds, nanos }
            }
        }
        impl Key for Timestamp {
            fn as_big_endian_bytes(&self) -> anyhow::Result<std::borrow::Cow<'_, [u8]>> {
                let seconds_bytes: &[u8] = &self.seconds.to_be_bytes();
                let nanos_bytes = &self.nanos.to_be_bytes();
                Ok(Cow::Owned([seconds_bytes, nanos_bytes].concat()))
            }
            fn from_big_endian_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
                if bytes.len() != 12 {
                    return ::anyhow::private::Err(::anyhow::private::new_adhoc(
                        "invalid length of stored bytes for Timestamp",
                    ));
                }
                Ok(Self {
                    seconds: u64::from_big_endian_bytes(&bytes[0..8])?,
                    nanos: u32::from_big_endian_bytes(&bytes[8..12])?,
                })
            }
        }
    }
    pub use self::timestamp::Timestamp;
    #[cfg(feature = "keyvalue")]
    mod implementation {
        use async_trait::async_trait;
        use futures::future::BoxFuture;
        use serde::{Deserialize, Serialize};
        use crate::{
            kv::{Command, KeyCheck, KeyOperation, KeyStatus, Output, Timestamp},
            Error,
        };
        /// Types for executing get operations.
        pub mod get {
            use futures::{Future, FutureExt};
            use serde::Deserialize;
            use super::{BuilderState, Command, KeyOperation, Kv, Output};
            use crate::Error;
            /// Executes [`Command::Get`] when awaited. Also offers methods to customize the
            /// options for the operation.
            #[must_use = "futures do nothing unless you `.await` or poll them"]
            pub struct Builder<'a, Kv, V> {
                state: BuilderState<'a, Options<'a, Kv>, Result<Option<V>, Error>>,
            }
            struct Options<'a, Kv> {
                kv: &'a Kv,
                namespace: Option<String>,
                key: String,
                delete: bool,
            }
            impl<'a, K, V> Builder<'a, K, V>
            where
                K: Kv,
            {
                pub(crate) fn new(kv: &'a K, namespace: Option<String>, key: String) -> Self {
                    Self {
                        state: BuilderState::Pending(Some(Options {
                            key,
                            kv,
                            namespace,
                            delete: false,
                        })),
                    }
                }
                fn options(&mut self) -> &mut Options<'a, K> {
                    if let BuilderState::Pending(Some(options)) = &mut self.state {
                        options
                    } else {
                        {
                            ::std::rt::begin_panic("Attempted to use after retrieving the result")
                        }
                    }
                }
                /// Delete the key after retrieving the value.
                pub fn and_delete(mut self) -> Self {
                    self.options().delete = true;
                    self
                }
            }
            impl<'a, K, V> Future for Builder<'a, K, V>
            where
                K: Kv,
                V: for<'de> Deserialize<'de>,
            {
                type Output = Result<Option<V>, Error>;
                fn poll(
                    mut self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Self::Output> {
                    match &mut self.state {
                        BuilderState::Executing(future) => future.as_mut().poll(cx),
                        BuilderState::Pending(builder) => {
                            let Options {
                                kv,
                                namespace,
                                key,
                                delete,
                            } = builder.take().expect("expected builder to have options");
                            let future = async move {
                                let result = kv
                                    .execute_key_operation(KeyOperation {
                                        namespace,
                                        key,
                                        command: Command::Get { delete },
                                    })
                                    .await?;
                                if let Output::Value(value) = result {
                                    Ok(value
                                        .map(|v| serde_cbor::from_slice(&v))
                                        .transpose()
                                        .unwrap())
                                } else {
                                    {
                                        {
                                            ::core::panicking::panic_fmt(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["internal error: entered unreachable code: "],
                                                    &match (&"Unexpected result from get",) {
                                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        )],
                                                    },
                                                ),
                                            )
                                        }
                                    }
                                }
                            }
                            .boxed();
                            self.state = BuilderState::Executing(future);
                            self.poll(cx)
                        }
                    }
                }
            }
        }
        /// Types for handling key namespaces.
        pub mod namespaced {
            use async_trait::async_trait;
            use super::{KeyOperation, Kv, Output};
            use crate::Error;
            /// A namespaced key-value store. All operations performed with this will be
            /// separate from other namespaces.
            pub struct Namespaced<'a, K> {
                namespace: String,
                kv: &'a K,
            }
            impl<'a, K> Namespaced<'a, K> {
                pub(crate) const fn new(namespace: String, kv: &'a K) -> Self {
                    Self { namespace, kv }
                }
            }
            impl<'a, K> Kv for Namespaced<'a, K>
            where
                K: Kv,
            {
                #[allow(
                    clippy::let_unit_value,
                    clippy::type_complexity,
                    clippy::type_repetition_in_bounds,
                    clippy::used_underscore_binding
                )]
                fn execute_key_operation<'life0, 'async_trait>(
                    &'life0 self,
                    op: KeyOperation,
                ) -> ::core::pin::Pin<
                    Box<
                        dyn ::core::future::Future<Output = Result<Output, Error>>
                            + ::core::marker::Send
                            + 'async_trait,
                    >,
                >
                where
                    'life0: 'async_trait,
                    Self: 'async_trait,
                {
                    Box::pin(async move {
                        if let ::core::option::Option::Some(__ret) =
                            ::core::option::Option::None::<Result<Output, Error>>
                        {
                            return __ret;
                        }
                        let __self = self;
                        let op = op;
                        let __ret: Result<Output, Error> =
                            { __self.kv.execute_key_operation(op).await };
                        #[allow(unreachable_code)]
                        __ret
                    })
                }
                fn key_namespace(&self) -> Option<&'_ str> {
                    Some(&self.namespace)
                }
                fn with_key_namespace(&'_ self, namespace: &str) -> Namespaced<'_, Self>
                where
                    Self: Sized,
                {
                    Namespaced {
                        namespace: {
                            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                                &["", "\u{0}"],
                                &match (&self.namespace, &namespace) {
                                    (arg0, arg1) => [
                                        ::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        ),
                                        ::core::fmt::ArgumentV1::new(
                                            arg1,
                                            ::core::fmt::Display::fmt,
                                        ),
                                    ],
                                },
                            ));
                            res
                        },
                        kv: self,
                    }
                }
            }
        }
        /// Types for executing set operations.
        pub mod set {
            use std::{
                ops::Add,
                time::{Duration, SystemTime},
            };
            use futures::{Future, FutureExt};
            use serde::{Deserialize, Serialize};
            use super::{
                BuilderState, Command, KeyCheck, KeyOperation, KeyStatus, Kv, Output, Timestamp,
            };
            use crate::Error;
            /// Executes [`Command::Set`] when awaited. Also offers methods to customize the
            /// options for the operation.
            #[must_use = "futures do nothing unless you `.await` or poll them"]
            pub struct Builder<'a, Kv, V> {
                state: BuilderState<'a, Options<'a, Kv, V>, Result<KeyStatus, Error>>,
            }
            struct Options<'a, Kv, V> {
                kv: &'a Kv,
                namespace: Option<String>,
                key: String,
                value: &'a V,
                expiration: Option<Timestamp>,
                keep_existing_expiration: bool,
                check: Option<KeyCheck>,
            }
            impl<'a, K, V> Builder<'a, K, V>
            where
                K: Kv,
            {
                pub(crate) fn new(
                    kv: &'a K,
                    namespace: Option<String>,
                    key: String,
                    value: &'a V,
                ) -> Self {
                    Self {
                        state: BuilderState::Pending(Some(Options {
                            key,
                            value,
                            kv,
                            namespace,
                            expiration: None,
                            keep_existing_expiration: false,
                            check: None,
                        })),
                    }
                }
                fn options(&mut self) -> &mut Options<'a, K, V> {
                    if let BuilderState::Pending(Some(options)) = &mut self.state {
                        options
                    } else {
                        {
                            ::std::rt::begin_panic("Attempted to use after retrieving the result")
                        }
                    }
                }
                /// Set this key to expire after `duration` from now.
                pub fn expire_in(mut self, duration: Duration) -> Self {
                    self.options().expiration =
                        Some(Timestamp::from(SystemTime::now().add(duration)));
                    self
                }
                /// Set this key to expire at the provided `time`.
                pub fn expire_at(mut self, time: SystemTime) -> Self {
                    self.options().expiration = Some(Timestamp::from(time));
                    self
                }
                /// If the key already exists, do not update the currently set expiration.
                pub fn keep_existing_expiration(mut self) -> Self {
                    self.options().keep_existing_expiration = true;
                    self
                }
                /// Only set the value if this key already exists.
                pub fn only_if_exists(mut self) -> Self {
                    self.options().check = Some(KeyCheck::OnlyIfPresent);
                    self
                }
                /// Only set the value if this key isn't present.
                pub fn only_if_vacant(mut self) -> Self {
                    self.options().check = Some(KeyCheck::OnlyIfVacant);
                    self
                }
                /// Executes the Set operation, requesting the previous value be returned.
                /// If no change is made, None will be returned.
                #[allow(clippy::missing_panics_doc)]
                pub async fn returning_previous(self) -> Result<Option<V>, Error>
                where
                    V: Serialize + for<'de> Deserialize<'de> + Send + Sync,
                {
                    if let BuilderState::Pending(Some(builder)) = self.state {
                        let Options {
                            kv,
                            namespace,
                            key,
                            value,
                            expiration,
                            keep_existing_expiration,
                            check,
                        } = builder;
                        let value = serde_cbor::to_vec(value)?;
                        let result = kv
                            .execute_key_operation(KeyOperation {
                                namespace,
                                key,
                                command: Command::Set {
                                    value,
                                    expiration,
                                    keep_existing_expiration,
                                    check,
                                    return_previous_value: true,
                                },
                            })
                            .await?;
                        match result {
                            Output::Value(value) => Ok(value
                                .map(|v| serde_cbor::from_slice(&v))
                                .transpose()
                                .unwrap()),
                            Output::Status(KeyStatus::NotChanged) => Ok(None),
                            Output::Status(_) => {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                    &["internal error: entered unreachable code: "],
                                    &match (&"Unexpected output from Set",) {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        )],
                                    },
                                ))
                            }
                        }
                    } else {
                        {
                            ::std::rt::begin_panic("Using future after it's been executed")
                        }
                    }
                }
            }
            impl<'a, K, V> Future for Builder<'a, K, V>
            where
                K: Kv,
                V: Serialize,
            {
                type Output = Result<KeyStatus, Error>;
                fn poll(
                    mut self: std::pin::Pin<&mut Self>,
                    cx: &mut std::task::Context<'_>,
                ) -> std::task::Poll<Self::Output> {
                    match &mut self.state {
                        BuilderState::Executing(future) => future.as_mut().poll(cx),
                        BuilderState::Pending(builder) => {
                            let Options {
                                kv,
                                namespace,
                                key,
                                value,
                                expiration,
                                keep_existing_expiration,
                                check,
                            } = builder.take().expect("expected builder to have options");
                            let value = serde_cbor::to_vec(value)?;
                            let future = async move {
                                let result = kv
                                    .execute_key_operation(KeyOperation {
                                        namespace,
                                        key,
                                        command: Command::Set {
                                            value,
                                            expiration,
                                            keep_existing_expiration,
                                            check,
                                            return_previous_value: false,
                                        },
                                    })
                                    .await?;
                                if let Output::Status(status) = result {
                                    Ok(status)
                                } else {
                                    {
                                        {
                                            ::core::panicking::panic_fmt(
                                                ::core::fmt::Arguments::new_v1(
                                                    &["internal error: entered unreachable code: "],
                                                    &match (&"Unexpected output from Set",) {
                                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                                            arg0,
                                                            ::core::fmt::Display::fmt,
                                                        )],
                                                    },
                                                ),
                                            )
                                        }
                                    }
                                }
                            }
                            .boxed();
                            self.state = BuilderState::Executing(future);
                            self.poll(cx)
                        }
                    }
                }
            }
        }
        use namespaced::Namespaced;
        /// Key-Value store methods. The Key-Value store is designed to be a
        /// high-performance, lightweight storage mechanism.
        ///
        /// When compared to Collections, the Key-Value store does not offer
        /// ACID-compliant transactions. Instead, the Key-Value store is made more
        /// efficient by periodically flushing the store to disk rather than during each
        /// operation. As such, the Key-Value store is intended to be used as a
        /// lightweight caching layer. However, because each of the operations it
        /// supports are executed atomically, the Key-Value store can also be utilized
        /// for synchronized locking.
        pub trait Kv: Send + Sync {
            /// Executes a single [`KeyOperation`].
            #[must_use]
            #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
            fn execute_key_operation<'life0, 'async_trait>(
                &'life0 self,
                op: KeyOperation,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<Output = Result<Output, Error>>
                        + ::core::marker::Send
                        + 'async_trait,
                >,
            >
            where
                'life0: 'async_trait,
                Self: 'async_trait;
            /// Sets `key` to `value`. This function returns a builder that is also a
            /// Future. Awaiting the builder will execute [`Command::Set`] with the options
            /// given.
            fn set_key<'a, S: Into<String>, V: Serialize>(
                &'a self,
                key: S,
                value: &'a V,
            ) -> set::Builder<'a, Self, V>
            where
                Self: Sized,
            {
                set::Builder::new(
                    self,
                    self.key_namespace().map(Into::into),
                    key.into(),
                    value,
                )
            }
            /// Gets the value stored at `key`. This function returns a builder that is also a
            /// Future. Awaiting the builder will execute [`Command::Get`] with the options
            /// given.
            fn get_key<'de, V: Deserialize<'de>, S: Into<String>>(
                &'_ self,
                key: S,
            ) -> get::Builder<'_, Self, V>
            where
                Self: Sized,
            {
                get::Builder::new(self, self.key_namespace().map(Into::into), key.into())
            }
            /// Deletes the value stored at `key`.
            #[must_use]
            #[allow(
                clippy::let_unit_value,
                clippy::type_complexity,
                clippy::type_repetition_in_bounds,
                clippy::used_underscore_binding
            )]
            fn delete_key<'life0, 'async_trait, S: Into<String> + Send>(
                &'life0 self,
                key: S,
            ) -> ::core::pin::Pin<
                Box<
                    dyn ::core::future::Future<Output = Result<KeyStatus, Error>>
                        + ::core::marker::Send
                        + 'async_trait,
                >,
            >
            where
                Self: Sized,
                S: 'async_trait,
                'life0: 'async_trait,
                Self: 'async_trait,
            {
                Box::pin(async move {
                    if let ::core::option::Option::Some(__ret) =
                        ::core::option::Option::None::<Result<KeyStatus, Error>>
                    {
                        return __ret;
                    }
                    let __self = self;
                    let key = key;
                    let __ret: Result<KeyStatus, Error> = {
                        match __self
                            .execute_key_operation(KeyOperation {
                                namespace: __self.key_namespace().map(ToOwned::to_owned),
                                key: key.into(),
                                command: Command::Delete,
                            })
                            .await?
                        {
                            Output::Status(status) => Ok(status),
                            Output::Value(_) => {
                                ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                                    &["internal error: entered unreachable code: "],
                                    &match (&"invalid output from delete operation",) {
                                        (arg0,) => [::core::fmt::ArgumentV1::new(
                                            arg0,
                                            ::core::fmt::Display::fmt,
                                        )],
                                    },
                                ))
                            }
                        }
                    };
                    #[allow(unreachable_code)]
                    __ret
                })
            }
            /// The current namespace.
            fn key_namespace(&self) -> Option<&'_ str> {
                None
            }
            /// Access this Key-Value store within a namespace. When using the returned
            /// [`Namespaced`] instance, all keys specified will be separated into their
            /// own storage designated by `namespace`.
            fn with_key_namespace(&'_ self, namespace: &str) -> Namespaced<'_, Self>
            where
                Self: Sized,
            {
                Namespaced::new(namespace.to_string(), self)
            }
        }
        enum BuilderState<'a, T, R> {
            Pending(Option<T>),
            Executing(BoxFuture<'a, R>),
        }
    }
    #[cfg(feature = "keyvalue")]
    pub use implementation::*;
    /// Checks for existing keys.
    pub enum KeyCheck {
        /// Only allow the operation if an existing key is present.
        OnlyIfPresent,
        /// Only allow the opeartion if the key isn't present.
        OnlyIfVacant,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyCheck {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    KeyCheck::OnlyIfPresent => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyCheck",
                        0u32,
                        "OnlyIfPresent",
                    ),
                    KeyCheck::OnlyIfVacant => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyCheck",
                        1u32,
                        "OnlyIfVacant",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyCheck {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "OnlyIfPresent" => _serde::__private::Ok(__Field::__field0),
                            "OnlyIfVacant" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"OnlyIfPresent" => _serde::__private::Ok(__Field::__field0),
                            b"OnlyIfVacant" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KeyCheck>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KeyCheck;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum KeyCheck")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyCheck::OnlyIfPresent)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyCheck::OnlyIfVacant)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["OnlyIfPresent", "OnlyIfVacant"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "KeyCheck",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyCheck>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for KeyCheck {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyCheck {
        #[inline]
        fn clone(&self) -> KeyCheck {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for KeyCheck {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&KeyCheck::OnlyIfPresent,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "OnlyIfPresent");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&KeyCheck::OnlyIfVacant,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "OnlyIfVacant");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// An operation performed on a key.
    pub struct KeyOperation {
        /// The namespace for the key.
        pub namespace: Option<String>,
        /// The key to operate on.
        pub key: String,
        /// The command to execute.
        pub command: Command,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyOperation {
        #[inline]
        fn clone(&self) -> KeyOperation {
            match *self {
                KeyOperation {
                    namespace: ref __self_0_0,
                    key: ref __self_0_1,
                    command: ref __self_0_2,
                } => KeyOperation {
                    namespace: ::core::clone::Clone::clone(&(*__self_0_0)),
                    key: ::core::clone::Clone::clone(&(*__self_0_1)),
                    command: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyOperation {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "KeyOperation",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "namespace",
                    &self.namespace,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key",
                    &self.key,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "command",
                    &self.command,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyOperation {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "namespace" => _serde::__private::Ok(__Field::__field0),
                            "key" => _serde::__private::Ok(__Field::__field1),
                            "command" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"namespace" => _serde::__private::Ok(__Field::__field0),
                            b"key" => _serde::__private::Ok(__Field::__field1),
                            b"command" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KeyOperation>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KeyOperation;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct KeyOperation")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct KeyOperation with 3 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct KeyOperation with 3 elements",
                                        ),
                                    );
                                }
                            };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Command>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct KeyOperation with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(KeyOperation {
                            namespace: __field0,
                            key: __field1,
                            command: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Command> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "namespace",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "key",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "command",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Command>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("namespace") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("command") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(KeyOperation {
                            namespace: __field0,
                            key: __field1,
                            command: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["namespace", "key", "command"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "KeyOperation",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyOperation>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for KeyOperation {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                KeyOperation {
                    namespace: ref __self_0_0,
                    key: ref __self_0_1,
                    command: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "KeyOperation");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "namespace",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "key",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "command",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    /// Commands for a key-value store.
    pub enum Command {
        /// Set a key/value pair.
        Set {
            /// The value.
            value: Vec<u8>,
            /// If set, the key will be set to expire automatically.
            expiration: Option<Timestamp>,
            /// If true and the key already exists, the expiration will not be
            /// updated. If false and an expiration is provided, the expiration will
            /// be set.
            keep_existing_expiration: bool,
            /// Conditional checks for whether the key is already present or not.
            check: Option<KeyCheck>,
            /// If true and the key already exists, the existing key will be returned if overwritten.
            return_previous_value: bool,
        },
        /// Get the value from a key.
        Get {
            /// Remove the key after retrieving the value.
            delete: bool,
        },
        /// Delete a key.
        Delete,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Command {
        #[inline]
        fn clone(&self) -> Command {
            match (&*self,) {
                (&Command::Set {
                    value: ref __self_0,
                    expiration: ref __self_1,
                    keep_existing_expiration: ref __self_2,
                    check: ref __self_3,
                    return_previous_value: ref __self_4,
                },) => Command::Set {
                    value: ::core::clone::Clone::clone(&(*__self_0)),
                    expiration: ::core::clone::Clone::clone(&(*__self_1)),
                    keep_existing_expiration: ::core::clone::Clone::clone(&(*__self_2)),
                    check: ::core::clone::Clone::clone(&(*__self_3)),
                    return_previous_value: ::core::clone::Clone::clone(&(*__self_4)),
                },
                (&Command::Get {
                    delete: ref __self_0,
                },) => Command::Get {
                    delete: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&Command::Delete,) => Command::Delete,
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Command {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Command::Set {
                        ref value,
                        ref expiration,
                        ref keep_existing_expiration,
                        ref check,
                        ref return_previous_value,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Command",
                            0u32,
                            "Set",
                            0 + 1 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "value",
                            value,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "expiration",
                            expiration,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "keep_existing_expiration",
                            keep_existing_expiration,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "check",
                            check,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "return_previous_value",
                            return_previous_value,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Command::Get { ref delete } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Command",
                            1u32,
                            "Get",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "delete",
                            delete,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Command::Delete => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Command",
                        2u32,
                        "Delete",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Command {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Set" => _serde::__private::Ok(__Field::__field0),
                            "Get" => _serde::__private::Ok(__Field::__field1),
                            "Delete" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Set" => _serde::__private::Ok(__Field::__field0),
                            b"Get" => _serde::__private::Ok(__Field::__field1),
                            b"Delete" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Command>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Command;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Command")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __field4,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            4u64 => _serde::__private::Ok(__Field::__field4),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "value" => _serde::__private::Ok(__Field::__field0),
                                            "expiration" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            "keep_existing_expiration" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            "check" => _serde::__private::Ok(__Field::__field3),
                                            "return_previous_value" => {
                                                _serde::__private::Ok(__Field::__field4)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"value" => _serde::__private::Ok(__Field::__field0),
                                            b"expiration" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            b"keep_existing_expiration" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            b"check" => _serde::__private::Ok(__Field::__field3),
                                            b"return_previous_value" => {
                                                _serde::__private::Ok(__Field::__field4)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Command>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Command;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Command::Set",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Command::Set with 5 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<Timestamp>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Command::Set with 5 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<bool>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant Command::Set with 5 elements")) ;
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<KeyCheck>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct variant Command::Set with 5 elements")) ;
                                                }
                                            };
                                        let __field4 =
                                            match match _serde::de::SeqAccess::next_element::<bool>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (4usize , & "struct variant Command::Set with 5 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Command::Set {
                                            value: __field0,
                                            expiration: __field1,
                                            keep_existing_expiration: __field2,
                                            check: __field3,
                                            return_previous_value: __field4,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<Vec<u8>> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<Timestamp>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<bool> =
                                            _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<
                                            Option<KeyCheck>,
                                        > = _serde::__private::None;
                                        let mut __field4: _serde::__private::Option<bool> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("value")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<u8>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("expiration")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<Timestamp>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("keep_existing_expiration")) ;
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("check")) ;
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<KeyCheck>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field4 => {
                                                    if _serde::__private::Option::is_some(&__field4)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("return_previous_value")) ;
                                                    }
                                                    __field4 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("value")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "expiration",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "keep_existing_expiration",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("check")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field4 = match __field4 {
                                            _serde::__private::Some(__field4) => __field4,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "return_previous_value",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Command::Set {
                                            value: __field0,
                                            expiration: __field1,
                                            keep_existing_expiration: __field2,
                                            check: __field3,
                                            return_previous_value: __field4,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &[
                                    "value",
                                    "expiration",
                                    "keep_existing_expiration",
                                    "check",
                                    "return_previous_value",
                                ];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Command>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "delete" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"delete" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<Command>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = Command;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Command::Get",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<bool>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Command::Get with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Command::Get { delete: __field0 })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<bool> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("delete")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("delete")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Command::Get { delete: __field0 })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["delete"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Command>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(Command::Delete)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Set", "Get", "Delete"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Command",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Command>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Command {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Command::Set {
                    value: ref __self_0,
                    expiration: ref __self_1,
                    keep_existing_expiration: ref __self_2,
                    check: ref __self_3,
                    return_previous_value: ref __self_4,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Set");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "expiration",
                        &&(*__self_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "keep_existing_expiration",
                        &&(*__self_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "check",
                        &&(*__self_3),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "return_previous_value",
                        &&(*__self_4),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Command::Get {
                    delete: ref __self_0,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Get");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "delete",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Command::Delete,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Delete");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// The result of a [`KeyOperation`].
    pub enum Output {
        /// A status was returned.
        Status(KeyStatus),
        /// A value was returned.
        Value(Option<Vec<u8>>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Output {
        #[inline]
        fn clone(&self) -> Output {
            match (&*self,) {
                (&Output::Status(ref __self_0),) => {
                    Output::Status(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Output::Value(ref __self_0),) => {
                    Output::Value(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Output {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Output::Status(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Output",
                        0u32,
                        "Status",
                        __field0,
                    ),
                    Output::Value(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Output",
                        1u32,
                        "Value",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Output {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Status" => _serde::__private::Ok(__Field::__field0),
                            "Value" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Status" => _serde::__private::Ok(__Field::__field0),
                            b"Value" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Output>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Output;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Output")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<KeyStatus>(__variant),
                                Output::Status,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Option<Vec<u8>>>(
                                    __variant,
                                ),
                                Output::Value,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Status", "Value"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Output",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Output>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Output {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Output::Status(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Status");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Output::Value(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Value");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// The status of an operation on a Key.
    pub enum KeyStatus {
        /// A new key was inserted.
        Inserted,
        /// An existing key was updated with a new value.
        Updated,
        /// A key was deleted.
        Deleted,
        /// No changes were made.
        NotChanged,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for KeyStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for KeyStatus {
        #[inline]
        fn clone(&self) -> KeyStatus {
            {
                *self
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for KeyStatus {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    KeyStatus::Inserted => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyStatus",
                        0u32,
                        "Inserted",
                    ),
                    KeyStatus::Updated => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyStatus",
                        1u32,
                        "Updated",
                    ),
                    KeyStatus::Deleted => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyStatus",
                        2u32,
                        "Deleted",
                    ),
                    KeyStatus::NotChanged => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "KeyStatus",
                        3u32,
                        "NotChanged",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for KeyStatus {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Inserted" => _serde::__private::Ok(__Field::__field0),
                            "Updated" => _serde::__private::Ok(__Field::__field1),
                            "Deleted" => _serde::__private::Ok(__Field::__field2),
                            "NotChanged" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Inserted" => _serde::__private::Ok(__Field::__field0),
                            b"Updated" => _serde::__private::Ok(__Field::__field1),
                            b"Deleted" => _serde::__private::Ok(__Field::__field2),
                            b"NotChanged" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<KeyStatus>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = KeyStatus;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum KeyStatus")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyStatus::Inserted)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyStatus::Updated)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyStatus::Deleted)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(KeyStatus::NotChanged)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] =
                    &["Inserted", "Updated", "Deleted", "NotChanged"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "KeyStatus",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<KeyStatus>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for KeyStatus {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&KeyStatus::Inserted,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Inserted");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&KeyStatus::Updated,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Updated");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&KeyStatus::Deleted,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Deleted");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&KeyStatus::NotChanged,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "NotChanged");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for KeyStatus {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for KeyStatus {
        #[inline]
        fn eq(&self, other: &KeyStatus) -> bool {
            {
                let __self_vi = ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi = ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
}
#[cfg(feature = "networking")]
pub use fabruic;
#[cfg(feature = "networking")]
/// Types for implementing the `PliantDb` network protocol.
pub mod networking {
    use actionable::Action;
    pub use fabruic;
    use schema::SchemaName;
    use serde::{de::DeserializeOwned, Deserialize, Serialize};
    use crate::{
        connection::{AccessPolicy, Database, QueryKey},
        document::Document,
        kv::{KeyOperation, Output},
        schema::{
            self,
            view::{self, map},
            CollectionName, Key, MappedValue, ViewName,
        },
        transaction::{Executed, OperationResult, Transaction},
    };
    /// A payload with an associated id.
    pub struct Payload<T> {
        /// The unique id for this payload.
        pub id: Option<u32>,
        /// The wrapped payload.
        pub wrapped: T,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Payload<T> {
        #[inline]
        fn clone(&self) -> Payload<T> {
            match *self {
                Payload {
                    id: ref __self_0_0,
                    wrapped: ref __self_0_1,
                } => Payload {
                    id: ::core::clone::Clone::clone(&(*__self_0_0)),
                    wrapped: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T> _serde::Deserialize<'de> for Payload<T>
        where
            T: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "id" => _serde::__private::Ok(__Field::__field0),
                            "wrapped" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"id" => _serde::__private::Ok(__Field::__field0),
                            b"wrapped" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, T>
                where
                    T: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<Payload<T>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                where
                    T: _serde::Deserialize<'de>,
                {
                    type Value = Payload<T>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Payload")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Option<u32>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct Payload with 2 elements",
                                ));
                            }
                        };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<T>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            1usize,
                                            &"struct Payload with 2 elements",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Payload {
                            id: __field0,
                            wrapped: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Option<u32>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<T> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "id",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<u32>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "wrapped",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<T>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("wrapped") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Payload {
                            id: __field0,
                            wrapped: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["id", "wrapped"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Payload",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Payload<T>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T> _serde::Serialize for Payload<T>
        where
            T: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Payload",
                    false as usize + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "id",
                    &self.id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "wrapped",
                    &self.wrapped,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Payload<T> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Payload {
                    id: ref __self_0_0,
                    wrapped: ref __self_0_1,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Payload");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_0_0));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "wrapped",
                        &&(*__self_0_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A request made to a server.
    pub enum Request<T>
    where
        T: Action,
    {
        /// A server-related request.
        #[actionable(protection = "none")]
        Server(ServerRequest),
        /// A database-related request.
        #[actionable(protection = "none")]
        Database {
            /// The name of the database.
            database: String,
            /// The request made to the database.
            request: DatabaseRequest,
        },
        /// A database-related request.
        #[actionable(protection = "none", subaction)]
        Api(T),
    }
    #[doc(hidden)]
    pub trait RequestDispatcher<T>: Send + Sync
    where
        T: Action,
    {
        type Output: Send + Sync;
        type Error: From<actionable::PermissionDenied> + Send + Sync;
        type ServerHandler: ServerHandler<Dispatcher = Self>;
        type DatabaseHandler: DatabaseHandler<Dispatcher = Self>;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn dispatch_to_handlers<'life0, 'life1, 'async_trait>(
            &'life0 self,
            permissions: &'life1 actionable::Permissions,
            request: Request<T>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Output, Self::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<Self::Output, Self::Error>>
                {
                    return __ret;
                }
                let __self = self;
                let permissions = permissions;
                let request = request;
                let __ret: Result<Self::Output, Self::Error> = {
                    match request {
                        Request::Server(arg0) => {
                            Self::ServerHandler::handle(__self, permissions, arg0).await
                        }
                        Request::Database { database, request } => {
                            Self::DatabaseHandler::handle(__self, permissions, database, request)
                                .await
                        }
                        Request::Api(arg0) => __self.handle_subaction(permissions, arg0).await,
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_subaction<'life0, 'life1, 'async_trait>(
            &'life0 self,
            permissions: &'life1 actionable::Permissions,
            arg0: T,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Output, Self::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ServerHandler: Send + Sync {
        type Dispatcher: RequestDispatcher;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            arg0: ServerRequest,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as RequestDispatcher>::Output,
                            <Self::Dispatcher as RequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait DatabaseHandler: Send + Sync {
        type Dispatcher: RequestDispatcher;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            database: String,
            request: DatabaseRequest,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as RequestDispatcher>::Output,
                            <Self::Dispatcher as RequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::clone::Clone> ::core::clone::Clone for Request<T>
    where
        T: Action,
    {
        #[inline]
        fn clone(&self) -> Request<T> {
            match (&*self,) {
                (&Request::Server(ref __self_0),) => {
                    Request::Server(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Request::Database {
                    database: ref __self_0,
                    request: ref __self_1,
                },) => Request::Database {
                    database: ::core::clone::Clone::clone(&(*__self_0)),
                    request: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&Request::Api(ref __self_0),) => {
                    Request::Api(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de, T> _serde::Deserialize<'de> for Request<T>
        where
            T: Action,
            T: _serde::Deserialize<'de>,
        {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Server" => _serde::__private::Ok(__Field::__field0),
                            "Database" => _serde::__private::Ok(__Field::__field1),
                            "Api" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Server" => _serde::__private::Ok(__Field::__field0),
                            b"Database" => _serde::__private::Ok(__Field::__field1),
                            b"Api" => _serde::__private::Ok(__Field::__field2),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de, T>
                where
                    T: Action,
                    T: _serde::Deserialize<'de>,
                {
                    marker: _serde::__private::PhantomData<Request<T>>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                where
                    T: Action,
                    T: _serde::Deserialize<'de>,
                {
                    type Value = Request<T>;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Request")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ServerRequest>(
                                    __variant,
                                ),
                                Request::Server,
                            ),
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "database" => _serde::__private::Ok(__Field::__field0),
                                            "request" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"database" => _serde::__private::Ok(__Field::__field0),
                                            b"request" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de, T>
                                where
                                    T: Action,
                                    T: _serde::Deserialize<'de>,
                                {
                                    marker: _serde::__private::PhantomData<Request<T>>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de, T> _serde::de::Visitor<'de> for __Visitor<'de, T>
                                where
                                    T: Action,
                                    T: _serde::Deserialize<'de>,
                                {
                                    type Value = Request<T>;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant Request::Database",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Request::Database with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                DatabaseRequest,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Request::Database with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(Request::Database {
                                            database: __field0,
                                            request: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            DatabaseRequest,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("database")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("request")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            DatabaseRequest,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "database",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "request",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(Request::Database {
                                            database: __field0,
                                            request: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["database", "request"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<Request<T>>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<T>(__variant),
                                Request::Api,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Server", "Database", "Api"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Request",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Request<T>>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<T> _serde::Serialize for Request<T>
        where
            T: Action,
            T: _serde::Serialize,
        {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Request::Server(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Request",
                        0u32,
                        "Server",
                        __field0,
                    ),
                    Request::Database {
                        ref database,
                        ref request,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "Request",
                            1u32,
                            "Database",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "database",
                            database,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "request",
                            request,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    Request::Api(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Request",
                        2u32,
                        "Api",
                        __field0,
                    ),
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl<T: ::core::fmt::Debug> ::core::fmt::Debug for Request<T>
    where
        T: Action,
    {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Request::Server(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Server");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Request::Database {
                    database: ref __self_0,
                    request: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Database");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "database",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "request",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&Request::Api(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Api");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A server-related request.
    pub enum ServerRequest {
        /// Creates a database.
        #[actionable(protection = "simple")]
        CreateDatabase(Database),
        /// Deletes the database named `name`
        #[actionable(protection = "simple")]
        DeleteDatabase {
            /// The name of the database to delete.
            name: String,
        },
        /// Lists all databases.
        #[actionable(protection = "simple")]
        ListDatabases,
        /// Lists available schemas.
        #[actionable(protection = "simple")]
        ListAvailableSchemas,
    }
    #[doc(hidden)]
    pub trait ServerRequestDispatcher: Send + Sync {
        type Output: Send + Sync;
        type Error: From<actionable::PermissionDenied> + Send + Sync;
        type CreateDatabaseHandler: CreateDatabaseHandler<Dispatcher = Self>;
        type DeleteDatabaseHandler: DeleteDatabaseHandler<Dispatcher = Self>;
        type ListDatabasesHandler: ListDatabasesHandler<Dispatcher = Self>;
        type ListAvailableSchemasHandler: ListAvailableSchemasHandler<Dispatcher = Self>;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn dispatch_to_handlers<'life0, 'life1, 'async_trait>(
            &'life0 self,
            permissions: &'life1 actionable::Permissions,
            request: ServerRequest,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Output, Self::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<Self::Output, Self::Error>>
                {
                    return __ret;
                }
                let __self = self;
                let permissions = permissions;
                let request = request;
                let __ret: Result<Self::Output, Self::Error> = {
                    match request {
                        ServerRequest::CreateDatabase(arg0) => {
                            Self::CreateDatabaseHandler::handle(__self, permissions, arg0).await
                        }
                        ServerRequest::DeleteDatabase { name } => {
                            Self::DeleteDatabaseHandler::handle(__self, permissions, name).await
                        }
                        ServerRequest::ListDatabases => {
                            Self::ListDatabasesHandler::handle(__self, permissions).await
                        }
                        ServerRequest::ListAvailableSchemas => {
                            Self::ListAvailableSchemasHandler::handle(__self, permissions).await
                        }
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
    }
    #[doc(hidden)]
    pub trait CreateDatabaseHandler: Send + Sync {
        type Dispatcher: ServerRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            arg0: &'a Database,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            arg0: Database,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as ServerRequestDispatcher>::Output,
                        <Self::Dispatcher as ServerRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let arg0 = arg0;
                let __ret: Result<
                    <Self::Dispatcher as ServerRequestDispatcher>::Output,
                    <Self::Dispatcher as ServerRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &arg0);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, arg0).await
                    } else {
                        Err(<Self::Dispatcher as ServerRequestDispatcher>::Error::from(
                            actionable::PermissionDenied {
                                resource: resource.to_owned(),
                                action: actionable::Action::name(&action),
                            },
                        ))
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            arg0: Database,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait DeleteDatabaseHandler: Send + Sync {
        type Dispatcher: ServerRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            name: &'a String,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            name: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as ServerRequestDispatcher>::Output,
                        <Self::Dispatcher as ServerRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let name = name;
                let __ret: Result<
                    <Self::Dispatcher as ServerRequestDispatcher>::Output,
                    <Self::Dispatcher as ServerRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &name);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, name).await
                    } else {
                        Err(<Self::Dispatcher as ServerRequestDispatcher>::Error::from(
                            actionable::PermissionDenied {
                                resource: resource.to_owned(),
                                action: actionable::Action::name(&action),
                            },
                        ))
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            name: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ListDatabasesHandler: Send + Sync {
        type Dispatcher: ServerRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(dispatcher: &'a Self::Dispatcher) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as ServerRequestDispatcher>::Output,
                        <Self::Dispatcher as ServerRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let __ret: Result<
                    <Self::Dispatcher as ServerRequestDispatcher>::Output,
                    <Self::Dispatcher as ServerRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions).await
                    } else {
                        Err(<Self::Dispatcher as ServerRequestDispatcher>::Error::from(
                            actionable::PermissionDenied {
                                resource: resource.to_owned(),
                                action: actionable::Action::name(&action),
                            },
                        ))
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ListAvailableSchemasHandler: Send + Sync {
        type Dispatcher: ServerRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(dispatcher: &'a Self::Dispatcher) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as ServerRequestDispatcher>::Output,
                        <Self::Dispatcher as ServerRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let __ret: Result<
                    <Self::Dispatcher as ServerRequestDispatcher>::Output,
                    <Self::Dispatcher as ServerRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions).await
                    } else {
                        Err(<Self::Dispatcher as ServerRequestDispatcher>::Error::from(
                            actionable::PermissionDenied {
                                resource: resource.to_owned(),
                                action: actionable::Action::name(&action),
                            },
                        ))
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as ServerRequestDispatcher>::Output,
                            <Self::Dispatcher as ServerRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ServerRequest {
        #[inline]
        fn clone(&self) -> ServerRequest {
            match (&*self,) {
                (&ServerRequest::CreateDatabase(ref __self_0),) => {
                    ServerRequest::CreateDatabase(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&ServerRequest::DeleteDatabase { name: ref __self_0 },) => {
                    ServerRequest::DeleteDatabase {
                        name: ::core::clone::Clone::clone(&(*__self_0)),
                    }
                }
                (&ServerRequest::ListDatabases,) => ServerRequest::ListDatabases,
                (&ServerRequest::ListAvailableSchemas,) => ServerRequest::ListAvailableSchemas,
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ServerRequest {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "CreateDatabase" => _serde::__private::Ok(__Field::__field0),
                            "DeleteDatabase" => _serde::__private::Ok(__Field::__field1),
                            "ListDatabases" => _serde::__private::Ok(__Field::__field2),
                            "ListAvailableSchemas" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"CreateDatabase" => _serde::__private::Ok(__Field::__field0),
                            b"DeleteDatabase" => _serde::__private::Ok(__Field::__field1),
                            b"ListDatabases" => _serde::__private::Ok(__Field::__field2),
                            b"ListAvailableSchemas" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ServerRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ServerRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum ServerRequest")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Database>(__variant),
                                ServerRequest::CreateDatabase,
                            ),
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ServerRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ServerRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ServerRequest::DeleteDatabase",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant ServerRequest::DeleteDatabase with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(ServerRequest::DeleteDatabase {
                                            name: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("name") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ServerRequest::DeleteDatabase {
                                            name: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["name"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ServerRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(ServerRequest::ListDatabases)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(ServerRequest::ListAvailableSchemas)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "CreateDatabase",
                    "DeleteDatabase",
                    "ListDatabases",
                    "ListAvailableSchemas",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ServerRequest",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ServerRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ServerRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ServerRequest::CreateDatabase(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ServerRequest",
                            0u32,
                            "CreateDatabase",
                            __field0,
                        )
                    }
                    ServerRequest::DeleteDatabase { ref name } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ServerRequest",
                            1u32,
                            "DeleteDatabase",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "name",
                            name,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ServerRequest::ListDatabases => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "ServerRequest",
                        2u32,
                        "ListDatabases",
                    ),
                    ServerRequest::ListAvailableSchemas => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "ServerRequest",
                            3u32,
                            "ListAvailableSchemas",
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ServerRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ServerRequest::CreateDatabase(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "CreateDatabase");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&ServerRequest::DeleteDatabase { name: ref __self_0 },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DeleteDatabase");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "name", &&(*__self_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&ServerRequest::ListDatabases,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ListDatabases");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&ServerRequest::ListAvailableSchemas,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ListAvailableSchemas");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A database-related request.
    pub enum DatabaseRequest {
        /// Retrieve a single document.
        #[actionable(protection = "simple")]
        Get {
            /// The collection of the document.
            collection: CollectionName,
            /// The id of the document.
            id: u64,
        },
        /// Retrieve multiple documents.
        #[actionable(protection = "custom")]
        GetMultiple {
            /// The collection of the documents.
            collection: CollectionName,
            /// The ids of the documents.
            ids: Vec<u64>,
        },
        /// Queries a view.
        #[actionable(protection = "simple")]
        Query {
            /// The name of the view.
            view: ViewName,
            /// The filter for the view.
            key: Option<QueryKey<Vec<u8>>>,
            /// The access policy for the query.
            access_policy: AccessPolicy,
            /// If true, [`DatabaseResponse::ViewMappingsWithDocs`] will be
            /// returned. If false, [`DatabaseResponse::ViewMappings`] will be
            /// returned.
            with_docs: bool,
        },
        /// Reduces a view.
        #[actionable(protection = "simple")]
        Reduce {
            /// The name of the view.
            view: ViewName,
            /// The filter for the view.
            key: Option<QueryKey<Vec<u8>>>,
            /// The access policy for the query.
            access_policy: AccessPolicy,
            /// Whether to return a single value or values grouped by unique key. If
            /// true, [`DatabaseResponse::ViewGroupedReduction`] will be returned.
            /// If false, [`DatabaseResponse::ViewReduction`] is returned.
            grouped: bool,
        },
        /// Applies a transaction.
        #[actionable(protection = "custom")]
        ApplyTransaction {
            /// The trasnaction to apply.
            transaction: Transaction<'static>,
        },
        /// Lists executed transactions.
        #[actionable(protection = "simple")]
        ListExecutedTransactions {
            /// The starting transaction id.
            starting_id: Option<u64>,
            /// The maximum number of results.
            result_limit: Option<usize>,
        },
        /// Queries the last transaction id.
        #[actionable(protection = "simple")]
        LastTransactionId,
        /// Creates a `PubSub` [`Subscriber`](crate::pubsub::Subscriber)
        #[actionable(protection = "simple")]
        CreateSubscriber,
        /// Publishes `payload` to all subscribers of `topic`.
        #[actionable(protection = "simple")]
        Publish {
            /// The topics to publish to.
            topic: String,
            /// The payload to publish.
            payload: Vec<u8>,
        },
        /// Publishes `payload` to all subscribers of all `topics`.
        #[actionable(protection = "custom")]
        PublishToAll {
            /// The topics to publish to.
            topics: Vec<String>,
            /// The payload to publish.
            payload: Vec<u8>,
        },
        /// Subscribes `subscriber_id` to messages for `topic`.
        #[actionable(protection = "simple")]
        SubscribeTo {
            /// The id of the [`Subscriber`](crate::pubsub::Subscriber).
            subscriber_id: u64,
            /// The topic to subscribe to.
            topic: String,
        },
        /// Unsubscribes `subscriber_id` from messages for `topic`.
        #[actionable(protection = "simple")]
        UnsubscribeFrom {
            /// The id of the [`Subscriber`](crate::pubsub::Subscriber).
            subscriber_id: u64,
            /// The topic to unsubscribe from.
            topic: String,
        },
        /// Unregisters the subscriber.
        #[actionable(protection = "none")]
        UnregisterSubscriber {
            /// The id of the [`Subscriber`](crate::pubsub::Subscriber).
            subscriber_id: u64,
        },
        /// Excutes a key-value store operation.
        #[actionable(protection = "simple")]
        ExecuteKeyOperation(KeyOperation),
    }
    #[doc(hidden)]
    pub trait DatabaseRequestDispatcher: Send + Sync {
        type Output: Send + Sync;
        type Error: From<actionable::PermissionDenied> + Send + Sync;
        type GetHandler: GetHandler<Dispatcher = Self>;
        type GetMultipleHandler: GetMultipleHandler<Dispatcher = Self>;
        type QueryHandler: QueryHandler<Dispatcher = Self>;
        type ReduceHandler: ReduceHandler<Dispatcher = Self>;
        type ApplyTransactionHandler: ApplyTransactionHandler<Dispatcher = Self>;
        type ListExecutedTransactionsHandler: ListExecutedTransactionsHandler<Dispatcher = Self>;
        type LastTransactionIdHandler: LastTransactionIdHandler<Dispatcher = Self>;
        type CreateSubscriberHandler: CreateSubscriberHandler<Dispatcher = Self>;
        type PublishHandler: PublishHandler<Dispatcher = Self>;
        type PublishToAllHandler: PublishToAllHandler<Dispatcher = Self>;
        type SubscribeToHandler: SubscribeToHandler<Dispatcher = Self>;
        type UnsubscribeFromHandler: UnsubscribeFromHandler<Dispatcher = Self>;
        type UnregisterSubscriberHandler: UnregisterSubscriberHandler<Dispatcher = Self>;
        type ExecuteKeyOperationHandler: ExecuteKeyOperationHandler<Dispatcher = Self>;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn dispatch_to_handlers<'life0, 'life1, 'async_trait>(
            &'life0 self,
            permissions: &'life1 actionable::Permissions,
            request: DatabaseRequest,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Output, Self::Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<Self::Output, Self::Error>>
                {
                    return __ret;
                }
                let __self = self;
                let permissions = permissions;
                let request = request;
                let __ret: Result<Self::Output, Self::Error> = {
                    match request {
                        DatabaseRequest::Get { collection, id } => {
                            Self::GetHandler::handle(__self, permissions, collection, id).await
                        }
                        DatabaseRequest::GetMultiple { collection, ids } => {
                            Self::GetMultipleHandler::handle(__self, permissions, collection, ids)
                                .await
                        }
                        DatabaseRequest::Query {
                            view,
                            key,
                            access_policy,
                            with_docs,
                        } => {
                            Self::QueryHandler::handle(
                                __self,
                                permissions,
                                view,
                                key,
                                access_policy,
                                with_docs,
                            )
                            .await
                        }
                        DatabaseRequest::Reduce {
                            view,
                            key,
                            access_policy,
                            grouped,
                        } => {
                            Self::ReduceHandler::handle(
                                __self,
                                permissions,
                                view,
                                key,
                                access_policy,
                                grouped,
                            )
                            .await
                        }
                        DatabaseRequest::ApplyTransaction { transaction } => {
                            Self::ApplyTransactionHandler::handle(__self, permissions, transaction)
                                .await
                        }
                        DatabaseRequest::ListExecutedTransactions {
                            starting_id,
                            result_limit,
                        } => {
                            Self::ListExecutedTransactionsHandler::handle(
                                __self,
                                permissions,
                                starting_id,
                                result_limit,
                            )
                            .await
                        }
                        DatabaseRequest::LastTransactionId => {
                            Self::LastTransactionIdHandler::handle(__self, permissions).await
                        }
                        DatabaseRequest::CreateSubscriber => {
                            Self::CreateSubscriberHandler::handle(__self, permissions).await
                        }
                        DatabaseRequest::Publish { topic, payload } => {
                            Self::PublishHandler::handle(__self, permissions, topic, payload).await
                        }
                        DatabaseRequest::PublishToAll { topics, payload } => {
                            Self::PublishToAllHandler::handle(__self, permissions, topics, payload)
                                .await
                        }
                        DatabaseRequest::SubscribeTo {
                            subscriber_id,
                            topic,
                        } => {
                            Self::SubscribeToHandler::handle(
                                __self,
                                permissions,
                                subscriber_id,
                                topic,
                            )
                            .await
                        }
                        DatabaseRequest::UnsubscribeFrom {
                            subscriber_id,
                            topic,
                        } => {
                            Self::UnsubscribeFromHandler::handle(
                                __self,
                                permissions,
                                subscriber_id,
                                topic,
                            )
                            .await
                        }
                        DatabaseRequest::UnregisterSubscriber { subscriber_id } => {
                            Self::UnregisterSubscriberHandler::handle(
                                __self,
                                permissions,
                                subscriber_id,
                            )
                            .await
                        }
                        DatabaseRequest::ExecuteKeyOperation(arg0) => {
                            Self::ExecuteKeyOperationHandler::handle(__self, permissions, arg0)
                                .await
                        }
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
    }
    #[doc(hidden)]
    pub trait GetHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            collection: &'a CollectionName,
            id: &'a u64,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            collection: CollectionName,
            id: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let collection = collection;
                let id = id;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &collection, &id);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, collection, id).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            collection: CollectionName,
            id: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait GetMultipleHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn verify_permissions<'life0, 'life1, 'life2, 'life3, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            collection: &'life2 CollectionName,
            ids: &'life3 Vec<u64>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<(), <Self::Dispatcher as DatabaseRequestDispatcher>::Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            'life3: 'async_trait,
            Self: 'async_trait;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            collection: CollectionName,
            ids: Vec<u64>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let collection = collection;
                let ids = ids;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    Self::verify_permissions(dispatcher, permissions, &collection, &ids).await?;
                    Self::handle_protected(dispatcher, permissions, collection, ids).await
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            collection: CollectionName,
            ids: Vec<u64>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait QueryHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            view: &'a ViewName,
            key: &'a Option<QueryKey<Vec<u8>>>,
            access_policy: &'a AccessPolicy,
            with_docs: &'a bool,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            view: ViewName,
            key: Option<QueryKey<Vec<u8>>>,
            access_policy: AccessPolicy,
            with_docs: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let view = view;
                let key = key;
                let access_policy = access_policy;
                let with_docs = with_docs;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource =
                        Self::resource_name(dispatcher, &view, &key, &access_policy, &with_docs);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(
                            dispatcher,
                            permissions,
                            view,
                            key,
                            access_policy,
                            with_docs,
                        )
                        .await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            view: ViewName,
            key: Option<QueryKey<Vec<u8>>>,
            access_policy: AccessPolicy,
            with_docs: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ReduceHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            view: &'a ViewName,
            key: &'a Option<QueryKey<Vec<u8>>>,
            access_policy: &'a AccessPolicy,
            grouped: &'a bool,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            view: ViewName,
            key: Option<QueryKey<Vec<u8>>>,
            access_policy: AccessPolicy,
            grouped: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let view = view;
                let key = key;
                let access_policy = access_policy;
                let grouped = grouped;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource =
                        Self::resource_name(dispatcher, &view, &key, &access_policy, &grouped);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(
                            dispatcher,
                            permissions,
                            view,
                            key,
                            access_policy,
                            grouped,
                        )
                        .await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            view: ViewName,
            key: Option<QueryKey<Vec<u8>>>,
            access_policy: AccessPolicy,
            grouped: bool,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ApplyTransactionHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn verify_permissions<'life0, 'life1, 'life2, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            transaction: &'life2 Transaction<'static>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<(), <Self::Dispatcher as DatabaseRequestDispatcher>::Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            Self: 'async_trait;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            transaction: Transaction<'static>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let transaction = transaction;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    Self::verify_permissions(dispatcher, permissions, &transaction).await?;
                    Self::handle_protected(dispatcher, permissions, transaction).await
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            transaction: Transaction<'static>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ListExecutedTransactionsHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            starting_id: &'a Option<u64>,
            result_limit: &'a Option<usize>,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            starting_id: Option<u64>,
            result_limit: Option<usize>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let starting_id = starting_id;
                let result_limit = result_limit;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &starting_id, &result_limit);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, starting_id, result_limit)
                            .await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            starting_id: Option<u64>,
            result_limit: Option<usize>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait LastTransactionIdHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(dispatcher: &'a Self::Dispatcher) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait CreateSubscriberHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(dispatcher: &'a Self::Dispatcher) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait PublishHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            topic: &'a String,
            payload: &'a Vec<u8>,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            topic: String,
            payload: Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let topic = topic;
                let payload = payload;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &topic, &payload);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, topic, payload).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            topic: String,
            payload: Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait PublishToAllHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn verify_permissions<'life0, 'life1, 'life2, 'life3, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            topics: &'life2 Vec<String>,
            payload: &'life3 Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<(), <Self::Dispatcher as DatabaseRequestDispatcher>::Error>,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            'life2: 'async_trait,
            'life3: 'async_trait,
            Self: 'async_trait;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            topics: Vec<String>,
            payload: Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let topics = topics;
                let payload = payload;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    Self::verify_permissions(dispatcher, permissions, &topics, &payload).await?;
                    Self::handle_protected(dispatcher, permissions, topics, payload).await
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            topics: Vec<String>,
            payload: Vec<u8>,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait SubscribeToHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            subscriber_id: &'a u64,
            topic: &'a String,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            subscriber_id: u64,
            topic: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let subscriber_id = subscriber_id;
                let topic = topic;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &subscriber_id, &topic);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, subscriber_id, topic).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            subscriber_id: u64,
            topic: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait UnsubscribeFromHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            subscriber_id: &'a u64,
            topic: &'a String,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            subscriber_id: u64,
            topic: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let subscriber_id = subscriber_id;
                let topic = topic;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &subscriber_id, &topic);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, subscriber_id, topic).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            subscriber_id: u64,
            topic: String,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait UnregisterSubscriberHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            subscriber_id: u64,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[doc(hidden)]
    pub trait ExecuteKeyOperationHandler: Send + Sync {
        type Dispatcher: DatabaseRequestDispatcher;
        #[allow(clippy::ptr_arg)]
        fn resource_name<'a>(
            dispatcher: &'a Self::Dispatcher,
            arg0: &'a KeyOperation,
        ) -> actionable::ResourceName<'a>;
        type Action: actionable::Action;
        fn action() -> Self::Action;
        #[must_use]
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn handle<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            arg0: KeyOperation,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) = ::core::option::Option::None::<
                    Result<
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                        <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                    >,
                > {
                    return __ret;
                }
                let dispatcher = dispatcher;
                let permissions = permissions;
                let arg0 = arg0;
                let __ret: Result<
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                    <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                > = {
                    let resource = Self::resource_name(dispatcher, &arg0);
                    let action = Self::action();
                    if permissions.allowed_to(&resource, &action) {
                        Self::handle_protected(dispatcher, permissions, arg0).await
                    } else {
                        Err(
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error::from(
                                actionable::PermissionDenied {
                                    resource: resource.to_owned(),
                                    action: actionable::Action::name(&action),
                                },
                            ),
                        )
                    }
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn handle_protected<'life0, 'life1, 'async_trait>(
            dispatcher: &'life0 Self::Dispatcher,
            permissions: &'life1 actionable::Permissions,
            arg0: KeyOperation,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<
                        Output = Result<
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Output,
                            <Self::Dispatcher as DatabaseRequestDispatcher>::Error,
                        >,
                    > + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DatabaseRequest {
        #[inline]
        fn clone(&self) -> DatabaseRequest {
            match (&*self,) {
                (&DatabaseRequest::Get {
                    collection: ref __self_0,
                    id: ref __self_1,
                },) => DatabaseRequest::Get {
                    collection: ::core::clone::Clone::clone(&(*__self_0)),
                    id: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::GetMultiple {
                    collection: ref __self_0,
                    ids: ref __self_1,
                },) => DatabaseRequest::GetMultiple {
                    collection: ::core::clone::Clone::clone(&(*__self_0)),
                    ids: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::Query {
                    view: ref __self_0,
                    key: ref __self_1,
                    access_policy: ref __self_2,
                    with_docs: ref __self_3,
                },) => DatabaseRequest::Query {
                    view: ::core::clone::Clone::clone(&(*__self_0)),
                    key: ::core::clone::Clone::clone(&(*__self_1)),
                    access_policy: ::core::clone::Clone::clone(&(*__self_2)),
                    with_docs: ::core::clone::Clone::clone(&(*__self_3)),
                },
                (&DatabaseRequest::Reduce {
                    view: ref __self_0,
                    key: ref __self_1,
                    access_policy: ref __self_2,
                    grouped: ref __self_3,
                },) => DatabaseRequest::Reduce {
                    view: ::core::clone::Clone::clone(&(*__self_0)),
                    key: ::core::clone::Clone::clone(&(*__self_1)),
                    access_policy: ::core::clone::Clone::clone(&(*__self_2)),
                    grouped: ::core::clone::Clone::clone(&(*__self_3)),
                },
                (&DatabaseRequest::ApplyTransaction {
                    transaction: ref __self_0,
                },) => DatabaseRequest::ApplyTransaction {
                    transaction: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&DatabaseRequest::ListExecutedTransactions {
                    starting_id: ref __self_0,
                    result_limit: ref __self_1,
                },) => DatabaseRequest::ListExecutedTransactions {
                    starting_id: ::core::clone::Clone::clone(&(*__self_0)),
                    result_limit: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::LastTransactionId,) => DatabaseRequest::LastTransactionId,
                (&DatabaseRequest::CreateSubscriber,) => DatabaseRequest::CreateSubscriber,
                (&DatabaseRequest::Publish {
                    topic: ref __self_0,
                    payload: ref __self_1,
                },) => DatabaseRequest::Publish {
                    topic: ::core::clone::Clone::clone(&(*__self_0)),
                    payload: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::PublishToAll {
                    topics: ref __self_0,
                    payload: ref __self_1,
                },) => DatabaseRequest::PublishToAll {
                    topics: ::core::clone::Clone::clone(&(*__self_0)),
                    payload: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::SubscribeTo {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                },) => DatabaseRequest::SubscribeTo {
                    subscriber_id: ::core::clone::Clone::clone(&(*__self_0)),
                    topic: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::UnsubscribeFrom {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                },) => DatabaseRequest::UnsubscribeFrom {
                    subscriber_id: ::core::clone::Clone::clone(&(*__self_0)),
                    topic: ::core::clone::Clone::clone(&(*__self_1)),
                },
                (&DatabaseRequest::UnregisterSubscriber {
                    subscriber_id: ref __self_0,
                },) => DatabaseRequest::UnregisterSubscriber {
                    subscriber_id: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&DatabaseRequest::ExecuteKeyOperation(ref __self_0),) => {
                    DatabaseRequest::ExecuteKeyOperation(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DatabaseRequest {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                    __field11,
                    __field12,
                    __field13,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            11u64 => _serde::__private::Ok(__Field::__field11),
                            12u64 => _serde::__private::Ok(__Field::__field12),
                            13u64 => _serde::__private::Ok(__Field::__field13),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 14",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Get" => _serde::__private::Ok(__Field::__field0),
                            "GetMultiple" => _serde::__private::Ok(__Field::__field1),
                            "Query" => _serde::__private::Ok(__Field::__field2),
                            "Reduce" => _serde::__private::Ok(__Field::__field3),
                            "ApplyTransaction" => _serde::__private::Ok(__Field::__field4),
                            "ListExecutedTransactions" => _serde::__private::Ok(__Field::__field5),
                            "LastTransactionId" => _serde::__private::Ok(__Field::__field6),
                            "CreateSubscriber" => _serde::__private::Ok(__Field::__field7),
                            "Publish" => _serde::__private::Ok(__Field::__field8),
                            "PublishToAll" => _serde::__private::Ok(__Field::__field9),
                            "SubscribeTo" => _serde::__private::Ok(__Field::__field10),
                            "UnsubscribeFrom" => _serde::__private::Ok(__Field::__field11),
                            "UnregisterSubscriber" => _serde::__private::Ok(__Field::__field12),
                            "ExecuteKeyOperation" => _serde::__private::Ok(__Field::__field13),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Get" => _serde::__private::Ok(__Field::__field0),
                            b"GetMultiple" => _serde::__private::Ok(__Field::__field1),
                            b"Query" => _serde::__private::Ok(__Field::__field2),
                            b"Reduce" => _serde::__private::Ok(__Field::__field3),
                            b"ApplyTransaction" => _serde::__private::Ok(__Field::__field4),
                            b"ListExecutedTransactions" => _serde::__private::Ok(__Field::__field5),
                            b"LastTransactionId" => _serde::__private::Ok(__Field::__field6),
                            b"CreateSubscriber" => _serde::__private::Ok(__Field::__field7),
                            b"Publish" => _serde::__private::Ok(__Field::__field8),
                            b"PublishToAll" => _serde::__private::Ok(__Field::__field9),
                            b"SubscribeTo" => _serde::__private::Ok(__Field::__field10),
                            b"UnsubscribeFrom" => _serde::__private::Ok(__Field::__field11),
                            b"UnregisterSubscriber" => _serde::__private::Ok(__Field::__field12),
                            b"ExecuteKeyOperation" => _serde::__private::Ok(__Field::__field13),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DatabaseRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum DatabaseRequest")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "id" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"id" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::Get",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                CollectionName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::Get with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::Get with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::Get {
                                            collection: __field0,
                                            id: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            CollectionName,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("collection")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            CollectionName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("id")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "collection",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("id") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::Get {
                                            collection: __field0,
                                            id: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["collection", "id"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "ids" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"collection" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"ids" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::GetMultiple",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                CollectionName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::GetMultiple with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Vec<u64>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::GetMultiple with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::GetMultiple {
                                            collection: __field0,
                                            ids: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            CollectionName,
                                        > = _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Vec<u64>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("collection")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            CollectionName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("ids")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<u64>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "collection",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("ids") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::GetMultiple {
                                            collection: __field0,
                                            ids: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["collection", "ids"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "view" => _serde::__private::Ok(__Field::__field0),
                                            "key" => _serde::__private::Ok(__Field::__field1),
                                            "access_policy" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            "with_docs" => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"view" => _serde::__private::Ok(__Field::__field0),
                                            b"key" => _serde::__private::Ok(__Field::__field1),
                                            b"access_policy" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            b"with_docs" => {
                                                _serde::__private::Ok(__Field::__field3)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::Query",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                ViewName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::Query with 4 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<QueryKey<Vec<u8>>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::Query with 4 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                AccessPolicy,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant DatabaseRequest::Query with 4 elements")) ;
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<bool>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct variant DatabaseRequest::Query with 4 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::Query {
                                            view: __field0,
                                            key: __field1,
                                            access_policy: __field2,
                                            with_docs: __field3,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<ViewName> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<QueryKey<Vec<u8>>>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<AccessPolicy> =
                                            _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<bool> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("view")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ViewName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<QueryKey<Vec<u8>>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("access_policy")) ;
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            AccessPolicy,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("with_docs")) ;
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("view") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("key") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "access_policy",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "with_docs",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::Query {
                                            view: __field0,
                                            key: __field1,
                                            access_policy: __field2,
                                            with_docs: __field3,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["view", "key", "access_policy", "with_docs"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field3, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __field3,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            3u64 => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "view" => _serde::__private::Ok(__Field::__field0),
                                            "key" => _serde::__private::Ok(__Field::__field1),
                                            "access_policy" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            "grouped" => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"view" => _serde::__private::Ok(__Field::__field0),
                                            b"key" => _serde::__private::Ok(__Field::__field1),
                                            b"access_policy" => {
                                                _serde::__private::Ok(__Field::__field2)
                                            }
                                            b"grouped" => _serde::__private::Ok(__Field::__field3),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::Reduce",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                ViewName,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::Reduce with 4 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<QueryKey<Vec<u8>>>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::Reduce with 4 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                AccessPolicy,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant DatabaseRequest::Reduce with 4 elements")) ;
                                                }
                                            };
                                        let __field3 =
                                            match match _serde::de::SeqAccess::next_element::<bool>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (3usize , & "struct variant DatabaseRequest::Reduce with 4 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::Reduce {
                                            view: __field0,
                                            key: __field1,
                                            access_policy: __field2,
                                            grouped: __field3,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<ViewName> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<
                                            Option<QueryKey<Vec<u8>>>,
                                        > = _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<AccessPolicy> =
                                            _serde::__private::None;
                                        let mut __field3: _serde::__private::Option<bool> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("view")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            ViewName,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("key")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<QueryKey<Vec<u8>>>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("access_policy")) ;
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            AccessPolicy,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field3 => {
                                                    if _serde::__private::Option::is_some(&__field3)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("grouped")) ;
                                                    }
                                                    __field3 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            bool,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("view") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("key") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "access_policy",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field3 = match __field3 {
                                            _serde::__private::Some(__field3) => __field3,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "grouped",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::Reduce {
                                            view: __field0,
                                            key: __field1,
                                            access_policy: __field2,
                                            grouped: __field3,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["view", "key", "access_policy", "grouped"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field4, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "transaction" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"transaction" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::ApplyTransaction",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Transaction<'static>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::ApplyTransaction with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::ApplyTransaction {
                                            transaction: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<
                                            Transaction<'static>,
                                        > = _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("transaction")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Transaction<'static>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "transaction",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::ApplyTransaction {
                                            transaction: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["transaction"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field5, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "starting_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "result_limit" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"starting_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"result_limit" => {
                                                _serde::__private::Ok(__Field::__field1)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde :: __private :: Formatter :: write_str (__formatter , "struct variant DatabaseRequest::ListExecutedTransactions")
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<u64>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::ListExecutedTransactions with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Option<usize>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::ListExecutedTransactions with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(
                                            DatabaseRequest::ListExecutedTransactions {
                                                starting_id: __field0,
                                                result_limit: __field1,
                                            },
                                        )
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<Option<u64>> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Option<usize>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("starting_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<u64>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("result_limit")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Option<usize>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "starting_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "result_limit",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(
                                            DatabaseRequest::ListExecutedTransactions {
                                                starting_id: __field0,
                                                result_limit: __field1,
                                            },
                                        )
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["starting_id", "result_limit"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(DatabaseRequest::LastTransactionId)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(DatabaseRequest::CreateSubscriber)
                            }
                            (__Field::__field8, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "topic" => _serde::__private::Ok(__Field::__field0),
                                            "payload" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"topic" => _serde::__private::Ok(__Field::__field0),
                                            b"payload" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::Publish",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::Publish with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::Publish with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::Publish {
                                            topic: __field0,
                                            payload: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Vec<u8>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("topic")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("payload")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<u8>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("topic")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "payload",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::Publish {
                                            topic: __field0,
                                            payload: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["topic", "payload"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field9, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "topics" => _serde::__private::Ok(__Field::__field0),
                                            "payload" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"topics" => _serde::__private::Ok(__Field::__field0),
                                            b"payload" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::PublishToAll",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<
                                                Vec<String>,
                                            >(
                                                &mut __seq
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::PublishToAll with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::PublishToAll with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::PublishToAll {
                                            topics: __field0,
                                            payload: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<Vec<String>> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<Vec<u8>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("topics")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<String>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("payload")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<u8>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("topics")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "payload",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::PublishToAll {
                                            topics: __field0,
                                            payload: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["topics", "payload"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field10, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "topic" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"topic" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::SubscribeTo",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::SubscribeTo with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::SubscribeTo with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::SubscribeTo {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("subscriber_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("topic")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "subscriber_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("topic")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::SubscribeTo {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["subscriber_id", "topic"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field11, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "topic" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"topic" => _serde::__private::Ok(__Field::__field1),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::UnsubscribeFrom",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::UnsubscribeFrom with 2 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseRequest::UnsubscribeFrom with 2 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseRequest::UnsubscribeFrom {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("subscriber_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("topic")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "subscriber_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("topic")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseRequest::UnsubscribeFrom {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["subscriber_id", "topic"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field12, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseRequest>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseRequest;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseRequest::UnregisterSubscriber",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseRequest::UnregisterSubscriber with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(
                                            DatabaseRequest::UnregisterSubscriber {
                                                subscriber_id: __field0,
                                            },
                                        )
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("subscriber_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "subscriber_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(
                                            DatabaseRequest::UnregisterSubscriber {
                                                subscriber_id: __field0,
                                            },
                                        )
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["subscriber_id"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field13, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<KeyOperation>(
                                    __variant,
                                ),
                                DatabaseRequest::ExecuteKeyOperation,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Get",
                    "GetMultiple",
                    "Query",
                    "Reduce",
                    "ApplyTransaction",
                    "ListExecutedTransactions",
                    "LastTransactionId",
                    "CreateSubscriber",
                    "Publish",
                    "PublishToAll",
                    "SubscribeTo",
                    "UnsubscribeFrom",
                    "UnregisterSubscriber",
                    "ExecuteKeyOperation",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DatabaseRequest",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DatabaseRequest>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DatabaseRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DatabaseRequest::Get {
                        ref collection,
                        ref id,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            0u32,
                            "Get",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "collection",
                            collection,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "id",
                            id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::GetMultiple {
                        ref collection,
                        ref ids,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            1u32,
                            "GetMultiple",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "collection",
                            collection,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "ids",
                            ids,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::Query {
                        ref view,
                        ref key,
                        ref access_policy,
                        ref with_docs,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            2u32,
                            "Query",
                            0 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "view",
                            view,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "access_policy",
                            access_policy,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "with_docs",
                            with_docs,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::Reduce {
                        ref view,
                        ref key,
                        ref access_policy,
                        ref grouped,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            3u32,
                            "Reduce",
                            0 + 1 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "view",
                            view,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "key",
                            key,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "access_policy",
                            access_policy,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "grouped",
                            grouped,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::ApplyTransaction { ref transaction } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            4u32,
                            "ApplyTransaction",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "transaction",
                            transaction,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::ListExecutedTransactions {
                        ref starting_id,
                        ref result_limit,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            5u32,
                            "ListExecutedTransactions",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "starting_id",
                            starting_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "result_limit",
                            result_limit,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::LastTransactionId => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DatabaseRequest",
                            6u32,
                            "LastTransactionId",
                        )
                    }
                    DatabaseRequest::CreateSubscriber => {
                        _serde::Serializer::serialize_unit_variant(
                            __serializer,
                            "DatabaseRequest",
                            7u32,
                            "CreateSubscriber",
                        )
                    }
                    DatabaseRequest::Publish {
                        ref topic,
                        ref payload,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            8u32,
                            "Publish",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "topic",
                            topic,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "payload",
                            payload,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::PublishToAll {
                        ref topics,
                        ref payload,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            9u32,
                            "PublishToAll",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "topics",
                            topics,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "payload",
                            payload,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::SubscribeTo {
                        ref subscriber_id,
                        ref topic,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            10u32,
                            "SubscribeTo",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "subscriber_id",
                            subscriber_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "topic",
                            topic,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::UnsubscribeFrom {
                        ref subscriber_id,
                        ref topic,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            11u32,
                            "UnsubscribeFrom",
                            0 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "subscriber_id",
                            subscriber_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "topic",
                            topic,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::UnregisterSubscriber { ref subscriber_id } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseRequest",
                            12u32,
                            "UnregisterSubscriber",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "subscriber_id",
                            subscriber_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseRequest::ExecuteKeyOperation(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseRequest",
                            13u32,
                            "ExecuteKeyOperation",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DatabaseRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&DatabaseRequest::Get {
                    collection: ref __self_0,
                    id: ref __self_1,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Get");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "id", &&(*__self_1));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::GetMultiple {
                    collection: ref __self_0,
                    ids: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "GetMultiple");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "collection",
                        &&(*__self_0),
                    );
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "ids", &&(*__self_1));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::Query {
                    view: ref __self_0,
                    key: ref __self_1,
                    access_policy: ref __self_2,
                    with_docs: ref __self_3,
                },) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Query");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "view", &&(*__self_0));
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "key", &&(*__self_1));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "access_policy",
                        &&(*__self_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "with_docs",
                        &&(*__self_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::Reduce {
                    view: ref __self_0,
                    key: ref __self_1,
                    access_policy: ref __self_2,
                    grouped: ref __self_3,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Reduce");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "view", &&(*__self_0));
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "key", &&(*__self_1));
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "access_policy",
                        &&(*__self_2),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "grouped",
                        &&(*__self_3),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::ApplyTransaction {
                    transaction: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "ApplyTransaction");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "transaction",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::ListExecutedTransactions {
                    starting_id: ref __self_0,
                    result_limit: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "ListExecutedTransactions");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "starting_id",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "result_limit",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::LastTransactionId,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LastTransactionId");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseRequest::CreateSubscriber,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "CreateSubscriber");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseRequest::Publish {
                    topic: ref __self_0,
                    payload: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Publish");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "topic",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "payload",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::PublishToAll {
                    topics: ref __self_0,
                    payload: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "PublishToAll");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "topics",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "payload",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::SubscribeTo {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "SubscribeTo");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subscriber_id",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "topic",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::UnsubscribeFrom {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "UnsubscribeFrom");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subscriber_id",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "topic",
                        &&(*__self_1),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::UnregisterSubscriber {
                    subscriber_id: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "UnregisterSubscriber");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subscriber_id",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseRequest::ExecuteKeyOperation(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ExecuteKeyOperation");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A response from a server.
    pub enum Response {
        /// A request succeded but provided no output.
        Ok,
        /// A response to a [`ServerRequest`].
        Server(ServerResponse),
        /// A response to a [`DatabaseRequest`].
        Database(DatabaseResponse),
        /// An error occurred processing a request.
        Error(crate::Error),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Response {
        #[inline]
        fn clone(&self) -> Response {
            match (&*self,) {
                (&Response::Ok,) => Response::Ok,
                (&Response::Server(ref __self_0),) => {
                    Response::Server(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Response::Database(ref __self_0),) => {
                    Response::Database(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Response::Error(ref __self_0),) => {
                    Response::Error(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Response {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Response::Ok => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Response",
                        0u32,
                        "Ok",
                    ),
                    Response::Server(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Response",
                            1u32,
                            "Server",
                            __field0,
                        )
                    }
                    Response::Database(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Response",
                            2u32,
                            "Database",
                            __field0,
                        )
                    }
                    Response::Error(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Response",
                        3u32,
                        "Error",
                        __field0,
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Response {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Ok" => _serde::__private::Ok(__Field::__field0),
                            "Server" => _serde::__private::Ok(__Field::__field1),
                            "Database" => _serde::__private::Ok(__Field::__field2),
                            "Error" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Ok" => _serde::__private::Ok(__Field::__field0),
                            b"Server" => _serde::__private::Ok(__Field::__field1),
                            b"Database" => _serde::__private::Ok(__Field::__field2),
                            b"Error" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Response>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Response;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Response")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(Response::Ok)
                            }
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<ServerResponse>(
                                    __variant,
                                ),
                                Response::Server,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<DatabaseResponse>(
                                    __variant,
                                ),
                                Response::Database,
                            ),
                            (__Field::__field3, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<crate::Error>(
                                    __variant,
                                ),
                                Response::Error,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Ok", "Server", "Database", "Error"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Response",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Response>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Response {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Response::Ok,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Ok");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Response::Server(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Server");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Response::Database(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Database");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Response::Error(ref __self_0),) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Error");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A response to a [`ServerRequest`].
    pub enum ServerResponse {
        /// A database with `name` was successfully created.
        DatabaseCreated {
            /// The name of the database to create.
            name: String,
        },
        /// A database with `name` was successfully removed.
        DatabaseDeleted {
            /// The name of the database to remove.
            name: String,
        },
        /// A list of available databases.
        Databases(Vec<Database>),
        ///A list of availble schemas.
        AvailableSchemas(Vec<SchemaName>),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ServerResponse {
        #[inline]
        fn clone(&self) -> ServerResponse {
            match (&*self,) {
                (&ServerResponse::DatabaseCreated { name: ref __self_0 },) => {
                    ServerResponse::DatabaseCreated {
                        name: ::core::clone::Clone::clone(&(*__self_0)),
                    }
                }
                (&ServerResponse::DatabaseDeleted { name: ref __self_0 },) => {
                    ServerResponse::DatabaseDeleted {
                        name: ::core::clone::Clone::clone(&(*__self_0)),
                    }
                }
                (&ServerResponse::Databases(ref __self_0),) => {
                    ServerResponse::Databases(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&ServerResponse::AvailableSchemas(ref __self_0),) => {
                    ServerResponse::AvailableSchemas(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ServerResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    ServerResponse::DatabaseCreated { ref name } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ServerResponse",
                            0u32,
                            "DatabaseCreated",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "name",
                            name,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ServerResponse::DatabaseDeleted { ref name } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "ServerResponse",
                            1u32,
                            "DatabaseDeleted",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "name",
                            name,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    ServerResponse::Databases(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ServerResponse",
                            2u32,
                            "Databases",
                            __field0,
                        )
                    }
                    ServerResponse::AvailableSchemas(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "ServerResponse",
                            3u32,
                            "AvailableSchemas",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ServerResponse {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 4",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "DatabaseCreated" => _serde::__private::Ok(__Field::__field0),
                            "DatabaseDeleted" => _serde::__private::Ok(__Field::__field1),
                            "Databases" => _serde::__private::Ok(__Field::__field2),
                            "AvailableSchemas" => _serde::__private::Ok(__Field::__field3),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"DatabaseCreated" => _serde::__private::Ok(__Field::__field0),
                            b"DatabaseDeleted" => _serde::__private::Ok(__Field::__field1),
                            b"Databases" => _serde::__private::Ok(__Field::__field2),
                            b"AvailableSchemas" => _serde::__private::Ok(__Field::__field3),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<ServerResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ServerResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum ServerResponse")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ServerResponse>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ServerResponse;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ServerResponse::DatabaseCreated",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant ServerResponse::DatabaseCreated with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(ServerResponse::DatabaseCreated {
                                            name: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("name") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ServerResponse::DatabaseCreated {
                                            name: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["name"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ServerResponse>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field1, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"name" => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<ServerResponse>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = ServerResponse;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant ServerResponse::DatabaseDeleted",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant ServerResponse::DatabaseDeleted with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(ServerResponse::DatabaseDeleted {
                                            name: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("name")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("name") {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(ServerResponse::DatabaseDeleted {
                                            name: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["name"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<ServerResponse>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<Database>>(
                                    __variant,
                                ),
                                ServerResponse::Databases,
                            ),
                            (__Field::__field3, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<SchemaName>>(
                                    __variant,
                                ),
                                ServerResponse::AvailableSchemas,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "DatabaseCreated",
                    "DatabaseDeleted",
                    "Databases",
                    "AvailableSchemas",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "ServerResponse",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<ServerResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ServerResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&ServerResponse::DatabaseCreated { name: ref __self_0 },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DatabaseCreated");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "name", &&(*__self_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&ServerResponse::DatabaseDeleted { name: ref __self_0 },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "DatabaseDeleted");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder, "name", &&(*__self_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&ServerResponse::Databases(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Databases");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&ServerResponse::AvailableSchemas(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "AvailableSchemas");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A response to a [`DatabaseRequest`].
    pub enum DatabaseResponse {
        /// One or more documents.
        Documents(Vec<Document<'static>>),
        /// Results of [`DatabaseRequest::ApplyTransaction`].
        TransactionResults(Vec<OperationResult>),
        /// Results of [`DatabaseRequest::Query`] when `with_docs` is false.
        ViewMappings(Vec<map::Serialized>),
        /// Results of [`DatabaseRequest::Query`] when `with_docs` is true.
        ViewMappingsWithDocs(Vec<MappedDocument>),
        /// Result of [`DatabaseRequest::Reduce`] when `grouped` is false.
        ViewReduction(Vec<u8>),
        /// Result of [`DatabaseRequest::Reduce`] when `grouped` is true.
        ViewGroupedReduction(Vec<MappedValue<Vec<u8>, Vec<u8>>>),
        /// Results of [`DatabaseRequest::ListExecutedTransactions`].
        ExecutedTransactions(Vec<Executed<'static>>),
        /// Result of [`DatabaseRequest::LastTransactionId`].
        LastTransactionId(Option<u64>),
        /// A new `PubSub` subscriber was created.
        SubscriberCreated {
            /// The unique ID of the subscriber.
            subscriber_id: u64,
        },
        /// A PubSub message was received.
        MessageReceived {
            /// The ID of the subscriber receiving the message.
            subscriber_id: u64,
            /// The topic the payload was received on.
            topic: String,
            /// The message payload.
            payload: Vec<u8>,
        },
        /// Output from a [`KeyOperation`] being executed.
        KvOutput(Output),
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for DatabaseResponse {
        #[inline]
        fn clone(&self) -> DatabaseResponse {
            match (&*self,) {
                (&DatabaseResponse::Documents(ref __self_0),) => {
                    DatabaseResponse::Documents(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DatabaseResponse::TransactionResults(ref __self_0),) => {
                    DatabaseResponse::TransactionResults(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DatabaseResponse::ViewMappings(ref __self_0),) => {
                    DatabaseResponse::ViewMappings(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DatabaseResponse::ViewMappingsWithDocs(ref __self_0),) => {
                    DatabaseResponse::ViewMappingsWithDocs(::core::clone::Clone::clone(
                        &(*__self_0),
                    ))
                }
                (&DatabaseResponse::ViewReduction(ref __self_0),) => {
                    DatabaseResponse::ViewReduction(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DatabaseResponse::ViewGroupedReduction(ref __self_0),) => {
                    DatabaseResponse::ViewGroupedReduction(::core::clone::Clone::clone(
                        &(*__self_0),
                    ))
                }
                (&DatabaseResponse::ExecutedTransactions(ref __self_0),) => {
                    DatabaseResponse::ExecutedTransactions(::core::clone::Clone::clone(
                        &(*__self_0),
                    ))
                }
                (&DatabaseResponse::LastTransactionId(ref __self_0),) => {
                    DatabaseResponse::LastTransactionId(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&DatabaseResponse::SubscriberCreated {
                    subscriber_id: ref __self_0,
                },) => DatabaseResponse::SubscriberCreated {
                    subscriber_id: ::core::clone::Clone::clone(&(*__self_0)),
                },
                (&DatabaseResponse::MessageReceived {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                    payload: ref __self_2,
                },) => DatabaseResponse::MessageReceived {
                    subscriber_id: ::core::clone::Clone::clone(&(*__self_0)),
                    topic: ::core::clone::Clone::clone(&(*__self_1)),
                    payload: ::core::clone::Clone::clone(&(*__self_2)),
                },
                (&DatabaseResponse::KvOutput(ref __self_0),) => {
                    DatabaseResponse::KvOutput(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for DatabaseResponse {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    DatabaseResponse::Documents(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            0u32,
                            "Documents",
                            __field0,
                        )
                    }
                    DatabaseResponse::TransactionResults(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            1u32,
                            "TransactionResults",
                            __field0,
                        )
                    }
                    DatabaseResponse::ViewMappings(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            2u32,
                            "ViewMappings",
                            __field0,
                        )
                    }
                    DatabaseResponse::ViewMappingsWithDocs(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            3u32,
                            "ViewMappingsWithDocs",
                            __field0,
                        )
                    }
                    DatabaseResponse::ViewReduction(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            4u32,
                            "ViewReduction",
                            __field0,
                        )
                    }
                    DatabaseResponse::ViewGroupedReduction(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            5u32,
                            "ViewGroupedReduction",
                            __field0,
                        )
                    }
                    DatabaseResponse::ExecutedTransactions(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            6u32,
                            "ExecutedTransactions",
                            __field0,
                        )
                    }
                    DatabaseResponse::LastTransactionId(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            7u32,
                            "LastTransactionId",
                            __field0,
                        )
                    }
                    DatabaseResponse::SubscriberCreated { ref subscriber_id } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseResponse",
                            8u32,
                            "SubscriberCreated",
                            0 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "subscriber_id",
                            subscriber_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseResponse::MessageReceived {
                        ref subscriber_id,
                        ref topic,
                        ref payload,
                    } => {
                        let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                            __serializer,
                            "DatabaseResponse",
                            9u32,
                            "MessageReceived",
                            0 + 1 + 1 + 1,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "subscriber_id",
                            subscriber_id,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "topic",
                            topic,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        match _serde::ser::SerializeStructVariant::serialize_field(
                            &mut __serde_state,
                            "payload",
                            payload,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        };
                        _serde::ser::SerializeStructVariant::end(__serde_state)
                    }
                    DatabaseResponse::KvOutput(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "DatabaseResponse",
                            10u32,
                            "KvOutput",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for DatabaseResponse {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                    __field10,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            3u64 => _serde::__private::Ok(__Field::__field3),
                            4u64 => _serde::__private::Ok(__Field::__field4),
                            5u64 => _serde::__private::Ok(__Field::__field5),
                            6u64 => _serde::__private::Ok(__Field::__field6),
                            7u64 => _serde::__private::Ok(__Field::__field7),
                            8u64 => _serde::__private::Ok(__Field::__field8),
                            9u64 => _serde::__private::Ok(__Field::__field9),
                            10u64 => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 11",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Documents" => _serde::__private::Ok(__Field::__field0),
                            "TransactionResults" => _serde::__private::Ok(__Field::__field1),
                            "ViewMappings" => _serde::__private::Ok(__Field::__field2),
                            "ViewMappingsWithDocs" => _serde::__private::Ok(__Field::__field3),
                            "ViewReduction" => _serde::__private::Ok(__Field::__field4),
                            "ViewGroupedReduction" => _serde::__private::Ok(__Field::__field5),
                            "ExecutedTransactions" => _serde::__private::Ok(__Field::__field6),
                            "LastTransactionId" => _serde::__private::Ok(__Field::__field7),
                            "SubscriberCreated" => _serde::__private::Ok(__Field::__field8),
                            "MessageReceived" => _serde::__private::Ok(__Field::__field9),
                            "KvOutput" => _serde::__private::Ok(__Field::__field10),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Documents" => _serde::__private::Ok(__Field::__field0),
                            b"TransactionResults" => _serde::__private::Ok(__Field::__field1),
                            b"ViewMappings" => _serde::__private::Ok(__Field::__field2),
                            b"ViewMappingsWithDocs" => _serde::__private::Ok(__Field::__field3),
                            b"ViewReduction" => _serde::__private::Ok(__Field::__field4),
                            b"ViewGroupedReduction" => _serde::__private::Ok(__Field::__field5),
                            b"ExecutedTransactions" => _serde::__private::Ok(__Field::__field6),
                            b"LastTransactionId" => _serde::__private::Ok(__Field::__field7),
                            b"SubscriberCreated" => _serde::__private::Ok(__Field::__field8),
                            b"MessageReceived" => _serde::__private::Ok(__Field::__field9),
                            b"KvOutput" => _serde::__private::Ok(__Field::__field10),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<DatabaseResponse>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = DatabaseResponse;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "enum DatabaseResponse",
                        )
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<Document<'static>>>(
                                    __variant,
                                ),
                                DatabaseResponse::Documents,
                            ),
                            (__Field::__field1, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<OperationResult>>(
                                    __variant,
                                ),
                                DatabaseResponse::TransactionResults,
                            ),
                            (__Field::__field2, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<map::Serialized>>(
                                    __variant,
                                ),
                                DatabaseResponse::ViewMappings,
                            ),
                            (__Field::__field3, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<MappedDocument>>(
                                    __variant,
                                ),
                                DatabaseResponse::ViewMappingsWithDocs,
                            ),
                            (__Field::__field4, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<u8>>(__variant),
                                DatabaseResponse::ViewReduction,
                            ),
                            (__Field::__field5, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<
                                    Vec<MappedValue<Vec<u8>, Vec<u8>>>,
                                >(__variant),
                                DatabaseResponse::ViewGroupedReduction,
                            ),
                            (__Field::__field6, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Vec<Executed<'static>>>(
                                    __variant,
                                ),
                                DatabaseResponse::ExecutedTransactions,
                            ),
                            (__Field::__field7, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Option<u64>>(
                                    __variant,
                                ),
                                DatabaseResponse::LastTransactionId,
                            ),
                            (__Field::__field8, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseResponse>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseResponse;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseResponse::SubscriberCreated",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseResponse::SubscriberCreated with 1 element")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseResponse::SubscriberCreated {
                                            subscriber_id: __field0,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("subscriber_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "subscriber_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseResponse::SubscriberCreated {
                                            subscriber_id: __field0,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] = &["subscriber_id"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseResponse>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field9, __variant) => {
                                #[allow(non_camel_case_types)]
                                enum __Field {
                                    __field0,
                                    __field1,
                                    __field2,
                                    __ignore,
                                }
                                struct __FieldVisitor;
                                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                    type Value = __Field;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "field identifier",
                                        )
                                    }
                                    fn visit_u64<__E>(
                                        self,
                                        __value: u64,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            0u64 => _serde::__private::Ok(__Field::__field0),
                                            1u64 => _serde::__private::Ok(__Field::__field1),
                                            2u64 => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_str<__E>(
                                        self,
                                        __value: &str,
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            "subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            "topic" => _serde::__private::Ok(__Field::__field1),
                                            "payload" => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                    fn visit_bytes<__E>(
                                        self,
                                        __value: &[u8],
                                    ) -> _serde::__private::Result<Self::Value, __E>
                                    where
                                        __E: _serde::de::Error,
                                    {
                                        match __value {
                                            b"subscriber_id" => {
                                                _serde::__private::Ok(__Field::__field0)
                                            }
                                            b"topic" => _serde::__private::Ok(__Field::__field1),
                                            b"payload" => _serde::__private::Ok(__Field::__field2),
                                            _ => _serde::__private::Ok(__Field::__ignore),
                                        }
                                    }
                                }
                                impl<'de> _serde::Deserialize<'de> for __Field {
                                    #[inline]
                                    fn deserialize<__D>(
                                        __deserializer: __D,
                                    ) -> _serde::__private::Result<Self, __D::Error>
                                    where
                                        __D: _serde::Deserializer<'de>,
                                    {
                                        _serde::Deserializer::deserialize_identifier(
                                            __deserializer,
                                            __FieldVisitor,
                                        )
                                    }
                                }
                                struct __Visitor<'de> {
                                    marker: _serde::__private::PhantomData<DatabaseResponse>,
                                    lifetime: _serde::__private::PhantomData<&'de ()>,
                                }
                                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                    type Value = DatabaseResponse;
                                    fn expecting(
                                        &self,
                                        __formatter: &mut _serde::__private::Formatter,
                                    ) -> _serde::__private::fmt::Result
                                    {
                                        _serde::__private::Formatter::write_str(
                                            __formatter,
                                            "struct variant DatabaseResponse::MessageReceived",
                                        )
                                    }
                                    #[inline]
                                    fn visit_seq<__A>(
                                        self,
                                        mut __seq: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::SeqAccess<'de>,
                                    {
                                        let __field0 =
                                            match match _serde::de::SeqAccess::next_element::<u64>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant DatabaseResponse::MessageReceived with 3 elements")) ;
                                                }
                                            };
                                        let __field1 =
                                            match match _serde::de::SeqAccess::next_element::<String>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant DatabaseResponse::MessageReceived with 3 elements")) ;
                                                }
                                            };
                                        let __field2 =
                                            match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                                                &mut __seq,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            } {
                                                _serde::__private::Some(__value) => __value,
                                                _serde::__private::None => {
                                                    return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant DatabaseResponse::MessageReceived with 3 elements")) ;
                                                }
                                            };
                                        _serde::__private::Ok(DatabaseResponse::MessageReceived {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                            payload: __field2,
                                        })
                                    }
                                    #[inline]
                                    fn visit_map<__A>(
                                        self,
                                        mut __map: __A,
                                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                                    where
                                        __A: _serde::de::MapAccess<'de>,
                                    {
                                        let mut __field0: _serde::__private::Option<u64> =
                                            _serde::__private::None;
                                        let mut __field1: _serde::__private::Option<String> =
                                            _serde::__private::None;
                                        let mut __field2: _serde::__private::Option<Vec<u8>> =
                                            _serde::__private::None;
                                        while let _serde::__private::Some(__key) =
                                            match _serde::de::MapAccess::next_key::<__Field>(
                                                &mut __map,
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        {
                                            match __key {
                                                __Field::__field0 => {
                                                    if _serde::__private::Option::is_some(&__field0)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("subscriber_id")) ;
                                                    }
                                                    __field0 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<u64>(
                                                            &mut __map,
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field1 => {
                                                    if _serde::__private::Option::is_some(&__field1)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("topic")) ;
                                                    }
                                                    __field1 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            String,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                __Field::__field2 => {
                                                    if _serde::__private::Option::is_some(&__field2)
                                                    {
                                                        return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("payload")) ;
                                                    }
                                                    __field2 = _serde::__private::Some(
                                                        match _serde::de::MapAccess::next_value::<
                                                            Vec<u8>,
                                                        >(
                                                            &mut __map
                                                        ) {
                                                            _serde::__private::Ok(__val) => __val,
                                                            _serde::__private::Err(__err) => {
                                                                return _serde::__private::Err(
                                                                    __err,
                                                                );
                                                            }
                                                        },
                                                    );
                                                }
                                                _ => {
                                                    let _ = match _serde::de::MapAccess::next_value::<
                                                        _serde::de::IgnoredAny,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    };
                                                }
                                            }
                                        }
                                        let __field0 = match __field0 {
                                            _serde::__private::Some(__field0) => __field0,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "subscriber_id",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field1 = match __field1 {
                                            _serde::__private::Some(__field1) => __field1,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field("topic")
                                                {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        let __field2 = match __field2 {
                                            _serde::__private::Some(__field2) => __field2,
                                            _serde::__private::None => {
                                                match _serde::__private::de::missing_field(
                                                    "payload",
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                }
                                            }
                                        };
                                        _serde::__private::Ok(DatabaseResponse::MessageReceived {
                                            subscriber_id: __field0,
                                            topic: __field1,
                                            payload: __field2,
                                        })
                                    }
                                }
                                const FIELDS: &'static [&'static str] =
                                    &["subscriber_id", "topic", "payload"];
                                _serde::de::VariantAccess::struct_variant(
                                    __variant,
                                    FIELDS,
                                    __Visitor {
                                        marker: _serde::__private::PhantomData::<DatabaseResponse>,
                                        lifetime: _serde::__private::PhantomData,
                                    },
                                )
                            }
                            (__Field::__field10, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<Output>(__variant),
                                DatabaseResponse::KvOutput,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Documents",
                    "TransactionResults",
                    "ViewMappings",
                    "ViewMappingsWithDocs",
                    "ViewReduction",
                    "ViewGroupedReduction",
                    "ExecutedTransactions",
                    "LastTransactionId",
                    "SubscriberCreated",
                    "MessageReceived",
                    "KvOutput",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "DatabaseResponse",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<DatabaseResponse>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for DatabaseResponse {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&DatabaseResponse::Documents(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Documents");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::TransactionResults(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "TransactionResults");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::ViewMappings(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewMappings");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::ViewMappingsWithDocs(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewMappingsWithDocs");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::ViewReduction(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewReduction");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::ViewGroupedReduction(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewGroupedReduction");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::ExecutedTransactions(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ExecutedTransactions");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::LastTransactionId(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "LastTransactionId");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&DatabaseResponse::SubscriberCreated {
                    subscriber_id: ref __self_0,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "SubscriberCreated");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subscriber_id",
                        &&(*__self_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseResponse::MessageReceived {
                    subscriber_id: ref __self_0,
                    topic: ref __self_1,
                    payload: ref __self_2,
                },) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "MessageReceived");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "subscriber_id",
                        &&(*__self_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "topic",
                        &&(*__self_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "payload",
                        &&(*__self_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
                (&DatabaseResponse::KvOutput(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "KvOutput");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    /// A serialized [`MappedDocument`](map::MappedDocument).
    pub struct MappedDocument {
        /// The serialized key.
        pub key: Vec<u8>,
        /// The serialized value.
        pub value: Vec<u8>,
        /// The source document.
        pub source: Document<'static>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for MappedDocument {
        #[inline]
        fn clone(&self) -> MappedDocument {
            match *self {
                MappedDocument {
                    key: ref __self_0_0,
                    value: ref __self_0_1,
                    source: ref __self_0_2,
                } => MappedDocument {
                    key: ::core::clone::Clone::clone(&(*__self_0_0)),
                    value: ::core::clone::Clone::clone(&(*__self_0_1)),
                    source: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for MappedDocument {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "MappedDocument",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "key",
                    &self.key,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "source",
                    &self.source,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for MappedDocument {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "key" => _serde::__private::Ok(__Field::__field0),
                            "value" => _serde::__private::Ok(__Field::__field1),
                            "source" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"key" => _serde::__private::Ok(__Field::__field0),
                            b"value" => _serde::__private::Ok(__Field::__field1),
                            b"source" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<MappedDocument>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = MappedDocument;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(
                            __formatter,
                            "struct MappedDocument",
                        )
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 = match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct MappedDocument with 3 elements",
                                ));
                            }
                        };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<Vec<u8>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct MappedDocument with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<
                            Document<'static>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct MappedDocument with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(MappedDocument {
                            key: __field0,
                            value: __field1,
                            source: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<Vec<u8>> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Vec<u8>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Document<'static>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "key",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<u8>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<u8>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "source",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Document<'static>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("key") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("value") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("source") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(MappedDocument {
                            key: __field0,
                            value: __field1,
                            source: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["key", "value", "source"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "MappedDocument",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<MappedDocument>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for MappedDocument {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                MappedDocument {
                    key: ref __self_0_0,
                    value: ref __self_0_1,
                    source: ref __self_0_2,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "MappedDocument");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "key",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "source",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl MappedDocument {
        /// Deserialize into a [`MappedDocument`](map::MappedDocument).
        pub fn deserialized<K: Key, V: Serialize + DeserializeOwned>(
            self,
        ) -> Result<map::MappedDocument<K, V>, crate::Error> {
            let key = Key::from_big_endian_bytes(&self.key).map_err(|err| {
                crate::Error::Database(view::Error::KeySerialization(err).to_string())
            })?;
            let value = serde_cbor::from_slice(&self.value)
                .map_err(|err| crate::Error::Database(view::Error::from(err).to_string()))?;
            Ok(map::MappedDocument {
                document: self.source,
                key,
                value,
            })
        }
    }
    /// A networking error.
    pub enum Error {
        /// The server responded with a message that wasn't expected for the request
        /// sent.
        #[error("unexpected response: {0}")]
        UnexpectedResponse(String),
        /// The connection was interrupted.
        #[error("unexpected disconnection")]
        Disconnected,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Error {
        #[inline]
        fn clone(&self) -> Error {
            match (&*self,) {
                (&Error::UnexpectedResponse(ref __self_0),) => {
                    Error::UnexpectedResponse(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Error::Disconnected,) => Error::Disconnected,
            }
        }
    }
    #[allow(unused_qualifications)]
    impl std::error::Error for Error {}
    #[allow(unused_qualifications)]
    impl std::fmt::Display for Error {
        fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            #[allow(unused_imports)]
            use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
            #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
            match self {
                Error::UnexpectedResponse(_0) => {
                    __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                        &["unexpected response: "],
                        &match (&_0.as_display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
                Error::Disconnected {} => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["unexpected disconnection"],
                    &match () {
                        () => [],
                    },
                )),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Error {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Error::UnexpectedResponse(ref __self_0),) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UnexpectedResponse");
                    let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&Error::Disconnected,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Disconnected");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Error {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Error::UnexpectedResponse(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Error",
                            0u32,
                            "UnexpectedResponse",
                            __field0,
                        )
                    }
                    Error::Disconnected => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Error",
                        1u32,
                        "Disconnected",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Error {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UnexpectedResponse" => _serde::__private::Ok(__Field::__field0),
                            "Disconnected" => _serde::__private::Ok(__Field::__field1),
                            _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UnexpectedResponse" => _serde::__private::Ok(__Field::__field0),
                            b"Disconnected" => _serde::__private::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::__private::from_utf8_lossy(__value);
                                _serde::__private::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Error>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Error;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "enum Error")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::__private::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                                Error::UnexpectedResponse,
                            ),
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                };
                                _serde::__private::Ok(Error::Disconnected)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["UnexpectedResponse", "Disconnected"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Error",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Error>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
}
#[cfg(feature = "pubsub")]
/// Types for Publish/Subscribe (`PubSub`) messaging.
pub mod pubsub {
    use std::sync::Arc;
    use async_trait::async_trait;
    use circulate::{flume, Message, Relay};
    use serde::Serialize;
    use crate::Error;
    /// Publishes and Subscribes to messages on topics.
    pub trait PubSub {
        /// The Subscriber type for this `PubSub` connection.
        type Subscriber: Subscriber;
        /// Create a new [`Subscriber`] for this relay.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn create_subscriber<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Subscriber, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Publishes a `payload` to all subscribers of `topic`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn publish<'life0, 'life1, 'async_trait, S: Into<String> + Send, P: Serialize + Sync>(
            &'life0 self,
            topic: S,
            payload: &'life1 P,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            S: 'async_trait,
            P: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Publishes a `payload` to all subscribers of all `topics`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn publish_to_all<'life0, 'life1, 'async_trait, P: Serialize + Sync>(
            &'life0 self,
            topics: Vec<String>,
            payload: &'life1 P,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            P: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
    }
    /// A subscriber to one or more topics.
    pub trait Subscriber {
        /// Subscribe to [`Message`]s published to `topic`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn subscribe_to<'life0, 'async_trait, S: Into<String> + Send>(
            &'life0 self,
            topic: S,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            S: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait;
        /// Unsubscribe from [`Message`]s published to `topic`.
        #[must_use]
        #[allow(clippy::type_complexity, clippy::type_repetition_in_bounds)]
        fn unsubscribe_from<'life0, 'life1, 'async_trait>(
            &'life0 self,
            topic: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait;
        /// Returns the receiver to receive [`Message`]s.
        #[must_use]
        fn receiver(&self) -> &'_ flume::Receiver<Arc<Message>>;
    }
    impl PubSub for Relay {
        type Subscriber = circulate::Subscriber;
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn create_subscriber<'life0, 'async_trait>(
            &'life0 self,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<Self::Subscriber, Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<Self::Subscriber, Error>>
                {
                    return __ret;
                }
                let __self = self;
                let __ret: Result<Self::Subscriber, Error> =
                    { Ok(__self.create_subscriber().await) };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn publish<'life0, 'life1, 'async_trait, S: Into<String> + Send, P: Serialize + Sync>(
            &'life0 self,
            topic: S,
            payload: &'life1 P,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            S: 'async_trait,
            P: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let topic = topic;
                let payload = payload;
                let __ret: Result<(), Error> = {
                    __self.publish(topic, payload).await?;
                    Ok(())
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn publish_to_all<'life0, 'life1, 'async_trait, P: Serialize + Sync>(
            &'life0 self,
            topics: Vec<String>,
            payload: &'life1 P,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            P: 'async_trait,
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let topics = topics;
                let payload = payload;
                let __ret: Result<(), Error> = {
                    __self.publish_to_all(topics, payload).await?;
                    Ok(())
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
    }
    impl Subscriber for circulate::Subscriber {
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn subscribe_to<'life0, 'async_trait, S: Into<String> + Send>(
            &'life0 self,
            topic: S,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            S: 'async_trait,
            'life0: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let topic = topic;
                let __ret: Result<(), Error> = {
                    __self.subscribe_to(topic).await;
                    Ok(())
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        #[allow(
            clippy::let_unit_value,
            clippy::type_complexity,
            clippy::type_repetition_in_bounds,
            clippy::used_underscore_binding
        )]
        fn unsubscribe_from<'life0, 'life1, 'async_trait>(
            &'life0 self,
            topic: &'life1 str,
        ) -> ::core::pin::Pin<
            Box<
                dyn ::core::future::Future<Output = Result<(), Error>>
                    + ::core::marker::Send
                    + 'async_trait,
            >,
        >
        where
            'life0: 'async_trait,
            'life1: 'async_trait,
            Self: 'async_trait,
        {
            Box::pin(async move {
                if let ::core::option::Option::Some(__ret) =
                    ::core::option::Option::None::<Result<(), Error>>
                {
                    return __ret;
                }
                let __self = self;
                let topic = topic;
                let __ret: Result<(), Error> = {
                    __self.unsubscribe_from(topic).await;
                    Ok(())
                };
                #[allow(unreachable_code)]
                __ret
            })
        }
        fn receiver(&self) -> &'_ flume::Receiver<Arc<Message>> {
            self.receiver()
        }
    }
    /// Creates a topic for use in a server. This is an internal API, which is why
    /// the documentation is hidden. This is an implementation detail, but both
    /// Client and Server must agree on this format, which is why it lives in core.
    #[doc(hidden)]
    #[must_use]
    pub fn database_topic(database: &str, topic: &str) -> String {
        {
            let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                &["", "\u{0}"],
                &match (&database, &topic) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                    ],
                },
            ));
            res
        }
    }
}
#[cfg(feature = "pubsub")]
pub use circulate;
use schema::{CollectionName, SchemaName, ViewName};
use serde::{Deserialize, Serialize};
/// an enumeration of errors that this crate can produce
pub enum Error {
    /// The database named `database_name` was created with a different schema
    /// (`stored_schema`) than provided (`schema`).
    #[error(
        "database '{database_name}' was created with schema '{stored_schema}', not '{schema}'"
    )]
    SchemaMismatch {
        /// The name of the database being accessed.
        database_name: String,
        /// The schema provided for the database.
        schema: SchemaName,
        /// The schema stored for the database.
        stored_schema: SchemaName,
    },
    /// The [`SchemaName`] returned has already been registered with this server.
    #[error("schema '{0}' was already registered")]
    SchemaAlreadyRegistered(SchemaName),
    /// The [`SchemaName`] requested was not registered with this server.
    #[error("schema '{0}' is not registered with this server")]
    SchemaNotRegistered(SchemaName),
    /// An invalid database name was specified. See
    /// [`ServerConnection::create_database()`](connection::ServerConnection::create_database)
    /// for database name requirements.
    #[error("invalid database name: {0}")]
    InvalidDatabaseName(String),
    /// The database name given was not found.
    #[error("database '{0}' was not found")]
    DatabaseNotFound(String),
    /// The database name already exists.
    #[error("a database with name '{0}' already exists")]
    DatabaseNameAlreadyTaken(String),
    /// An error from interacting with local storage.
    #[error("error from storage: {0}")]
    Database(String),
    /// An error from interacting with a server.
    #[error("error from server: {0}")]
    Server(String),
    /// An error occurred from the QUIC transport layer.
    #[error("a transport error occurred: '{0}'")]
    Transport(String),
    /// An error occurred from the websocket transport layer.
    #[cfg(feature = "websockets")]
    #[error("a websocket error occurred: '{0}'")]
    Websocket(String),
    /// An error occurred from networking.
    #[cfg(feature = "networking")]
    #[error("a networking error occurred: '{0}'")]
    Networking(networking::Error),
    /// An error occurred from IO.
    #[error("an io error occurred: '{0}'")]
    Io(String),
    /// An error occurred with the provided configuration options.
    #[error("a configuration error occurred: '{0}'")]
    Configuration(String),
    /// An error occurred inside of the client.
    #[error("an io error in the client: '{0}'")]
    Client(String),
    /// An attempt to use a `Collection` with a `Database` that it wasn't defined within.
    #[error("attempted to access a collection not registered with this schema")]
    CollectionNotFound,
    /// An attempt to update a document that doesn't exist.
    #[error("the requested document id {1} from collection {0} was not found")]
    DocumentNotFound(CollectionName, u64),
    /// When updating a document, if a situation is detected where the contents have changed on the server since the `Revision` provided, a Conflict error will be returned.
    #[error("a conflict was detected while updating document id {1} from collection {0}")]
    DocumentConflict(CollectionName, u64),
    /// When saving a document in a collection with unique views, a document emits a key that is already emitted by an existing ocument, this error is returned.
    # [error ("a unique key violation occurred: document `{existing_document_id}` already has the same key as `{conflicting_document_id}` for {view}")]
    UniqueKeyViolation {
        /// The name of the view that the unique key violation occurred.
        view: ViewName,
        /// The document that caused the violation.
        conflicting_document_id: u64,
        /// The document that already uses the same key.
        existing_document_id: u64,
    },
    /// An invalid name was specified during schema creation.
    #[error("an invalid name was used in a schema: {0}")]
    InvalidName(#[from] schema::InvalidNameError),
    /// Permission was denied.
    #[error("permission error: {0}")]
    PermissionDenied(#[from] actionable::PermissionDenied),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for Error {
    #[inline]
    fn clone(&self) -> Error {
        match (&*self,) {
            (&Error::SchemaMismatch {
                database_name: ref __self_0,
                schema: ref __self_1,
                stored_schema: ref __self_2,
            },) => Error::SchemaMismatch {
                database_name: ::core::clone::Clone::clone(&(*__self_0)),
                schema: ::core::clone::Clone::clone(&(*__self_1)),
                stored_schema: ::core::clone::Clone::clone(&(*__self_2)),
            },
            (&Error::SchemaAlreadyRegistered(ref __self_0),) => {
                Error::SchemaAlreadyRegistered(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::SchemaNotRegistered(ref __self_0),) => {
                Error::SchemaNotRegistered(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::InvalidDatabaseName(ref __self_0),) => {
                Error::InvalidDatabaseName(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::DatabaseNotFound(ref __self_0),) => {
                Error::DatabaseNotFound(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::DatabaseNameAlreadyTaken(ref __self_0),) => {
                Error::DatabaseNameAlreadyTaken(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Database(ref __self_0),) => {
                Error::Database(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Server(ref __self_0),) => {
                Error::Server(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Transport(ref __self_0),) => {
                Error::Transport(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Websocket(ref __self_0),) => {
                Error::Websocket(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Networking(ref __self_0),) => {
                Error::Networking(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Io(ref __self_0),) => Error::Io(::core::clone::Clone::clone(&(*__self_0))),
            (&Error::Configuration(ref __self_0),) => {
                Error::Configuration(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::Client(ref __self_0),) => {
                Error::Client(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::CollectionNotFound,) => Error::CollectionNotFound,
            (&Error::DocumentNotFound(ref __self_0, ref __self_1),) => Error::DocumentNotFound(
                ::core::clone::Clone::clone(&(*__self_0)),
                ::core::clone::Clone::clone(&(*__self_1)),
            ),
            (&Error::DocumentConflict(ref __self_0, ref __self_1),) => Error::DocumentConflict(
                ::core::clone::Clone::clone(&(*__self_0)),
                ::core::clone::Clone::clone(&(*__self_1)),
            ),
            (&Error::UniqueKeyViolation {
                view: ref __self_0,
                conflicting_document_id: ref __self_1,
                existing_document_id: ref __self_2,
            },) => Error::UniqueKeyViolation {
                view: ::core::clone::Clone::clone(&(*__self_0)),
                conflicting_document_id: ::core::clone::Clone::clone(&(*__self_1)),
                existing_document_id: ::core::clone::Clone::clone(&(*__self_2)),
            },
            (&Error::InvalidName(ref __self_0),) => {
                Error::InvalidName(::core::clone::Clone::clone(&(*__self_0)))
            }
            (&Error::PermissionDenied(ref __self_0),) => {
                Error::PermissionDenied(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
#[allow(unused_qualifications)]
impl std::error::Error for Error {
    fn source(&self) -> std::option::Option<&(dyn std::error::Error + 'static)> {
        use thiserror::private::AsDynError;
        #[allow(deprecated)]
        match self {
            Error::SchemaMismatch { .. } => std::option::Option::None,
            Error::SchemaAlreadyRegistered { .. } => std::option::Option::None,
            Error::SchemaNotRegistered { .. } => std::option::Option::None,
            Error::InvalidDatabaseName { .. } => std::option::Option::None,
            Error::DatabaseNotFound { .. } => std::option::Option::None,
            Error::DatabaseNameAlreadyTaken { .. } => std::option::Option::None,
            Error::Database { .. } => std::option::Option::None,
            Error::Server { .. } => std::option::Option::None,
            Error::Transport { .. } => std::option::Option::None,
            Error::Websocket { .. } => std::option::Option::None,
            Error::Networking { .. } => std::option::Option::None,
            Error::Io { .. } => std::option::Option::None,
            Error::Configuration { .. } => std::option::Option::None,
            Error::Client { .. } => std::option::Option::None,
            Error::CollectionNotFound { .. } => std::option::Option::None,
            Error::DocumentNotFound { .. } => std::option::Option::None,
            Error::DocumentConflict { .. } => std::option::Option::None,
            Error::UniqueKeyViolation { .. } => std::option::Option::None,
            Error::InvalidName { 0: source, .. } => {
                std::option::Option::Some(source.as_dyn_error())
            }
            Error::PermissionDenied { 0: source, .. } => {
                std::option::Option::Some(source.as_dyn_error())
            }
        }
    }
}
#[allow(unused_qualifications)]
impl std::fmt::Display for Error {
    fn fmt(&self, __formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
        #[allow(unused_imports)]
        use thiserror::private::{DisplayAsDisplay, PathAsDisplay};
        #[allow(unused_variables, deprecated, clippy::used_underscore_binding)]
        match self {
            Error::SchemaMismatch {
                database_name,
                schema,
                stored_schema,
            } => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &[
                    "database \'",
                    "\' was created with schema \'",
                    "\', not \'",
                    "\'",
                ],
                &match (
                    &database_name.as_display(),
                    &stored_schema.as_display(),
                    &schema.as_display(),
                ) {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            )),
            Error::SchemaAlreadyRegistered(_0) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["schema \'", "\' was already registered"],
                    &match (&_0.as_display(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
            Error::SchemaNotRegistered(_0) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["schema \'", "\' is not registered with this server"],
                    &match (&_0.as_display(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
            Error::InvalidDatabaseName(_0) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["invalid database name: "],
                    &match (&_0.as_display(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
            Error::DatabaseNotFound(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["database \'", "\' was not found"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::DatabaseNameAlreadyTaken(_0) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &["a database with name \'", "\' already exists"],
                    &match (&_0.as_display(),) {
                        (arg0,) => [::core::fmt::ArgumentV1::new(
                            arg0,
                            ::core::fmt::Display::fmt,
                        )],
                    },
                ))
            }
            Error::Database(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["error from storage: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Server(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["error from server: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Transport(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["a transport error occurred: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Websocket(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["a websocket error occurred: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Networking(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["a networking error occurred: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Io(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["an io error occurred: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Configuration(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["a configuration error occurred: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::Client(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["an io error in the client: \'", "\'"],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::CollectionNotFound {} => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["attempted to access a collection not registered with this schema"],
                &match () {
                    () => [],
                },
            )),
            Error::DocumentNotFound(_0, _1) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &[
                        "the requested document id ",
                        " from collection ",
                        " was not found",
                    ],
                    &match (&_1.as_display(), &_0.as_display()) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ))
            }
            Error::DocumentConflict(_0, _1) => {
                __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                    &[
                        "a conflict was detected while updating document id ",
                        " from collection ",
                    ],
                    &match (&_1.as_display(), &_0.as_display()) {
                        (arg0, arg1) => [
                            ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                            ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ],
                    },
                ))
            }
            Error::UniqueKeyViolation {
                view,
                conflicting_document_id,
                existing_document_id,
            } => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &[
                    "a unique key violation occurred: document `",
                    "` already has the same key as `",
                    "` for ",
                ],
                &match (
                    &existing_document_id.as_display(),
                    &conflicting_document_id.as_display(),
                    &view.as_display(),
                ) {
                    (arg0, arg1, arg2) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                    ],
                },
            )),
            Error::InvalidName(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["an invalid name was used in a schema: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
            Error::PermissionDenied(_0) => __formatter.write_fmt(::core::fmt::Arguments::new_v1(
                &["permission error: "],
                &match (&_0.as_display(),) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            )),
        }
    }
}
#[allow(unused_qualifications)]
impl std::convert::From<schema::InvalidNameError> for Error {
    #[allow(deprecated)]
    fn from(source: schema::InvalidNameError) -> Self {
        Error::InvalidName { 0: source }
    }
}
#[allow(unused_qualifications)]
impl std::convert::From<actionable::PermissionDenied> for Error {
    #[allow(deprecated)]
    fn from(source: actionable::PermissionDenied) -> Self {
        Error::PermissionDenied { 0: source }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for Error {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&Error::SchemaMismatch {
                database_name: ref __self_0,
                schema: ref __self_1,
                stored_schema: ref __self_2,
            },) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "SchemaMismatch");
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "database_name",
                    &&(*__self_0),
                );
                let _ =
                    ::core::fmt::DebugStruct::field(debug_trait_builder, "schema", &&(*__self_1));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "stored_schema",
                    &&(*__self_2),
                );
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
            (&Error::SchemaAlreadyRegistered(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "SchemaAlreadyRegistered");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::SchemaNotRegistered(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "SchemaNotRegistered");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::InvalidDatabaseName(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidDatabaseName");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::DatabaseNotFound(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "DatabaseNotFound");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::DatabaseNameAlreadyTaken(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "DatabaseNameAlreadyTaken");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Database(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Database");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Server(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Server");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Transport(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Transport");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Websocket(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Websocket");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Networking(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Networking");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Io(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Io");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Configuration(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "Configuration");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::Client(ref __self_0),) => {
                let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "Client");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::CollectionNotFound,) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "CollectionNotFound");
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::DocumentNotFound(ref __self_0, ref __self_1),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "DocumentNotFound");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_1));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::DocumentConflict(ref __self_0, ref __self_1),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "DocumentConflict");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_1));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::UniqueKeyViolation {
                view: ref __self_0,
                conflicting_document_id: ref __self_1,
                existing_document_id: ref __self_2,
            },) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_struct(f, "UniqueKeyViolation");
                let _ = ::core::fmt::DebugStruct::field(debug_trait_builder, "view", &&(*__self_0));
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "conflicting_document_id",
                    &&(*__self_1),
                );
                let _ = ::core::fmt::DebugStruct::field(
                    debug_trait_builder,
                    "existing_document_id",
                    &&(*__self_2),
                );
                ::core::fmt::DebugStruct::finish(debug_trait_builder)
            }
            (&Error::InvalidName(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "InvalidName");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
            (&Error::PermissionDenied(ref __self_0),) => {
                let debug_trait_builder =
                    &mut ::core::fmt::Formatter::debug_tuple(f, "PermissionDenied");
                let _ = ::core::fmt::DebugTuple::field(debug_trait_builder, &&(*__self_0));
                ::core::fmt::DebugTuple::finish(debug_trait_builder)
            }
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for Error {
        fn serialize<__S>(
            &self,
            __serializer: __S,
        ) -> _serde::__private::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                Error::SchemaMismatch {
                    ref database_name,
                    ref schema,
                    ref stored_schema,
                } => {
                    let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "Error",
                        0u32,
                        "SchemaMismatch",
                        0 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "database_name",
                        database_name,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "schema",
                        schema,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "stored_schema",
                        stored_schema,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                Error::SchemaAlreadyRegistered(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        1u32,
                        "SchemaAlreadyRegistered",
                        __field0,
                    )
                }
                Error::SchemaNotRegistered(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        2u32,
                        "SchemaNotRegistered",
                        __field0,
                    )
                }
                Error::InvalidDatabaseName(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        3u32,
                        "InvalidDatabaseName",
                        __field0,
                    )
                }
                Error::DatabaseNotFound(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        4u32,
                        "DatabaseNotFound",
                        __field0,
                    )
                }
                Error::DatabaseNameAlreadyTaken(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        5u32,
                        "DatabaseNameAlreadyTaken",
                        __field0,
                    )
                }
                Error::Database(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    6u32,
                    "Database",
                    __field0,
                ),
                Error::Server(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    7u32,
                    "Server",
                    __field0,
                ),
                Error::Transport(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    8u32,
                    "Transport",
                    __field0,
                ),
                Error::Websocket(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    9u32,
                    "Websocket",
                    __field0,
                ),
                Error::Networking(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    10u32,
                    "Networking",
                    __field0,
                ),
                Error::Io(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    11u32,
                    "Io",
                    __field0,
                ),
                Error::Configuration(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        12u32,
                        "Configuration",
                        __field0,
                    )
                }
                Error::Client(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    13u32,
                    "Client",
                    __field0,
                ),
                Error::CollectionNotFound => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "Error",
                    14u32,
                    "CollectionNotFound",
                ),
                Error::DocumentNotFound(ref __field0, ref __field1) => {
                    let mut __serde_state = match _serde::Serializer::serialize_tuple_variant(
                        __serializer,
                        "Error",
                        15u32,
                        "DocumentNotFound",
                        0 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field0,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeTupleVariant::end(__serde_state)
                }
                Error::DocumentConflict(ref __field0, ref __field1) => {
                    let mut __serde_state = match _serde::Serializer::serialize_tuple_variant(
                        __serializer,
                        "Error",
                        16u32,
                        "DocumentConflict",
                        0 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field0,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeTupleVariant::serialize_field(
                        &mut __serde_state,
                        __field1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeTupleVariant::end(__serde_state)
                }
                Error::UniqueKeyViolation {
                    ref view,
                    ref conflicting_document_id,
                    ref existing_document_id,
                } => {
                    let mut __serde_state = match _serde::Serializer::serialize_struct_variant(
                        __serializer,
                        "Error",
                        17u32,
                        "UniqueKeyViolation",
                        0 + 1 + 1 + 1,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "view",
                        view,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "conflicting_document_id",
                        conflicting_document_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStructVariant::serialize_field(
                        &mut __serde_state,
                        "existing_document_id",
                        existing_document_id,
                    ) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStructVariant::end(__serde_state)
                }
                Error::InvalidName(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "Error",
                    18u32,
                    "InvalidName",
                    __field0,
                ),
                Error::PermissionDenied(ref __field0) => {
                    _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Error",
                        19u32,
                        "PermissionDenied",
                        __field0,
                    )
                }
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for Error {
        fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __field7,
                __field8,
                __field9,
                __field10,
                __field11,
                __field12,
                __field13,
                __field14,
                __field15,
                __field16,
                __field17,
                __field18,
                __field19,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::__private::Ok(__Field::__field0),
                        1u64 => _serde::__private::Ok(__Field::__field1),
                        2u64 => _serde::__private::Ok(__Field::__field2),
                        3u64 => _serde::__private::Ok(__Field::__field3),
                        4u64 => _serde::__private::Ok(__Field::__field4),
                        5u64 => _serde::__private::Ok(__Field::__field5),
                        6u64 => _serde::__private::Ok(__Field::__field6),
                        7u64 => _serde::__private::Ok(__Field::__field7),
                        8u64 => _serde::__private::Ok(__Field::__field8),
                        9u64 => _serde::__private::Ok(__Field::__field9),
                        10u64 => _serde::__private::Ok(__Field::__field10),
                        11u64 => _serde::__private::Ok(__Field::__field11),
                        12u64 => _serde::__private::Ok(__Field::__field12),
                        13u64 => _serde::__private::Ok(__Field::__field13),
                        14u64 => _serde::__private::Ok(__Field::__field14),
                        15u64 => _serde::__private::Ok(__Field::__field15),
                        16u64 => _serde::__private::Ok(__Field::__field16),
                        17u64 => _serde::__private::Ok(__Field::__field17),
                        18u64 => _serde::__private::Ok(__Field::__field18),
                        19u64 => _serde::__private::Ok(__Field::__field19),
                        _ => _serde::__private::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 20",
                        )),
                    }
                }
                fn visit_str<__E>(
                    self,
                    __value: &str,
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "SchemaMismatch" => _serde::__private::Ok(__Field::__field0),
                        "SchemaAlreadyRegistered" => _serde::__private::Ok(__Field::__field1),
                        "SchemaNotRegistered" => _serde::__private::Ok(__Field::__field2),
                        "InvalidDatabaseName" => _serde::__private::Ok(__Field::__field3),
                        "DatabaseNotFound" => _serde::__private::Ok(__Field::__field4),
                        "DatabaseNameAlreadyTaken" => _serde::__private::Ok(__Field::__field5),
                        "Database" => _serde::__private::Ok(__Field::__field6),
                        "Server" => _serde::__private::Ok(__Field::__field7),
                        "Transport" => _serde::__private::Ok(__Field::__field8),
                        "Websocket" => _serde::__private::Ok(__Field::__field9),
                        "Networking" => _serde::__private::Ok(__Field::__field10),
                        "Io" => _serde::__private::Ok(__Field::__field11),
                        "Configuration" => _serde::__private::Ok(__Field::__field12),
                        "Client" => _serde::__private::Ok(__Field::__field13),
                        "CollectionNotFound" => _serde::__private::Ok(__Field::__field14),
                        "DocumentNotFound" => _serde::__private::Ok(__Field::__field15),
                        "DocumentConflict" => _serde::__private::Ok(__Field::__field16),
                        "UniqueKeyViolation" => _serde::__private::Ok(__Field::__field17),
                        "InvalidName" => _serde::__private::Ok(__Field::__field18),
                        "PermissionDenied" => _serde::__private::Ok(__Field::__field19),
                        _ => _serde::__private::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::__private::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"SchemaMismatch" => _serde::__private::Ok(__Field::__field0),
                        b"SchemaAlreadyRegistered" => _serde::__private::Ok(__Field::__field1),
                        b"SchemaNotRegistered" => _serde::__private::Ok(__Field::__field2),
                        b"InvalidDatabaseName" => _serde::__private::Ok(__Field::__field3),
                        b"DatabaseNotFound" => _serde::__private::Ok(__Field::__field4),
                        b"DatabaseNameAlreadyTaken" => _serde::__private::Ok(__Field::__field5),
                        b"Database" => _serde::__private::Ok(__Field::__field6),
                        b"Server" => _serde::__private::Ok(__Field::__field7),
                        b"Transport" => _serde::__private::Ok(__Field::__field8),
                        b"Websocket" => _serde::__private::Ok(__Field::__field9),
                        b"Networking" => _serde::__private::Ok(__Field::__field10),
                        b"Io" => _serde::__private::Ok(__Field::__field11),
                        b"Configuration" => _serde::__private::Ok(__Field::__field12),
                        b"Client" => _serde::__private::Ok(__Field::__field13),
                        b"CollectionNotFound" => _serde::__private::Ok(__Field::__field14),
                        b"DocumentNotFound" => _serde::__private::Ok(__Field::__field15),
                        b"DocumentConflict" => _serde::__private::Ok(__Field::__field16),
                        b"UniqueKeyViolation" => _serde::__private::Ok(__Field::__field17),
                        b"InvalidName" => _serde::__private::Ok(__Field::__field18),
                        b"PermissionDenied" => _serde::__private::Ok(__Field::__field19),
                        _ => {
                            let __value = &_serde::__private::from_utf8_lossy(__value);
                            _serde::__private::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(
                    __deserializer: __D,
                ) -> _serde::__private::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::__private::PhantomData<Error>,
                lifetime: _serde::__private::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = Error;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::__private::Formatter,
                ) -> _serde::__private::fmt::Result {
                    _serde::__private::Formatter::write_str(__formatter, "enum Error")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::__private::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::__private::Ok(__val) => __val,
                        _serde::__private::Err(__err) => {
                            return _serde::__private::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            #[allow(non_camel_case_types)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            struct __FieldVisitor;
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "database_name" => _serde::__private::Ok(__Field::__field0),
                                        "schema" => _serde::__private::Ok(__Field::__field1),
                                        "stored_schema" => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"database_name" => {
                                            _serde::__private::Ok(__Field::__field0)
                                        }
                                        b"schema" => _serde::__private::Ok(__Field::__field1),
                                        b"stored_schema" => {
                                            _serde::__private::Ok(__Field::__field2)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Error>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Error;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant Error::SchemaMismatch",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                                        String,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Error::SchemaMismatch with 3 elements")) ;
                                        }
                                    };
                                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                                        SchemaName,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Error::SchemaMismatch with 3 elements")) ;
                                        }
                                    };
                                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                                        SchemaName,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant Error::SchemaMismatch with 3 elements")) ;
                                        }
                                    };
                                    _serde::__private::Ok(Error::SchemaMismatch {
                                        database_name: __field0,
                                        schema: __field1,
                                        stored_schema: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<String> =
                                        _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<SchemaName> =
                                        _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<SchemaName> =
                                        _serde::__private::None;
                                    while let _serde::__private::Some(__key) =
                                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("database_name")) ;
                                                }
                                                __field0 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<String>(
                                                        &mut __map,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("schema")) ;
                                                }
                                                __field1 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<
                                                        SchemaName,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("stored_schema")) ;
                                                }
                                                __field2 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<
                                                        SchemaName,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            _ => {
                                                let _ = match _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                };
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field(
                                                "database_name",
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field("schema") {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field(
                                                "stored_schema",
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    _serde::__private::Ok(Error::SchemaMismatch {
                                        database_name: __field0,
                                        schema: __field1,
                                        stored_schema: __field2,
                                    })
                                }
                            }
                            const FIELDS: &'static [&'static str] =
                                &["database_name", "schema", "stored_schema"];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Error>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field1, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<SchemaName>(__variant),
                            Error::SchemaAlreadyRegistered,
                        ),
                        (__Field::__field2, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<SchemaName>(__variant),
                            Error::SchemaNotRegistered,
                        ),
                        (__Field::__field3, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::InvalidDatabaseName,
                        ),
                        (__Field::__field4, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::DatabaseNotFound,
                        ),
                        (__Field::__field5, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::DatabaseNameAlreadyTaken,
                        ),
                        (__Field::__field6, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Database,
                        ),
                        (__Field::__field7, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Server,
                        ),
                        (__Field::__field8, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Transport,
                        ),
                        (__Field::__field9, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Websocket,
                        ),
                        (__Field::__field10, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<networking::Error>(
                                __variant,
                            ),
                            Error::Networking,
                        ),
                        (__Field::__field11, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Io,
                        ),
                        (__Field::__field12, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Configuration,
                        ),
                        (__Field::__field13, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            Error::Client,
                        ),
                        (__Field::__field14, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            };
                            _serde::__private::Ok(Error::CollectionNotFound)
                        }
                        (__Field::__field15, __variant) => {
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Error>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Error;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "tuple variant Error::DocumentNotFound",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                                        CollectionName,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "tuple variant Error::DocumentNotFound with 2 elements")) ;
                                        }
                                    };
                                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                                        u64,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "tuple variant Error::DocumentNotFound with 2 elements")) ;
                                        }
                                    };
                                    _serde::__private::Ok(Error::DocumentNotFound(
                                        __field0, __field1,
                                    ))
                                }
                            }
                            _serde::de::VariantAccess::tuple_variant(
                                __variant,
                                2usize,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Error>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field16, __variant) => {
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Error>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Error;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "tuple variant Error::DocumentConflict",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                                        CollectionName,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "tuple variant Error::DocumentConflict with 2 elements")) ;
                                        }
                                    };
                                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                                        u64,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "tuple variant Error::DocumentConflict with 2 elements")) ;
                                        }
                                    };
                                    _serde::__private::Ok(Error::DocumentConflict(
                                        __field0, __field1,
                                    ))
                                }
                            }
                            _serde::de::VariantAccess::tuple_variant(
                                __variant,
                                2usize,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Error>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field17, __variant) => {
                            #[allow(non_camel_case_types)]
                            enum __Field {
                                __field0,
                                __field1,
                                __field2,
                                __ignore,
                            }
                            struct __FieldVisitor;
                            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                                type Value = __Field;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "field identifier",
                                    )
                                }
                                fn visit_u64<__E>(
                                    self,
                                    __value: u64,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        0u64 => _serde::__private::Ok(__Field::__field0),
                                        1u64 => _serde::__private::Ok(__Field::__field1),
                                        2u64 => _serde::__private::Ok(__Field::__field2),
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_str<__E>(
                                    self,
                                    __value: &str,
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        "view" => _serde::__private::Ok(__Field::__field0),
                                        "conflicting_document_id" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        "existing_document_id" => {
                                            _serde::__private::Ok(__Field::__field2)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                                fn visit_bytes<__E>(
                                    self,
                                    __value: &[u8],
                                ) -> _serde::__private::Result<Self::Value, __E>
                                where
                                    __E: _serde::de::Error,
                                {
                                    match __value {
                                        b"view" => _serde::__private::Ok(__Field::__field0),
                                        b"conflicting_document_id" => {
                                            _serde::__private::Ok(__Field::__field1)
                                        }
                                        b"existing_document_id" => {
                                            _serde::__private::Ok(__Field::__field2)
                                        }
                                        _ => _serde::__private::Ok(__Field::__ignore),
                                    }
                                }
                            }
                            impl<'de> _serde::Deserialize<'de> for __Field {
                                #[inline]
                                fn deserialize<__D>(
                                    __deserializer: __D,
                                ) -> _serde::__private::Result<Self, __D::Error>
                                where
                                    __D: _serde::Deserializer<'de>,
                                {
                                    _serde::Deserializer::deserialize_identifier(
                                        __deserializer,
                                        __FieldVisitor,
                                    )
                                }
                            }
                            struct __Visitor<'de> {
                                marker: _serde::__private::PhantomData<Error>,
                                lifetime: _serde::__private::PhantomData<&'de ()>,
                            }
                            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                                type Value = Error;
                                fn expecting(
                                    &self,
                                    __formatter: &mut _serde::__private::Formatter,
                                ) -> _serde::__private::fmt::Result
                                {
                                    _serde::__private::Formatter::write_str(
                                        __formatter,
                                        "struct variant Error::UniqueKeyViolation",
                                    )
                                }
                                #[inline]
                                fn visit_seq<__A>(
                                    self,
                                    mut __seq: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::SeqAccess<'de>,
                                {
                                    let __field0 = match match _serde::de::SeqAccess::next_element::<
                                        ViewName,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (0usize , & "struct variant Error::UniqueKeyViolation with 3 elements")) ;
                                        }
                                    };
                                    let __field1 = match match _serde::de::SeqAccess::next_element::<
                                        u64,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (1usize , & "struct variant Error::UniqueKeyViolation with 3 elements")) ;
                                        }
                                    };
                                    let __field2 = match match _serde::de::SeqAccess::next_element::<
                                        u64,
                                    >(
                                        &mut __seq
                                    ) {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    } {
                                        _serde::__private::Some(__value) => __value,
                                        _serde::__private::None => {
                                            return _serde :: __private :: Err (_serde :: de :: Error :: invalid_length (2usize , & "struct variant Error::UniqueKeyViolation with 3 elements")) ;
                                        }
                                    };
                                    _serde::__private::Ok(Error::UniqueKeyViolation {
                                        view: __field0,
                                        conflicting_document_id: __field1,
                                        existing_document_id: __field2,
                                    })
                                }
                                #[inline]
                                fn visit_map<__A>(
                                    self,
                                    mut __map: __A,
                                ) -> _serde::__private::Result<Self::Value, __A::Error>
                                where
                                    __A: _serde::de::MapAccess<'de>,
                                {
                                    let mut __field0: _serde::__private::Option<ViewName> =
                                        _serde::__private::None;
                                    let mut __field1: _serde::__private::Option<u64> =
                                        _serde::__private::None;
                                    let mut __field2: _serde::__private::Option<u64> =
                                        _serde::__private::None;
                                    while let _serde::__private::Some(__key) =
                                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map)
                                        {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        }
                                    {
                                        match __key {
                                            __Field::__field0 => {
                                                if _serde::__private::Option::is_some(&__field0) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("view")) ;
                                                }
                                                __field0 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<
                                                        ViewName,
                                                    >(
                                                        &mut __map
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            __Field::__field1 => {
                                                if _serde::__private::Option::is_some(&__field1) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("conflicting_document_id")) ;
                                                }
                                                __field1 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<u64>(
                                                        &mut __map,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            __Field::__field2 => {
                                                if _serde::__private::Option::is_some(&__field2) {
                                                    return _serde :: __private :: Err (< __A :: Error as _serde :: de :: Error > :: duplicate_field ("existing_document_id")) ;
                                                }
                                                __field2 = _serde::__private::Some(
                                                    match _serde::de::MapAccess::next_value::<u64>(
                                                        &mut __map,
                                                    ) {
                                                        _serde::__private::Ok(__val) => __val,
                                                        _serde::__private::Err(__err) => {
                                                            return _serde::__private::Err(__err);
                                                        }
                                                    },
                                                );
                                            }
                                            _ => {
                                                let _ = match _serde::de::MapAccess::next_value::<
                                                    _serde::de::IgnoredAny,
                                                >(
                                                    &mut __map
                                                ) {
                                                    _serde::__private::Ok(__val) => __val,
                                                    _serde::__private::Err(__err) => {
                                                        return _serde::__private::Err(__err);
                                                    }
                                                };
                                            }
                                        }
                                    }
                                    let __field0 = match __field0 {
                                        _serde::__private::Some(__field0) => __field0,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field("view") {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    let __field1 = match __field1 {
                                        _serde::__private::Some(__field1) => __field1,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field(
                                                "conflicting_document_id",
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    let __field2 = match __field2 {
                                        _serde::__private::Some(__field2) => __field2,
                                        _serde::__private::None => {
                                            match _serde::__private::de::missing_field(
                                                "existing_document_id",
                                            ) {
                                                _serde::__private::Ok(__val) => __val,
                                                _serde::__private::Err(__err) => {
                                                    return _serde::__private::Err(__err);
                                                }
                                            }
                                        }
                                    };
                                    _serde::__private::Ok(Error::UniqueKeyViolation {
                                        view: __field0,
                                        conflicting_document_id: __field1,
                                        existing_document_id: __field2,
                                    })
                                }
                            }
                            const FIELDS: &'static [&'static str] =
                                &["view", "conflicting_document_id", "existing_document_id"];
                            _serde::de::VariantAccess::struct_variant(
                                __variant,
                                FIELDS,
                                __Visitor {
                                    marker: _serde::__private::PhantomData::<Error>,
                                    lifetime: _serde::__private::PhantomData,
                                },
                            )
                        }
                        (__Field::__field18, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<schema::InvalidNameError>(
                                __variant,
                            ),
                            Error::InvalidName,
                        ),
                        (__Field::__field19, __variant) => _serde::__private::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<
                                actionable::PermissionDenied,
                            >(__variant),
                            Error::PermissionDenied,
                        ),
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &[
                "SchemaMismatch",
                "SchemaAlreadyRegistered",
                "SchemaNotRegistered",
                "InvalidDatabaseName",
                "DatabaseNotFound",
                "DatabaseNameAlreadyTaken",
                "Database",
                "Server",
                "Transport",
                "Websocket",
                "Networking",
                "Io",
                "Configuration",
                "Client",
                "CollectionNotFound",
                "DocumentNotFound",
                "DocumentConflict",
                "UniqueKeyViolation",
                "InvalidName",
                "PermissionDenied",
            ];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "Error",
                VARIANTS,
                __Visitor {
                    marker: _serde::__private::PhantomData::<Error>,
                    lifetime: _serde::__private::PhantomData,
                },
            )
        }
    }
};
impl From<serde_cbor::Error> for Error {
    fn from(err: serde_cbor::Error) -> Self {
        Self::Database(err.to_string())
    }
}
/// Shared schemas and utilities used for unit testing.
#[cfg(any(feature = "test-util", test))]
#[allow(missing_docs)]
pub mod test_util {
    #![allow(clippy::missing_panics_doc)]
    use std::{
        borrow::Cow,
        fmt::{Debug, Display},
        io::ErrorKind,
        path::{Path, PathBuf},
        time::{Duration, Instant},
    };
    use serde::{Deserialize, Serialize};
    use crate::{
        connection::{AccessPolicy, Connection, ServerConnection},
        document::Document,
        limits::{LIST_TRANSACTIONS_DEFAULT_RESULT_COUNT, LIST_TRANSACTIONS_MAX_RESULTS},
        schema::{
            view, Collection, CollectionName, InvalidNameError, MapResult, MappedValue, Name,
            Schema, SchemaName, Schematic, View,
        },
        Error,
    };
    pub struct Basic {
        pub value: String,
        pub category: Option<String>,
        pub parent_id: Option<u64>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Basic {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Basic",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "category",
                    &self.category,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "parent_id",
                    &self.parent_id,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Basic {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            1u64 => _serde::__private::Ok(__Field::__field1),
                            2u64 => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            "category" => _serde::__private::Ok(__Field::__field1),
                            "parent_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            b"category" => _serde::__private::Ok(__Field::__field1),
                            b"parent_id" => _serde::__private::Ok(__Field::__field2),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Basic>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Basic;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Basic")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Basic with 3 elements",
                                        ),
                                    );
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Basic with 3 elements",
                                ));
                            }
                        };
                        let __field2 = match match _serde::de::SeqAccess::next_element::<Option<u64>>(
                            &mut __seq,
                        ) {
                            _serde::__private::Ok(__val) => __val,
                            _serde::__private::Err(__err) => {
                                return _serde::__private::Err(__err);
                            }
                        } {
                            _serde::__private::Some(__value) => __value,
                            _serde::__private::None => {
                                return _serde::__private::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct Basic with 3 elements",
                                ));
                            }
                        };
                        _serde::__private::Ok(Basic {
                            value: __field0,
                            category: __field1,
                            parent_id: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<String> =
                            _serde::__private::None;
                        let mut __field1: _serde::__private::Option<Option<String>> =
                            _serde::__private::None;
                        let mut __field2: _serde::__private::Option<Option<u64>> =
                            _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::__private::Option::is_some(&__field1) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "category",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::__private::Option::is_some(&__field2) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "parent_id",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<Option<u64>>(
                                            &mut __map,
                                        ) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("value") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::__private::Some(__field1) => __field1,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("category") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::__private::Some(__field2) => __field2,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("parent_id") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Basic {
                            value: __field0,
                            category: __field1,
                            parent_id: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value", "category", "parent_id"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Basic",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Basic>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Basic {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Basic {
                    value: ref __self_0_0,
                    category: ref __self_0_1,
                    parent_id: ref __self_0_2,
                } => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_struct(f, "Basic");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_0_0),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "category",
                        &&(*__self_0_1),
                    );
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "parent_id",
                        &&(*__self_0_2),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Basic {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Basic {
        #[inline]
        fn eq(&self, other: &Basic) -> bool {
            match *other {
                Basic {
                    value: ref __self_1_0,
                    category: ref __self_1_1,
                    parent_id: ref __self_1_2,
                } => match *self {
                    Basic {
                        value: ref __self_0_0,
                        category: ref __self_0_1,
                        parent_id: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Basic) -> bool {
            match *other {
                Basic {
                    value: ref __self_1_0,
                    category: ref __self_1_1,
                    parent_id: ref __self_1_2,
                } => match *self {
                    Basic {
                        value: ref __self_0_0,
                        category: ref __self_0_1,
                        parent_id: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for Basic {
        #[inline]
        fn default() -> Basic {
            Basic {
                value: ::core::default::Default::default(),
                category: ::core::default::Default::default(),
                parent_id: ::core::default::Default::default(),
            }
        }
    }
    impl Basic {
        pub fn new(value: impl Into<String>) -> Self {
            Self {
                value: value.into(),
                category: None,
                parent_id: None,
            }
        }
        pub fn with_category(mut self, category: impl Into<String>) -> Self {
            self.category = Some(category.into());
            self
        }
        #[must_use]
        pub const fn with_parent_id(mut self, parent_id: u64) -> Self {
            self.parent_id = Some(parent_id);
            self
        }
    }
    impl Collection for Basic {
        fn collection_name() -> Result<CollectionName, InvalidNameError> {
            CollectionName::new("khonsulabs", "basic")
        }
        fn define_views(schema: &mut Schematic) -> Result<(), Error> {
            schema.define_view(BasicCount)?;
            schema.define_view(BasicByParentId)?;
            schema.define_view(BasicByCategory)
        }
    }
    pub struct BasicCount;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicCount {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicCount => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicCount");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl View for BasicCount {
        type Collection = Basic;
        type Key = ();
        type Value = usize;
        fn version(&self) -> u64 {
            0
        }
        fn name(&self) -> Result<Name, InvalidNameError> {
            Name::new("count")
        }
        fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value> {
            Ok(Some(document.emit_key_and_value((), 1)))
        }
        fn reduce(
            &self,
            mappings: &[MappedValue<Self::Key, Self::Value>],
            _rereduce: bool,
        ) -> Result<Self::Value, view::Error> {
            Ok(mappings.iter().map(|map| map.value).sum())
        }
    }
    pub struct BasicByParentId;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicByParentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicByParentId => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicByParentId");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl View for BasicByParentId {
        type Collection = Basic;
        type Key = Option<u64>;
        type Value = usize;
        fn version(&self) -> u64 {
            1
        }
        fn name(&self) -> Result<Name, InvalidNameError> {
            Name::new("by-parent-id")
        }
        fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value> {
            let contents = document.contents::<Basic>()?;
            Ok(Some(document.emit_key_and_value(contents.parent_id, 1)))
        }
        fn reduce(
            &self,
            mappings: &[MappedValue<Self::Key, Self::Value>],
            _rereduce: bool,
        ) -> Result<Self::Value, view::Error> {
            Ok(mappings.iter().map(|map| map.value).sum())
        }
    }
    pub struct BasicByCategory;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicByCategory {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicByCategory => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicByCategory");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl View for BasicByCategory {
        type Collection = Basic;
        type Key = String;
        type Value = usize;
        fn version(&self) -> u64 {
            0
        }
        fn name(&self) -> Result<Name, InvalidNameError> {
            Name::new("by-category")
        }
        fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value> {
            let contents = document.contents::<Basic>()?;
            if let Some(category) = &contents.category {
                Ok(Some(
                    document.emit_key_and_value(category.to_lowercase(), 1),
                ))
            } else {
                Ok(None)
            }
        }
        fn reduce(
            &self,
            mappings: &[MappedValue<Self::Key, Self::Value>],
            _rereduce: bool,
        ) -> Result<Self::Value, view::Error> {
            Ok(mappings.iter().map(|map| map.value).sum())
        }
    }
    pub struct BasicByBrokenParentId;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicByBrokenParentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicByBrokenParentId => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicByBrokenParentId");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl View for BasicByBrokenParentId {
        type Collection = Basic;
        type Key = ();
        type Value = ();
        fn version(&self) -> u64 {
            0
        }
        fn name(&self) -> Result<Name, InvalidNameError> {
            Name::new("by-parent-id")
        }
        fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value> {
            Ok(Some(document.emit()))
        }
    }
    pub struct BasicSchema;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicSchema {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicSchema => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicSchema");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Schema for BasicSchema {
        fn schema_name() -> Result<SchemaName, InvalidNameError> {
            SchemaName::new("khonsulabs", "basic")
        }
        fn define_collections(schema: &mut Schematic) -> Result<(), Error> {
            schema.define_collection::<Basic>()?;
            schema.define_collection::<Unique>()
        }
    }
    pub struct Unique {
        pub value: u32,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Unique {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::__private::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Unique",
                    false as usize + 1,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "value",
                    &self.value,
                ) {
                    _serde::__private::Ok(__val) => __val,
                    _serde::__private::Err(__err) => {
                        return _serde::__private::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Unique {
            fn deserialize<__D>(__deserializer: __D) -> _serde::__private::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::__private::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"value" => _serde::__private::Ok(__Field::__field0),
                            _ => _serde::__private::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::__private::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::__private::PhantomData<Unique>,
                    lifetime: _serde::__private::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Unique;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::__private::Formatter,
                    ) -> _serde::__private::fmt::Result {
                        _serde::__private::Formatter::write_str(__formatter, "struct Unique")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<u32>(&mut __seq) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            } {
                                _serde::__private::Some(__value) => __value,
                                _serde::__private::None => {
                                    return _serde::__private::Err(
                                        _serde::de::Error::invalid_length(
                                            0usize,
                                            &"struct Unique with 1 element",
                                        ),
                                    );
                                }
                            };
                        _serde::__private::Ok(Unique { value: __field0 })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::__private::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::__private::Option<u32> = _serde::__private::None;
                        while let _serde::__private::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::__private::Ok(__val) => __val,
                                _serde::__private::Err(__err) => {
                                    return _serde::__private::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::__private::Option::is_some(&__field0) {
                                        return _serde::__private::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "value",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::__private::Some(
                                        match _serde::de::MapAccess::next_value::<u32>(&mut __map) {
                                            _serde::__private::Ok(__val) => __val,
                                            _serde::__private::Err(__err) => {
                                                return _serde::__private::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::__private::Ok(__val) => __val,
                                        _serde::__private::Err(__err) => {
                                            return _serde::__private::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::__private::Some(__field0) => __field0,
                            _serde::__private::None => {
                                match _serde::__private::de::missing_field("value") {
                                    _serde::__private::Ok(__val) => __val,
                                    _serde::__private::Err(__err) => {
                                        return _serde::__private::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::__private::Ok(Unique { value: __field0 })
                    }
                }
                const FIELDS: &'static [&'static str] = &["value"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Unique",
                    FIELDS,
                    __Visitor {
                        marker: _serde::__private::PhantomData::<Unique>,
                        lifetime: _serde::__private::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Unique {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Unique {
                    value: ref __self_0_0,
                } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f, "Unique");
                    let _ = ::core::fmt::DebugStruct::field(
                        debug_trait_builder,
                        "value",
                        &&(*__self_0_0),
                    );
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Unique {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Unique {
        #[inline]
        fn eq(&self, other: &Unique) -> bool {
            match *other {
                Unique {
                    value: ref __self_1_0,
                } => match *self {
                    Unique {
                        value: ref __self_0_0,
                    } => (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Unique) -> bool {
            match *other {
                Unique {
                    value: ref __self_1_0,
                } => match *self {
                    Unique {
                        value: ref __self_0_0,
                    } => (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for Unique {
        #[inline]
        fn default() -> Unique {
            Unique {
                value: ::core::default::Default::default(),
            }
        }
    }
    impl Collection for Unique {
        fn collection_name() -> Result<CollectionName, InvalidNameError> {
            CollectionName::new("khonsulabs", "unique")
        }
        fn define_views(schema: &mut Schematic) -> Result<(), Error> {
            schema.define_view(UniqueValue)
        }
    }
    pub struct UniqueValue;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UniqueValue {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UniqueValue => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UniqueValue");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl View for UniqueValue {
        type Collection = Unique;
        type Key = u32;
        type Value = ();
        fn unique(&self) -> bool {
            true
        }
        fn version(&self) -> u64 {
            1
        }
        fn name(&self) -> Result<Name, InvalidNameError> {
            Name::new("unique-value")
        }
        fn map(&self, document: &Document<'_>) -> MapResult<Self::Key, Self::Value> {
            let entry = document.contents::<Unique>()?;
            Ok(Some(document.emit_key(entry.value)))
        }
    }
    pub struct TestDirectory(pub PathBuf);
    impl TestDirectory {
        pub fn new<S: AsRef<Path>>(name: S) -> Self {
            let path = std::env::temp_dir().join(name);
            if path.exists() {
                std::fs::remove_dir_all(&path).expect("error clearing temporary directory");
            }
            Self(path)
        }
    }
    impl Drop for TestDirectory {
        fn drop(&mut self) {
            if let Err(err) = std::fs::remove_dir_all(&self.0) {
                if err.kind() != ErrorKind::NotFound {
                    {
                        ::std::io::_eprint(::core::fmt::Arguments::new_v1(
                            &["Failed to clean up temporary folder: ", "\n"],
                            &match (&err,) {
                                (arg0,) => {
                                    [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)]
                                }
                            },
                        ));
                    };
                }
            }
        }
    }
    impl AsRef<Path> for TestDirectory {
        fn as_ref(&self) -> &Path {
            &self.0
        }
    }
    pub struct BasicCollectionWithNoViews;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicCollectionWithNoViews {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicCollectionWithNoViews => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BasicCollectionWithNoViews");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Collection for BasicCollectionWithNoViews {
        fn collection_name() -> Result<CollectionName, InvalidNameError> {
            Basic::collection_name()
        }
        fn define_views(_schema: &mut Schematic) -> Result<(), Error> {
            Ok(())
        }
    }
    pub struct BasicCollectionWithOnlyBrokenParentId;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for BasicCollectionWithOnlyBrokenParentId {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                BasicCollectionWithOnlyBrokenParentId => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(
                        f,
                        "BasicCollectionWithOnlyBrokenParentId",
                    );
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Collection for BasicCollectionWithOnlyBrokenParentId {
        fn collection_name() -> Result<CollectionName, InvalidNameError> {
            Basic::collection_name()
        }
        fn define_views(schema: &mut Schematic) -> Result<(), Error> {
            schema.define_view(BasicByBrokenParentId)
        }
    }
    pub struct UnassociatedCollection;
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnassociatedCollection {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                UnassociatedCollection => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UnassociatedCollection");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl Collection for UnassociatedCollection {
        fn collection_name() -> Result<CollectionName, InvalidNameError> {
            CollectionName::new("khonsulabs", "unassociated")
        }
        fn define_views(_schema: &mut Schematic) -> Result<(), Error> {
            Ok(())
        }
    }
    pub enum HarnessTest {
        ServerConnectionTests = 1,
        StoreRetrieveUpdate,
        NotFound,
        Conflict,
        BadUpdate,
        NoUpdate,
        GetMultiple,
        ListTransactions,
        ViewQuery,
        UnassociatedCollection,
        ViewUpdate,
        ViewAccessPolicies,
        UniqueViews,
        PubSubSimple,
        PubSubMultipleSubscribers,
        PubSubDropAndSend,
        PubSubUnsubscribe,
        PubSubDropCleanup,
        PubSubPublishAll,
        KvBasic,
        KvSet,
        KvExpiration,
        KvDeleteExpire,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for HarnessTest {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for HarnessTest {
        #[inline]
        fn clone(&self) -> HarnessTest {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for HarnessTest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&HarnessTest::ServerConnectionTests,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ServerConnectionTests");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::StoreRetrieveUpdate,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "StoreRetrieveUpdate");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::NotFound,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "NotFound");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::Conflict,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "Conflict");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::BadUpdate,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "BadUpdate");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::NoUpdate,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "NoUpdate");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::GetMultiple,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "GetMultiple");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::ListTransactions,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ListTransactions");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::ViewQuery,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewQuery");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::UnassociatedCollection,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UnassociatedCollection");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::ViewUpdate,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewUpdate");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::ViewAccessPolicies,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "ViewAccessPolicies");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::UniqueViews,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "UniqueViews");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubSimple,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubSimple");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubMultipleSubscribers,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubMultipleSubscribers");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubDropAndSend,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubDropAndSend");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubUnsubscribe,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubUnsubscribe");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubDropCleanup,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubDropCleanup");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::PubSubPublishAll,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "PubSubPublishAll");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::KvBasic,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "KvBasic");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::KvSet,) => {
                    let debug_trait_builder = &mut ::core::fmt::Formatter::debug_tuple(f, "KvSet");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::KvExpiration,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "KvExpiration");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
                (&HarnessTest::KvDeleteExpire,) => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_tuple(f, "KvDeleteExpire");
                    ::core::fmt::DebugTuple::finish(debug_trait_builder)
                }
            }
        }
    }
    impl HarnessTest {
        #[must_use]
        pub const fn port(self, base: u16) -> u16 {
            base + self as u16
        }
    }
    impl Display for HarnessTest {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            Debug::fmt(&self, f)
        }
    }
    pub async fn store_retrieve_update_delete_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let original_value = Basic::new("initial_value");
        let collection = db.collection::<Basic>();
        let header = collection.push(&original_value).await?;
        let mut doc = collection
            .get(header.id)
            .await?
            .expect("couldn't retrieve stored item");
        let mut value = doc.contents::<Basic>()?;
        {
            match (&original_value, &value) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let old_revision = doc.header.revision.clone();
        value.value = String::from("updated_value");
        doc.set_contents(&value)?;
        db.update(&mut doc).await?;
        {
            match (&doc.header.revision, &old_revision) {
                (left_val, right_val) => {
                    if *left_val == *right_val {
                        let kind = ::core::panicking::AssertKind::Ne;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let doc = collection
            .get(header.id)
            .await?
            .expect("couldn't retrieve stored item");
        {
            match (&doc.contents::<Basic>()?, &value) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let transactions = db.list_executed_transactions(None, None).await?;
        {
            match (&transactions.len(), &2) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        if !(transactions[0].id < transactions[1].id) {
            ::core::panicking::panic("assertion failed: transactions[0].id < transactions[1].id")
        };
        for transaction in &transactions {
            {
                match (&transaction.changed_documents.len(), &1) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (
                    &transaction.changed_documents[0].collection,
                    &Basic::collection_name()?,
                ) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&transaction.changed_documents[0].id, &header.id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&transaction.changed_documents[0].deleted, &false) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
        }
        db.delete(&doc).await?;
        if !collection.get(header.id).await?.is_none() {
            ::core::panicking::panic("assertion failed: collection.get(header.id).await?.is_none()")
        };
        let transactions = db
            .list_executed_transactions(Some(transactions.last().as_ref().unwrap().id + 1), None)
            .await?;
        {
            match (&transactions.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let transaction = transactions.first().unwrap();
        {
            match (&transaction.changed_documents.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &transaction.changed_documents[0].collection,
                &Basic::collection_name()?,
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&transaction.changed_documents[0].id, &header.id) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&transaction.changed_documents[0].deleted, &true) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn not_found_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        if !db.collection::<Basic>().get(1).await?.is_none() {
            ::core::panicking::panic(
                "assertion failed: db.collection::<Basic>().get(1).await?.is_none()",
            )
        };
        if !db.last_transaction_id().await?.is_none() {
            ::core::panicking::panic("assertion failed: db.last_transaction_id().await?.is_none()")
        };
        Ok(())
    }
    pub async fn conflict_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let original_value = Basic::new("initial_value");
        let collection = db.collection::<Basic>();
        let header = collection.push(&original_value).await?;
        let mut doc = collection
            .get(header.id)
            .await?
            .expect("couldn't retrieve stored item");
        let mut value = doc.contents::<Basic>()?;
        value.value = String::from("updated_value");
        doc.set_contents(&value)?;
        db.update(&mut doc).await?;
        doc.header = Cow::Owned(header);
        match db
            .update(&mut doc)
            .await
            .expect_err("conflict should have generated an error")
        {
            Error::DocumentConflict(collection, id) => {
                {
                    match (&collection, &Basic::collection_name()?) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
                {
                    match (&id, &doc.header.id) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
            }
            other => return Err(anyhow::Error::from(other)),
        }
        Ok(())
    }
    pub async fn bad_update_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let mut doc = Document::with_contents(1, &Basic::default(), Basic::collection_name()?)?;
        match db.update(&mut doc).await {
            Err(Error::DocumentNotFound(collection, id)) => {
                {
                    match (&collection, &Basic::collection_name()?) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
                {
                    match (&id, &1) {
                        (left_val, right_val) => {
                            if !(*left_val == *right_val) {
                                let kind = ::core::panicking::AssertKind::Eq;
                                ::core::panicking::assert_failed(
                                    kind,
                                    &*left_val,
                                    &*right_val,
                                    ::core::option::Option::None,
                                );
                            }
                        }
                    }
                };
                Ok(())
            }
            other => ::std::rt::begin_panic_fmt(&::core::fmt::Arguments::new_v1(
                &["expected DocumentNotFound from update but got: "],
                &match (&other,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Debug::fmt)],
                },
            )),
        }
    }
    pub async fn no_update_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let original_value = Basic::new("initial_value");
        let collection = db.collection::<Basic>();
        let header = collection.push(&original_value).await?;
        let mut doc = collection
            .get(header.id)
            .await?
            .expect("couldn't retrieve stored item");
        db.update(&mut doc).await?;
        {
            match (&doc.header.as_ref(), &&header) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn get_multiple_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let collection = db.collection::<Basic>();
        let doc1_value = Basic::new("initial_value");
        let doc1 = collection.push(&doc1_value).await?;
        let doc2_value = Basic::new("second_value");
        let doc2 = collection.push(&doc2_value).await?;
        let both_docs = db.get_multiple::<Basic>(&[doc1.id, doc2.id]).await?;
        {
            match (&both_docs.len(), &2) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let doc1 = both_docs
            .iter()
            .find(|doc| doc.header.id == doc1.id)
            .expect("Couldn't find doc1");
        let doc1 = doc1.contents::<Basic>()?;
        {
            match (&doc1.value, &doc1_value.value) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let doc2 = both_docs
            .iter()
            .find(|doc| doc.header.id == doc2.id)
            .expect("Couldn't find doc2");
        let doc2 = doc2.contents::<Basic>()?;
        {
            match (&doc2.value, &doc2_value.value) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn list_transactions_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let collection = db.collection::<Basic>();
        futures::future::join_all(
            (0..=(LIST_TRANSACTIONS_MAX_RESULTS))
                .map(|_| async { collection.push(&Basic::default()).await.unwrap() }),
        )
        .await;
        let transactions = db.list_executed_transactions(None, None).await?;
        {
            match (&transactions.len(), &LIST_TRANSACTIONS_DEFAULT_RESULT_COUNT) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let transactions = db
            .list_executed_transactions(None, Some(LIST_TRANSACTIONS_MAX_RESULTS + 1))
            .await?;
        {
            match (&transactions.len(), &LIST_TRANSACTIONS_MAX_RESULTS) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let transactions = db.list_executed_transactions(None, Some(0)).await?;
        if !transactions.is_empty() {
            ::core::panicking::panic("assertion failed: transactions.is_empty()")
        };
        let mut transactions = Vec::new();
        let mut starting_id = None;
        loop {
            let chunk = db
                .list_executed_transactions(starting_id, Some(100))
                .await?;
            if chunk.is_empty() {
                break;
            }
            let max_id = chunk.last().map(|tx| tx.id).unwrap();
            starting_id = Some(max_id + 1);
            transactions.extend(chunk);
        }
        {
            match (&transactions.len(), &(LIST_TRANSACTIONS_MAX_RESULTS + 1)) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn view_query_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let collection = db.collection::<Basic>();
        let a = collection.push(&Basic::new("A")).await?;
        let b = collection.push(&Basic::new("B")).await?;
        let a_child = collection
            .push(
                &Basic::new("A.1")
                    .with_parent_id(a.id)
                    .with_category("Alpha"),
            )
            .await?;
        collection
            .push(&Basic::new("B.1").with_parent_id(b.id).with_category("Beta"))
            .await?;
        collection
            .push(&Basic::new("B.2").with_parent_id(b.id).with_category("beta"))
            .await?;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .query()
            .await?;
        {
            match (&a_children.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .query_with_docs()
            .await?;
        {
            match (&a_children.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&a_children[0].document.header.id, &a_child.id) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let b_children = db
            .view::<BasicByParentId>()
            .with_key(Some(b.id))
            .query()
            .await?;
        {
            match (&b_children.len(), &2) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let a_and_b_children = db
            .view::<BasicByParentId>()
            .with_keys(<[_]>::into_vec(box [Some(a.id), Some(b.id)]))
            .query()
            .await?;
        {
            match (&a_and_b_children.len(), &3) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let has_parent = db
            .view::<BasicByParentId>()
            .with_key_range(Some(0)..Some(u64::MAX))
            .query()
            .await?;
        {
            match (&has_parent.len(), &3) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let items_with_categories = db.view::<BasicByCategory>().query().await?;
        {
            match (&items_with_categories.len(), &3) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn unassociated_collection_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        if !match db
            .collection::<UnassociatedCollection>()
            .push(&Basic::default())
            .await
        {
            Err(Error::CollectionNotFound) => true,
            _ => false,
        } {
            :: core :: panicking :: panic ("assertion failed: matches!(db . collection :: < UnassociatedCollection > () .\\n         push(& Basic :: default()) . await, Err(Error :: CollectionNotFound))")
        };
        Ok(())
    }
    pub async fn view_update_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let collection = db.collection::<Basic>();
        let a = collection.push(&Basic::new("A")).await?;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .query()
            .await?;
        {
            match (&a_children.len(), &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &db.view::<BasicByParentId>()
                    .with_key(Some(a.id))
                    .reduce()
                    .await?,
                &0,
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let a_child = collection
            .push(
                &Basic::new("A.1")
                    .with_parent_id(a.id)
                    .with_category("Alpha"),
            )
            .await?;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .query()
            .await?;
        {
            match (&a_children.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &db.view::<BasicByParentId>()
                    .with_key(Some(a.id))
                    .reduce()
                    .await?,
                &1,
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &db.view::<BasicByParentId>().reduce_grouped().await?,
                &<[_]>::into_vec(box [
                    MappedValue {
                        key: None,
                        value: 1,
                    },
                    MappedValue {
                        key: Some(a.id),
                        value: 1,
                    },
                ]),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let mut doc = db.collection::<Basic>().get(a_child.id).await?.unwrap();
        let mut basic = doc.contents::<Basic>()?;
        basic.parent_id = None;
        doc.set_contents(&basic)?;
        db.update(&mut doc).await?;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .query()
            .await?;
        {
            match (&a_children.len(), &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &db.view::<BasicByParentId>()
                    .with_key(Some(a.id))
                    .reduce()
                    .await?,
                &0,
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (&db.view::<BasicByParentId>().reduce().await?, &2) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        db.delete(&doc).await?;
        let all_entries = db.view::<BasicByParentId>().query().await?;
        {
            match (&all_entries.len(), &1) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        {
            match (
                &db.view::<BasicByParentId>().reduce_grouped().await?,
                &<[_]>::into_vec(box [MappedValue {
                    key: None,
                    value: 1,
                }]),
            ) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        Ok(())
    }
    pub async fn view_access_policy_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let collection = db.collection::<Basic>();
        let a = collection.push(&Basic::new("A")).await?;
        collection
            .push(
                &Basic::new("A.1")
                    .with_parent_id(a.id)
                    .with_category("Alpha"),
            )
            .await?;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .with_access_policy(AccessPolicy::NoUpdate)
            .query()
            .await?;
        {
            match (&a_children.len(), &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        tokio::time::sleep(Duration::from_millis(20)).await;
        let a_children = db
            .view::<BasicByParentId>()
            .with_key(Some(a.id))
            .with_access_policy(AccessPolicy::UpdateAfter)
            .query()
            .await?;
        {
            match (&a_children.len(), &0) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        for _ in 0..10_u8 {
            tokio::time::sleep(Duration::from_millis(20)).await;
            let a_children = db
                .view::<BasicByParentId>()
                .with_key(Some(a.id))
                .with_access_policy(AccessPolicy::NoUpdate)
                .query()
                .await?;
            if a_children.len() == 1 {
                return Ok(());
            }
        }
        {
            ::std::rt::begin_panic("view never updated")
        }
    }
    pub async fn unique_view_tests<C: Connection>(db: &C) -> anyhow::Result<()> {
        let first_doc = db.collection::<Unique>().push(&Unique { value: 1 }).await?;
        if let Err(Error::UniqueKeyViolation {
            view,
            existing_document_id,
            conflicting_document_id,
        }) = db.collection::<Unique>().push(&Unique { value: 1 }).await
        {
            {
                match (&view, &UniqueValue.view_name()?) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&existing_document_id, &first_doc.id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&conflicting_document_id, &existing_document_id) {
                    (left_val, right_val) => {
                        if *left_val == *right_val {
                            let kind = ::core::panicking::AssertKind::Ne;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
        } else {
            {
                {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"unique key violation not triggered",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        let second_doc = db.collection::<Unique>().push(&Unique { value: 2 }).await?;
        let mut second_doc = db.collection::<Unique>().get(second_doc.id).await?.unwrap();
        let mut contents = second_doc.contents::<Unique>()?;
        contents.value = 1;
        second_doc.set_contents(&contents)?;
        if let Err(Error::UniqueKeyViolation {
            view,
            existing_document_id,
            conflicting_document_id,
        }) = db.update(&mut second_doc).await
        {
            {
                match (&view, &UniqueValue.view_name()?) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&existing_document_id, &first_doc.id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
            {
                match (&conflicting_document_id, &second_doc.header.id) {
                    (left_val, right_val) => {
                        if !(*left_val == *right_val) {
                            let kind = ::core::panicking::AssertKind::Eq;
                            ::core::panicking::assert_failed(
                                kind,
                                &*left_val,
                                &*right_val,
                                ::core::option::Option::None,
                            );
                        }
                    }
                }
            };
        } else {
            {
                {
                    ::core::panicking::panic_fmt(::core::fmt::Arguments::new_v1(
                        &["internal error: entered unreachable code: "],
                        &match (&"unique key violation not triggered",) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ))
                }
            }
        }
        Ok(())
    }
    pub struct TimingTest {
        tolerance: Duration,
        start: Instant,
    }
    impl TimingTest {
        #[must_use]
        pub fn new(tolerance: Duration) -> Self {
            Self {
                tolerance,
                start: Instant::now(),
            }
        }
        pub async fn wait_until(&self, absolute_duration: Duration) -> bool {
            let target = self.start + absolute_duration;
            let now = Instant::now();
            if now > target {
                let amount_past = now - target;
                amount_past < self.tolerance
            } else {
                tokio::time::sleep_until(target.into()).await;
                true
            }
        }
        #[must_use]
        pub fn elapsed(&self) -> Duration {
            Instant::now()
                .checked_duration_since(self.start)
                .unwrap_or_default()
        }
    }
    pub async fn basic_server_connection_tests<C: ServerConnection>(
        server: C,
        newdb_name: &str,
    ) -> anyhow::Result<()> {
        let schemas = server.list_available_schemas().await?;
        {
            match (&schemas, &<[_]>::into_vec(box [Basic::schema_name()?])) {
                (left_val, right_val) => {
                    if !(*left_val == *right_val) {
                        let kind = ::core::panicking::AssertKind::Eq;
                        ::core::panicking::assert_failed(
                            kind,
                            &*left_val,
                            &*right_val,
                            ::core::option::Option::None,
                        );
                    }
                }
            }
        };
        let databases = server.list_databases().await?;
        if !databases.contains(&crate::connection::Database {
            name: String::from("tests"),
            schema: Basic::schema_name()?,
        }) {
            :: core :: panicking :: panic ("assertion failed: databases.contains(&crate::connection::Database{name: String::from(\\\"tests\\\"),\\n                                                schema:\\n                                                    Basic::schema_name()?,})")
        };
        server.create_database::<Basic>(newdb_name).await?;
        server.delete_database(newdb_name).await?;
        if !match server.delete_database(newdb_name).await {
            Err(Error::DatabaseNotFound(_)) => true,
            _ => false,
        } {
            :: core :: panicking :: panic ("assertion failed: matches!(server . delete_database(newdb_name) . await,\\n         Err(Error :: DatabaseNotFound(_)))")
        };
        if !match server.create_database::<Basic>("tests").await {
            Err(Error::DatabaseNameAlreadyTaken(_)) => true,
            _ => false,
        } {
            :: core :: panicking :: panic ("assertion failed: matches!(server . create_database :: < Basic > (\\\"tests\\\") . await,\\n         Err(Error :: DatabaseNameAlreadyTaken(_)))")
        };
        if !match match server.create_database::<Basic>("|invalidname").await {
            tmp => {
                {
                    ::std::io::_eprint(::core::fmt::Arguments::new_v1_formatted(
                        &["[", ":", "] ", " = ", "\n"],
                        &match (
                            &"core/src/test_util.rs",
                            &1196u32,
                            &"server.create_database::<Basic>(\"|invalidname\").await",
                            &&tmp,
                        ) {
                            (arg0, arg1, arg2, arg3) => [
                                ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg2, ::core::fmt::Display::fmt),
                                ::core::fmt::ArgumentV1::new(arg3, ::core::fmt::Debug::fmt),
                            ],
                        },
                        &[
                            ::core::fmt::rt::v1::Argument {
                                position: 0usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 1usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 2usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 0u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                            ::core::fmt::rt::v1::Argument {
                                position: 3usize,
                                format: ::core::fmt::rt::v1::FormatSpec {
                                    fill: ' ',
                                    align: ::core::fmt::rt::v1::Alignment::Unknown,
                                    flags: 4u32,
                                    precision: ::core::fmt::rt::v1::Count::Implied,
                                    width: ::core::fmt::rt::v1::Count::Implied,
                                },
                            },
                        ],
                    ));
                };
                tmp
            }
        } {
            Err(Error::InvalidDatabaseName(_)) => true,
            _ => false,
        } {
            :: core :: panicking :: panic ("assertion failed: matches!(dbg !\\n         (server . create_database :: < Basic > (\\\"|invalidname\\\") . await),\\n         Err(Error :: InvalidDatabaseName(_)))")
        };
        if !match server
            .create_database::<UnassociatedCollection>(newdb_name)
            .await
        {
            Err(Error::SchemaNotRegistered(_)) => true,
            _ => false,
        } {
            :: core :: panicking :: panic ("assertion failed: matches!(server . create_database :: < UnassociatedCollection > (newdb_name) .\\n         await, Err(Error :: SchemaNotRegistered(_)))")
        };
        Ok(())
    }
}
