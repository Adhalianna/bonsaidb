<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>PliantDb User&#x27;s Guide</title>
                <meta name="robots" content="noindex" />
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">About PliantDb</li><li class="chapter-item expanded "><a href="about/concepts.html"><strong aria-hidden="true">1.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="about/concepts/document.html"><strong aria-hidden="true">1.1.</strong> Document</a></li><li class="chapter-item expanded "><a href="about/concepts/collection.html"><strong aria-hidden="true">1.2.</strong> Collection</a></li><li class="chapter-item expanded "><a href="about/concepts/view.html"><strong aria-hidden="true">1.3.</strong> View</a></li><li class="chapter-item expanded "><a href="about/concepts/schema.html"><strong aria-hidden="true">1.4.</strong> Schema</a></li><li class="chapter-item expanded "><a href="about/concepts/database.html"><strong aria-hidden="true">1.5.</strong> Database</a></li><li class="chapter-item expanded "><a href="about/concepts/server.html"><strong aria-hidden="true">1.6.</strong> Server</a></li><li class="chapter-item expanded "><a href="about/concepts/client.html"><strong aria-hidden="true">1.7.</strong> Client</a></li><li class="chapter-item expanded "><a href="about/concepts/pubsub.html"><strong aria-hidden="true">1.8.</strong> PubSub</a></li></ol></li><li class="chapter-item expanded "><a href="about/access_models.html"><strong aria-hidden="true">2.</strong> How can PliantDb be accessed?</a></li><li class="chapter-item expanded affix "><li class="part-title">Integration</li><li class="chapter-item expanded "><a href="integration/overview.html"><strong aria-hidden="true">3.</strong> Overview</a></li><li class="chapter-item expanded "><a href="integration/local.html"><strong aria-hidden="true">4.</strong> Local</a></li><li class="chapter-item expanded "><a href="integration/server.html"><strong aria-hidden="true">5.</strong> Networked</a></li><li class="chapter-item expanded "><a href="integration/cluster.html"><strong aria-hidden="true">6.</strong> Clustered (upcoming)</a></li><li class="chapter-item expanded affix "><li class="part-title">Core Traits</li><li class="chapter-item expanded "><a href="traits/connection.html"><strong aria-hidden="true">7.</strong> Connection</a></li><li class="chapter-item expanded "><a href="traits/server_connection.html"><strong aria-hidden="true">8.</strong> ServerConnection</a></li><li class="chapter-item expanded "><a href="traits/pubsub.html"><strong aria-hidden="true">9.</strong> PubSub/Subscriber</a></li><li class="chapter-item expanded "><a href="traits/kv.html"><strong aria-hidden="true">10.</strong> Kv</a></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">PliantDb User&#x27;s Guide</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pliantdb-users-guide"><a class="header" href="#pliantdb-users-guide">PliantDb User's Guide</a></h1>
<p>PliantDb is an ACID-compliant, document-database written in Rust. It takes heavy inspiration from CouchDB, but makes no efforts to be compatible with CouchDB. Its goal is to be a general-purpose database that aims to simplify development and deployment by providing reliable building blocks that are lightweight enough for hobby projects running with minimal resources, but scalable for when your hobby project becomes a deployed product.</p>
<p>This user's guide aims to provide a guided walkthrough for users to understand how PliantDb works. This guide is meant to be supplemental <a href="https://pliantdb.dev/main/pliantdb/">to the documentation</a>. If you learn best by exploring examples, <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples">many are available in <code>pliantdb/examples</code></a>. If, however, you learn best by taking a guided tour of how something works, this guide is specifically for you.</p>
<p>If you have any feedback on this guide, please <a href="https://github.com/khonsulabs/pliantdb/issues">file an issue</a>, and we will try to address any issues or shortcomings.</p>
<p>Thank you for exploring PliantDb.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>This is a list of common concepts that will be used throughout this book as well as the documentation.</p>
<ul>
<li><a href="about/./concepts/document.html">Document</a></li>
<li><a href="about/./concepts/collection.html">Collection</a></li>
<li><a href="about/./concepts/view.html">View</a></li>
<li><a href="about/./concepts/schema.html">Schema</a></li>
<li><a href="about/./concepts/database.html">Database</a></li>
<li><a href="about/./concepts/server.html">Server</a></li>
<li><a href="about/./concepts/client.html">Client</a></li>
<li><a href="about/./concepts/pubsub.html">PubSub</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="document"><a class="header" href="#document">Document</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/core/document/struct.Document.html">Document</a> is a single piece of stored data. Each document is stored within a <a href="about/concepts/./collection.html"><code>Collection</code></a>, and has a unique ID within that Collection. A Document also contains a revision ID as well as a digest matching the current contents of the document.</p>
<p>When a Document is updated, PliantDb will check that the revision information passed matches the currently stored information. If not, a <a href="https://pliantdb.dev/main/pliantdb/core/enum.Error.html#variant.DocumentConflict">conflict error</a> will be returned. This simple check ensures that if two writers try to update the document simultaneously, one will succeed and the other will receive an error.</p>
<p>PliantDb provides APIs for storing <a href="https://serde.rs/">serde</a>-compatible data structures using the <a href="https://cbor.io/">CBOR</a> format. CBOR provides larger data type compatibility than JSON, and is a more efficent format. It also provides a bit more resilliance for parsing structures that have changed than some other encoding formats, but care still needs to be taken when updating structures that represent already-stored data.</p>
<p>If you would prefer to manually manage the data stored inside of a Document, you can directly manage the <a href="https://pliantdb.dev/main/pliantdb/core/document/struct.Document.html#structfield.contents"><code>contents</code></a> field. PliantDb will not interact with the <code>contents</code> of a Document. Only code that you write will parse or update the stored data.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection"><a class="header" href="#collection">Collection</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Collection.html">Collection</a> is a group of <a href="about/concepts/./document.html">Documents</a> and associated functionality. The goal of a Collection is to encapsulate the logic for a set of data in such a way that Collections could be designed to be shared and reused in multiple <a href="about/concepts/./schema.html">Schemas</a> or applications.</p>
<p>Each Collection must have a unique <a href="https://pliantdb.dev/main/pliantdb/core/schema/struct.CollectionId.html"><code>CollectionId</code></a>.</p>
<p>A Collection can contain one or more <a href="about/concepts/./view.html">Views</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="view"><a class="header" href="#view">View</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.View.html">View</a> is a <a href="https://en.wikipedia.org/wiki/MapReduce">map/reduce</a>-powered method of quickly accessing information inside of a <a href="about/concepts/./collection.html">Collection</a>. A View can only belong to one Collection.</p>
<p>Views define two important associated types: a Key type and a Value type. You can think of these as the equivalent entries in a map/dictionary-like collection that supports more than one entry for each Key. The Key is used to filter the View's results, and the Value is used by your application or the <code>reduce()</code> function.</p>
<p>Views are a powerful, yet abstract concept. Let's look at a concrete example: blog posts with categories.</p>
<pre><code class="language-rust no_run noplayground">#[derive(Serialize, Deserialize, Debug)]
pub struct BlogPost {
    pub title: String,
    pub body: String,
    pub category: Option&lt;String&gt;,
}
</code></pre>
<p>While <code>category</code> should be an enum, let's first explore using <code>String</code> and upgrade to an enum at the end (it requires one additional step). Let's implement a View that will allow users to find blog posts by their category as well as count the number of posts in each category.</p>
<pre><code class="language-rust noplayground no_run">pub trait BlogPostsByCategory {
    type Collection = BlogPost;
    type Key = Option&lt;String&gt;;
    type Value = u32;

    fn map(&amp;self, document: &amp;Document&lt;'_&gt;) -&gt; MapResult&lt;Self::Key, Self::Value&gt; {
        let post = document.contents::&lt;BlogPost&gt;()?;
        Ok(Some(document.emit_key_and_value(post.category.clone(), 1)))
    }

    fn reduce(
        &amp;self,
        mappings: &amp;[MappedValue&lt;Self::Key, Self::Value&gt;],
        _rereduce: bool,
    ) -&gt; Result&lt;Self::Value, Error&gt; {
        Ok(mappings.iter().map(|mapping| mapping.value).sum())
    }
}
</code></pre>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<p>The first line of the <code>map</code> function calls <a href="https://pliantdb.dev/main/pliantdb/core/document/struct.Document.html#method.contents"><code>Document::contents()</code></a> to deserialize the stored <code>BlogPost</code>. The second line returns an emitted Key and Value -- in our case a clone of the post's category and the value <code>1_u32</code>. With the map function, we're able to use <a href="https://pliantdb.dev/main/pliantdb/core/connection/struct.View.html#method.query"><code>query()</code></a> and <a href="https://pliantdb.dev/main/pliantdb/core/connection/struct.View.html#method.query_with_docs"><code>query_with_docs()</code></a>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_posts = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(String::from(&quot;Rust&quot;)))
        .query_with_docs().await?;
</code></pre>
<p>The above queries the <a href="about/concepts/./database.html">Database</a> for all documents in the <code>BlogPost</code> Collection that emitted a Key of <code>Some(&quot;Rust&quot;)</code>.</p>
<h2 id="reduce"><a class="header" href="#reduce">Reduce</a></h2>
<p>The second function to learn about is the <code>reduce()</code> function. It is responsible for turning an array of Key/Value pairs into a single Value. In some cases, PliantDb might need to call <code>reduce()</code> with values that have already been reduced one time. If this is the case, <code>rereduce</code> is set to true.</p>
<p>In this example, we're using the built-in <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.sum"><code>Iterator::sum()</code></a> function to turn our Value of <code>1_u32</code> into a single <code>u32</code> representing the total number of documents.</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(String::from(&quot;Rust&quot;)))
        .reduce().await?;
</code></pre>
<h3 id="understanding-re-reduce"><a class="header" href="#understanding-re-reduce">Understanding Re-reduce</a></h3>
<p>Let's examine this data set:</p>
<table><thead><tr><th>Document ID</th><th>BlogPost Category</th></tr></thead><tbody>
<tr><td>1</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>2</td><td>Some(&quot;Rust&quot;)</td></tr>
<tr><td>3</td><td>Some(&quot;Cooking&quot;)</td></tr>
<tr><td>4</td><td>None</td></tr>
</tbody></table>
<p>When updating views, each view entry is reduced and the value is cached. These are the view entries:</p>
<table><thead><tr><th>View Entry ID</th><th>Reduced Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
<p>When a reduce query is issued for a single key, the value can be returned without further processing. But, if the reduce query matches multiple keys, the View's <code>reduce()</code> function will be called with the already reduced values with <code>rereduce</code> set to <code>true</code>. For example, retrieving the total count of blog posts:</p>
<pre><code class="language-rust noplayground no_run">    let total_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .reduce().await?;
</code></pre>
<p>Once PliantDb has gathered each of the key's reduced values, it needs to further reduce that list into a single value. To accomplish this, the View's <code>reduce()</code> function to be invoked with <code>rereduce</code> set to <code>true</code>, and with mappings containing:</p>
<table><thead><tr><th>Key</th><th>Value</th></tr></thead><tbody>
<tr><td>Some(&quot;Rust&quot;)</td><td>2</td></tr>
<tr><td>Some(&quot;Cooking&quot;)</td><td>1</td></tr>
<tr><td>None</td><td>1</td></tr>
</tbody></table>
<p>This produces a final value of 4.</p>
<h2 id="how-does-pliantdb-make-this-efficient"><a class="header" href="#how-does-pliantdb-make-this-efficient">How does PliantDb make this efficient?</a></h2>
<p>When saving Documents, PliantDb does not immediately update related views. It instead notes what documents have been updated since the last time the View was indexed.</p>
<p>When a View is accessed, the queries include an <a href="https://pliantdb.dev/main/pliantdb/core/connection/enum.AccessPolicy.html"><code>AccessPolicy</code></a>. If you aren't overriding it, <a href="https://pliantdb.dev/main/pliantdb/core/connection/enum.AccessPolicy.html#variant.UpdateBefore"><code>UpdateBefore</code></a> is used. This means that when the query is evaluated, PliantDb will first check if the index is out of date due to any updated data. If it is, it will update the View before evaluating the query.</p>
<p>If you're wanting to get results quickly and are willing to accept data that might not be updated, the access policies <a href="https://pliantdb.dev/main/pliantdb/core/connection/enum.AccessPolicy.html#variant.UpdateAfter"><code>UpdateAfter</code></a> and <a href="https://pliantdb.dev/main/pliantdb/core/connection/enum.AccessPolicy.html#variant.NoUpdate"><code>NoUpdate</code></a> can be used depending on your needs.</p>
<p>If multiple simulataneous queries are being evaluted for the same View and the View is outdated, PliantDb ensures that only a single view indexer will execute while both queries wait for it to complete.</p>
<h2 id="using-arbitrary-types-as-a-view-key"><a class="header" href="#using-arbitrary-types-as-a-view-key">Using arbitrary types as a View Key</a></h2>
<p>In our previous example, we used <code>String</code> for the Key type. The reason is important: Keys must be sortable by <a href="http://sled.rs/">our underlying storage engine</a>, which means special care must be taken. Most serialization types do not guarantee binary sort order. Instead, PliantDb exposes the <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Key.html"><code>Key</code></a> trait. On that documentation page, you can see that PliantDb implements <code>Key</code> for many built-in types.</p>
<h3 id="using-an-enum-as-a-view-key"><a class="header" href="#using-an-enum-as-a-view-key">Using an enum as a View Key</a></h3>
<p>The easiest way to expose an enum is to derive <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.FromPrimitive.html"><code>num_traits::FromPrimitive</code></a> and <a href="https://docs.rs/num-traits/0.2.14/num_traits/cast/trait.ToPrimitive.html"><code>num_traits::ToPrimitive</code></a> using <a href="https://lib.rs/num-derive">num-derive</a>, and add an <code>impl EnumKey</code> line:</p>
<pre><code class="language-rust noplayground no_run">#[derive(Serialize, Deserialize, Debug, num_derive::FromPrimitive, num_derive::ToPrimitive)]
pub enum Category {
    Rust,
    Cooking,
}

impl EnumKey for Category {}
</code></pre>
<p>The View code remains unchanged, although the associated Key type can now be set to <code>Option&lt;Category&gt;</code>. The queries can now use the enum instead of a <code>String</code>:</p>
<pre><code class="language-rust noplayground no_run">    let rust_post_count = db
        .view::&lt;BlogPostsByCategory&gt;()
        .with_key(Some(Category::Rust))
        .reduce().await?;
</code></pre>
<p>PliantDb will convert the enum to a u64 and use that value as the Key. A u64 was chosen to ensure fairly wide compatibility even with some extreme usages of bitmasks. If you wish to customize this behavior, you can implement <code>Key</code> directly.</p>
<h3 id="implementing-the-key-trait"><a class="header" href="#implementing-the-key-trait">Implementing the <code>Key</code> trait</a></h3>
<p>The <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Key.html"><code>Key</code></a> trait declares two functions: <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Key.html#tymethod.as_big_endian_bytes"><code>as_big_endian_bytes()</code></a> and <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Key.html#tymethod.from_big_endian_bytes"><code>from_big_endian_bytes</code></a>. The intention is to convert the type to bytes using a network byte order for numerical types, and for non-numerical types, the bytes need to be stored in binary-sortable order.</p>
<p>Here is how PliantDb implements Key for <code>EnumKey</code>:</p>
<pre><code class="language-rust noplayground no_run">impl&lt;T&gt; Key for T
where
    T: EnumKey,
{
    fn as_big_endian_bytes(&amp;self) -&gt; anyhow::Result&lt;Cow&lt;'_, [u8]&gt;&gt; {
        self.to_u64()
            .ok_or_else(|| anyhow::anyhow!(&quot;Primitive::to_u64() returned None&quot;))?
            .as_big_endian_bytes()
            .map(|bytes| Cow::Owned(bytes.to_vec()))
    }

    fn from_big_endian_bytes(bytes: &amp;[u8]) -&gt; anyhow::Result&lt;Self&gt; {
        let primitive = u64::from_big_endian_bytes(bytes)?;
        Self::from_u64(primitive)
            .ok_or_else(|| anyhow::anyhow!(&quot;Primitive::from_u64() returned None&quot;))
    }
}
</code></pre>
<p>By implementing <code>Key</code> you can take full control of converting your view keys.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="schema"><a class="header" href="#schema">Schema</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/core/schema/trait.Schema.html">Schema</a> is a group of one or more <a href="about/concepts/./collection.html">Collections</a>. A Schema can be instantiated as a <a href="about/concepts/./database.html">Database</a>. The Schema describes how a set of data behaves, and a Database is a set of data on-disk.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="database"><a class="header" href="#database">Database</a></h1>
<p>A Database is a set of stored data. Each Database is described by a <a href="about/concepts/./schema.html">Schema</a>. Unlike the other concepts, this concept corresponds to multiple types:</p>
<ul>
<li>For pliantdb-local: <a href="https://pliantdb.dev/main/pliantdb/local/struct.Database.html"><code>Database</code></a></li>
<li>For pliantdb-server: <a href="https://pliantdb.dev/main/pliantdb/server/struct.Database.html"><code>hosted::Database</code></a></li>
<li>For pliantdb-client: <a href="https://pliantdb.dev/main/pliantdb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a></li>
</ul>
<p>All of these types implement the <a href="about/concepts/../../traits/connection.html"><code>Connection</code></a> trait.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="server"><a class="header" href="#server">Server</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/core/connection/trait.ServerConnection.html">Server</a> oversees one or more <a href="about/concepts/./schema.html">Schemas</a> and named <a href="about/concepts/./database.html">Databases</a>. Over time, this concept will be extended to have support for other features including users and permissions.</p>
<p>There are two ways to initialize a <code>PliantDb</code> server:</p>
<ul>
<li><a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a>: A local, file-based server implementation with no networking capabilities.</li>
<li><a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html"><code>Server</code></a>: A networked server implementation, written using <code>Storage</code>. This server supports <a href="https://en.wikipedia.org/wiki/QUIC">QUIC</a>- and <a href="https://en.wikipedia.org/wiki/WebSocket">WebSocket</a>-based protocols. The QUIC protocol is preferred, but it uses UDP which many load balancers don't support. If you're exposing <code>PliantDb</code> behind a load balancer, WebSockets may be the only option depending on your host's capabilities.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="client"><a class="header" href="#client">Client</a></h1>
<p>A <a href="https://pliantdb.dev/main/pliantdb/client/struct.Client.html">Client</a> is used to access a <a href="about/concepts/./server.html">Server</a> over a network connection.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub"><a class="header" href="#pubsub">PubSub</a></h1>
<p>The <a href="https://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern">Publish/Subscribe pattern</a> enables developers to design systems that produce and receive messages. It is implemented for PliantDb through the <a href="about/concepts/../../traits/pubsub.html"><code>PubSub</code> and <code>Subscriber</code></a> traits.</p>
<p>A common example of what PubSub enables is implementing a simple chat system. Each chat participant can subscribe to messages on the <code>chat</code> topic, and when any participant publishes a <code>chat</code> message, all subscribers will receive a copy of that message.</p>
<p>A working example of PubSub is available at <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/pubsub.rs"><code>pliantdb/examples/pubsub.rs</code></a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-cases-of-pliantdb"><a class="header" href="#use-cases-of-pliantdb">Use cases of PliantDb</a></h1>
<h2 id="single-database-model-no-networking"><a class="header" href="#single-database-model-no-networking">Single database model (No networking)</a></h2>
<p>This use case is most similar to utilizing SQLite for your database. In this mode, PliantDb directly interacts with files on your disk to provide your database. Unlike other file-based databases, however, it's easy to migrate to any of these scenarios from this starting position:</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(pliantdb-local::Database)]
  code &lt;--&gt; local
</pre>
<p>A working example of how to use a local database can be found at <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/basic-local.rs"><code>pliantdb/examples/basic-local.rs</code></a>.</p>
<h2 id="multi-database-model-no-networking"><a class="header" href="#multi-database-model-no-networking">Multi-database model (No networking)</a></h2>
<p>This model is most similar to using multiple SQLite databases. In this mode, you interact with a <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a> that you spawn within your code.</p>
<pre class="mermaid">graph LR
  code{{Rust Code}}
  local[(pliantdb-local::Storage)]
  code &lt;--&gt; server
  server &lt;--&gt; local
</pre>
<p>If you look at the source behind <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html#method.open_local"><code>Database::open_local</code></a>, you'll see that the single-database model is using <code>Storage</code> under the hood.</p>
<h2 id="server-model-quic-or-websockets"><a class="header" href="#server-model-quic-or-websockets">Server model (QUIC or WebSockets)</a></h2>
<p>This model is most similar to using other document databases, like CouchDB or MongoDB. In this mode, you interact with a <a href="https://pliantdb.dev/main/pliantdb/client/struct.Client.html"><code>Client</code></a> that connects via either QUIC or WebSockets with a server. From the server code's perspective, this model is the same as the multi-database model, except that the server is listening for and responding to network traffic.</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[pliantdb-client]]
  server[[pliantdb-server]]
  local[(pliantdb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
</pre>
<p>A working example of this model can be found at <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/server.rs"><code>pliantdb/examples/server.rs</code></a>. When writing client/server applications that utilize <code>PliantDb</code>, you can have the <code>PliantDb</code> server running withing your server application. This means that your server still has the ability not use networking to interact with <code>PliantDb</code>. Regardless of if you run any other server code, your <code>PliantDb</code> server will be accessible through a <code>Client</code> over the network.</p>
<h2 id="coming-later-api-platform-model-quic-or-websockets"><a class="header" href="#coming-later-api-platform-model-quic-or-websockets">Coming Later: API Platform model (QUIC or WebSockets)</a></h2>
<p>If you're finding yourself developing an API for your application, and all of the consumers of this API are already connected to <code>PliantDb</code>, you may want to take advantage of the <code>platform</code> feature. This is not implemented yet, but the vision is that by implementing a few callbacks to handle and respond to your own serde-compatible request type, you can implement a custom API that can be used directly from clients. And, by taking advantage of the permissions model that will be developed, you can even expose this API over the internet safely.</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[pliantdb-client]]
  server[[pliantdb-server]]
  platform[[pliantdb-platform]]
  local[(pliantdb-local)]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; server
  server &lt;--&gt; local
  server-code &lt;--&gt; server
  server-code &lt;--&gt; platform
  platform &lt;--&gt; server
</pre>
<h2 id="coming-later-cluster-model"><a class="header" href="#coming-later-cluster-model">Coming Later: Cluster model</a></h2>
<p>When you're at the stage of scaling beyond a single server, you will be able to upgrade your server to a cluster using the hypothetical <code>pliantdb-cluster</code> crate. The clustering model is still being designed, but the goal is something similar to:</p>
<pre class="mermaid">graph LR
  client-code{{Rust Client Code}}
  server-code{{Rust Server Code}}
  client[[pliantdb-client]]
  server1[[server 1]]
  server2[[server 2]]
  server3[[server 3]]
  cluster[[pliantdb-cluster]]
  client-code &lt;--&gt; client
  client &lt;-. network .-&gt; cluster
  server-code &lt;--&gt; cluster
  cluster &lt;--&gt; server1
  cluster &lt;--&gt; server2
  cluster &lt;--&gt; server3
  server1 &lt;--&gt; server2
  server2 &lt;--&gt; server3
  server1 &lt;--&gt; server3
</pre>
<p>In this model, the local storage element is hidden; Each server has its own storage. This model is very similar from the viewpoint of your server and client code -- the primary difference is that the server-side connection is being established using the cluster crate. From the client's perspective, the cluster behaves as a single entity -- sending a request to any server node will result in the same result within the cluster.</p>
<p>All features of PliantDb will be designed to work in cluster mode seamlessly. <code>PubSub</code> will ensure that subscribers will receive messages regardless of which server they're connected to.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p><code>PliantDb</code> aims to offer the majority of its functionality in <a href="integration/./local.html">local operation</a>. The <a href="integration/./server.html">networked server</a> adds some functionality on top of the local version, but its main function is to add the ability to use networking to talk to the database.</p>
<p>Because of this model, it makes it easy to transition a local database to a networked database server. Start with whatever model fits your needs today, and when your neeeds change, <code>PliantDb</code> will adapt.</p>
<h2 id="when-to-use-the-a-hrefintegrationlocalhtmllocal-integrationa"><a class="header" href="#when-to-use-the-a-hrefintegrationlocalhtmllocal-integrationa">When to use the <a href="integration/./local.html">Local Integration</a></a></h2>
<ul>
<li>You're going to databases from one process at a time. <code>PliantDb</code> is designed for concurrency and can scale with the capabilities of the hardware. However, the underlying storage layer that <code>PliantDb</code> is built upon, <a href="http://sled.rs">sled</a>, does not support multiple processes writing its data simultaneously. If you need to access the database from multiple processes, the <a href="integration/./server.html">server integration</a> is what you should use. While it doesn't offer IPC communication today, a pull-request would be accepted to that added that functionality (along with the corresponding unit tests).</li>
<li>You have no public API/PubSub/access needs or have implemented those with another stack.</li>
</ul>
<h2 id="when-to-use-the-a-hrefintegrationserverhtmlserver-integrationa"><a class="header" href="#when-to-use-the-a-hrefintegrationserverhtmlserver-integrationa">When to use the <a href="integration/./server.html">Server Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one process or machine.</li>
<li>You are OK with downtime due to loss of service when the single server is offline. If you need to have a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> database, you should use the Cluster Integration (Coming Soon).</li>
<li>Your database load can be met with a single machine. If you have enough load that you need to share the processing power of multiple servers, you should use the Cluster Integration (Coming Soon)</li>
</ul>
<h2 id="coming-soon-when-to-use-the-a-hrefintegrationclusterhtmlcluster-integrationa"><a class="header" href="#coming-soon-when-to-use-the-a-hrefintegrationclusterhtmlcluster-integrationa">Coming Soon: When to use the <a href="integration/./cluster.html">Cluster Integration</a></a></h2>
<ul>
<li>You need to access databases from more than one machine.</li>
<li>You need a <a href="https://en.wikipedia.org/wiki/High_availability">highly-available</a> setup.</li>
<li>You need/want to split load between multiple machines.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-pliantdb-locally"><a class="header" href="#integrating-pliantdb-locally">Integrating PliantDb Locally</a></h1>
<p><code>PliantDb</code> supports multiple <a href="integration/../about/concepts/database.html">databases</a> and multiple <a href="integration/../about/concepts/schema.html">schemas</a>. However, for many applications, you only need a single database.</p>
<p>If you're only wanting a single database, the setup is straightforward: (from <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/basic-local.rs"><code>pliantdb/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let db = Database::&lt;Message&gt;::open_local(
    &quot;basic.pliantdb&quot;, 
    &amp;Configuration::default()
).await?;
</code></pre>
<p>Under the hood, <code>PliantDb</code> is creating a multi-database <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a> with a local <a href="https://pliantdb.dev/main/pliantdb/local/struct.Database.html"><code>Database</code></a> named <code>default</code> for you. If you need to switch to a multi-database model, you can open the storage and access the <code>default</code> database: (adapted from <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/basic-local-multidb.rs"><code>pliantdb/examples/basic-local.rs</code></a>)</p>
<pre><code class="language-rust noplayground no_run">let storage = Storage::open_local(
    &quot;basic.pliantdb&quot;,
    &amp;Configuration::default()
).await?;
storage.register_schema::&lt;Message&gt;().await?;
let db = storage.database::&lt;Message&gt;(&quot;default&quot;).await?;
</code></pre>
<p>You can register multiple schemas so that databases can be purpose-built.</p>
<h2 id="common-traits"><a class="header" href="#common-traits">Common Traits</a></h2>
<p>To help your code transition between different modes of accessing <code>PliantDb</code>, you can use these common traits to make your methods accept any style of <code>PliantDb</code> access.</p>
<ul>
<li><a href="https://pliantdb.dev/main/pliantdb/local/struct.Database.html"><code>Database</code></a> implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/kv.html"><code>Kv</code></a>, and <a href="integration/../traits/kv.html"><code>PubSub</code></a>.</li>
<li><a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a> implements <a href="integration/../traits/server_connection.html"><code>ServerConnection</code></a>.</li>
</ul>
<p>For example, <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/basic-local-multidb.rs"><code>pliantdb/examples/basic-local.rs</code></a> uses this helper method to insert a record:</p>
<pre><code class="language-rust noplayground no_run">async fn insert_a_message&lt;C: Connection&gt;(
    connection: &amp;C,
    value: &amp;str,
) -&gt; anyhow::Result&lt;()&gt; {
    connection
        .collection::&lt;Message&gt;()
        .push(&amp;Message {
            contents: String::from(value),
            timestamp: SystemTime::now(),
        })
        .await?;
    Ok(())
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-the-networked-pliantdb-server"><a class="header" href="#integrating-the-networked-pliantdb-server">Integrating the networked PliantDb Server</a></h1>
<p>To access <code>PliantDb</code> over the network, you're going to be writing two pieces of code: the server code and the client code.</p>
<h2 id="your-pliantdb-server"><a class="header" href="#your-pliantdb-server">Your PliantDb Server</a></h2>
<p>The first step is to create a <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Server</code></a>, which uses local <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a> under the hood. This means that if you're already using <code>PliantDb</code> in local mode, you can swap your usage of <a href="https://pliantdb.dev/main/pliantdb/local/struct.Storage.html"><code>Storage</code></a> with <a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html"><code>Server</code></a> in your server code without running your database through any tools. Here's the setup code from <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/server.rs"><code>pliantdb/examples/server.rs</code></a></p>
<pre><code class="language-rust noplayground no_run">    let server = Server::open(
        Path::new(&quot;server-data.pliantdb&quot;),
        Configuration::default(),
    )
    .await?;
    if server.certificate().await.is_err() {
        server
            .install_self_signed_certificate(&quot;example-server&quot;, true)
            .await?;
    }
    let certificate = server.certificate().await?;
    server.register_schema::&lt;Shape&gt;().await?;
    match server.create_database::&lt;Shape&gt;(&quot;my-database&quot;).await {
        Ok(()) =&gt; {}
        Err(Error::DatabaseNameAlreadyTaken(_)) =&gt; {}
        Err(err) =&gt; panic!(
            &quot;Unexpected error from server during create_database: {:?}&quot;,
            err
        ),
    }
</code></pre>
<p>Once you have a server initialized, calling <a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html#method.listen_on"><code>listen_on</code></a> will begin listening for connections on the port specified. This uses the preferred native protocol which uses UDP. If you find that UDP is not working for your setup or want to put <code>PliantDb</code> behind a load balancer that doesn't support UDP, you can enable WebSocket support and call <a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html#method.listen_for_websockets_on"><code>listen_for_websockets_on</code></a>.</p>
<p>You can call both, but since these functions don't return until the server is shut down, you should spawn them instead:</p>
<pre><code class="language-rust noplayground no_run">let task_server = server.clone();
tokio::spawn(async move {
    task_server.listen_on(5645).await
});
let server = server.clone();
tokio::spawn(async move {
    task_server.listen_for_websockets_on(&quot;localhost:8080&quot;).await
});
</code></pre>
<p>If you're not running any of your own code on the server, and you're only using one listening method, you can just await the listen method of your choice in your server's main.</p>
<!-- TODO: Certificates -->
<h2 id="from-the-client"><a class="header" href="#from-the-client">From the Client</a></h2>
<p>The <a href="https://pliantdb.dev/main/pliantdb/client/struct.Client.html"><code>Client</code></a> can support both the native protocol and WebSockets. It determines which protocol to use based on the scheme in the URL:</p>
<ul>
<li><code>pliantdb://host:port</code> will connect using the native <code>PliantDb</code> protocol.</li>
<li><code>ws://host:port</code> will connect using WebSockets.</li>
</ul>
<p>Here's how to connect, from <a href="https://github.com/khonsulabs/pliantdb/blob/main/pliantdb/examples/server.rs"><code>pliantdb/examples/server.rs</code></a>:</p>
<pre><code class="language-rust noplayground no_run">Client::new(
    Url::parse(&quot;pliantdb://localhost:5645&quot;)?,
    Some(certificate),
)
.await?
</code></pre>
<p>This is using a pinned certificate to connect. Other methods are supported, but better certificate management is coming soon.</p>
<!-- TODO: Certificates -->
<h2 id="common-traits-1"><a class="header" href="#common-traits-1">Common Traits</a></h2>
<ul>
<li><a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html"><code>Server</code></a> implements <a href="integration/../traits/server_connection.html"><code>ServerConnection</code></a>.</li>
<li><a href="https://pliantdb.dev/main/pliantdb/server/struct.Server.html#method.database"><code>Server::database()</code></a> returns a local <a href="https://pliantdb.dev/main/pliantdb/local/struct.Database.html"><code>Database</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/kv.html"><code>Kv</code></a>, and <a href="integration/../traits/kv.html"><code>PubSub</code></a>. Local access in the server executable doesn't go over the network.</li>
<li><a href="https://pliantdb.dev/main/pliantdb/client/struct.Client.html"><code>Client</code></a> implements <a href="integration/../traits/server_connection.html"><code>ServerConnection</code></a>.</li>
<li><a href="https://pliantdb.dev/main/pliantdb/client/struct.Client.html#method.database"><code>Client::database()</code></a> returns a <a href="https://pliantdb.dev/main/pliantdb/client/struct.RemoteDatabase.html"><code>RemoteDatabase</code></a>, which implements <a href="integration/../traits/connection.html"><code>Connection</code></a>, <a href="integration/../traits/kv.html"><code>Kv</code></a>, and <a href="integration/../traits/kv.html"><code>PubSub</code></a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="integrating-into-a-pliantdb-cluster"><a class="header" href="#integrating-into-a-pliantdb-cluster">Integrating into a PliantDb Cluster</a></h1>
<p>Coming Soon.</p>
<p>The goals of this feature are to make clustering simple. We hope to provide an experience that allows someone who is operating a networked server to desire two types of clusters:</p>
<h2 id="one-leader-mode"><a class="header" href="#one-leader-mode">One-leader mode</a></h2>
<p>When setting up a cluster initially, you will begin with one-leader mode. In this mode, you can add as many nodes to the cluster as you wish, but only one node will be processing all of the data updates. All nodes can handle requests, but requests that can't be served locally will be forwarded to the leader. This allows for the use of read-replicas to alleviate load in some read-heavy situations.</p>
<p>Another benefit of this mode are that it supports a two-node configuration. If you're scaling your app and need a reliable backup for quicker disaster recovery, you can operate a read replica and manually failover when the situation arises.</p>
<p>If you decide to allow automatic failover in this mode, there is a chance for data loss, as the leader does not wait for read-replicas to synchronize data. Any transactions that committed and were not synchronized before the outage occurred would not be on the other servers. Thus, this mode is <em>not intended for high-availability configurations</em>, although some users may elect to use it in such a configuration knowing these limitations.</p>
<h2 id="quorum-mode"><a class="header" href="#quorum-mode">Quorum mode</a></h2>
<p>Once you have a cluster with at least 3 nodes, you can switch the cluster into quorum mode. For any given <code>N</code> nodes, all requests must reach an agreed response by <code>N / 2 + 1</code> members. For example, in a cluster of 3 nodes, there must be 2 successful responses before a client can receive a response to its request.</p>
<p>In quorum mode, your data is divided into shards and those shards replicated throughout the cluster onto at least 3 nodes (configurable). Initially, with just 3 nodes available, the only benefits are having a highly-available cluster with no data loss during when a single node goes down.</p>
<p>As you add more nodes to your cluster, however, you can re-balance your databases to move shards. The author of PliantDb did not enjoy this process in CouchDB when he had to do it and aims to make these tools easy and effortless to use. Ideally, there would be a low-maintenance mode that would allow the cluster to re-shard itself authomatically during allowed maintenance periods, ensuring data is distributed more evenly amongst the cluster.</p>
<p>Additional long-term dreams of quorum mode include the ability to customize node selection criteria on a per-database basis. The practical use of node selection is to ensure that at least 3 unique nodes are picked for each shard. However, allowing custom logic to evaluate which nodes should be selected for any database would allow ultimate flexibility. For example, if you have a globally deployed application, and you have some data that is geographically specific, you could locate each region's database on nodes within those locations' data centers.</p>
<h2 id="when"><a class="header" href="#when">When?</a></h2>
<p>Clustering is an important part of the design of <a href="https://github.com/khonsulabs/cosmicverge">Cosmic Verge</a>. As such, it is a priority for us to work on. But, the overall game is a very large project, so we hesitate to make any promises on timelines.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="connection"><a class="header" href="#connection">Connection</a></h1>
<p><em>Coming soon.</em></p>
<p>This is an <a href="https://lib.rs/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://pliantdb.dev/main/pliantdb/core/connection/trait.Connection.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="serverconnection"><a class="header" href="#serverconnection">ServerConnection</a></h1>
<p><em>Coming soon.</em></p>
<p>This is an <a href="https://lib.rs/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://pliantdb.dev/main/pliantdb/core/networking/trait.ServerConnection.html">messy documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pubsub-traits"><a class="header" href="#pubsub-traits">PubSub Traits</a></h1>
<p><em>Coming soon.</em></p>
<p>These are <a href="https://lib.rs/crates/async-trait">async traits</a>, which unfortunately yield messy documentation: <a href="https://pliantdb.dev/main/pliantdb/core/pubsub/trait.PubSub.html">PubSub</a> and <a href="https://pliantdb.dev/main/pliantdb/core/pubsub/trait.Subscriber.html">Subscriber</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="key-value-store"><a class="header" href="#key-value-store">Key-Value Store</a></h1>
<p><em>Coming soon.</em></p>
<p>This is an <a href="https://lib.rs/crates/async-trait">async trait</a>, which unfortunately yields <a href="https://pliantdb.dev/main/pliantdb/core/kv/trait.Kv.html">messy documentation</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
                <script type="text/javascript" src="mermaid.min.js"></script>
                <script type="text/javascript" src="mermaid-init.js"></script>
        
                        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
                
    </body>
</html>
